<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Backend interview</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Книжка для подготовки к собеседованию на должность backend developer">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Введение</a></li><li class="chapter-item expanded "><a href="algostruct/index.html"><strong aria-hidden="true">1.</strong> Алгоритмы и Структуры Данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algostruct/structBasics.html"><strong aria-hidden="true">1.1.</strong> Базовые структуры</a></li><li class="chapter-item expanded "><a href="algostruct/array.html"><strong aria-hidden="true">1.2.</strong> Массив</a></li><li class="chapter-item expanded "><a href="algostruct/hashTable.html"><strong aria-hidden="true">1.3.</strong> Хэш-Таблица</a></li><li class="chapter-item expanded "><a href="algostruct/tree.html"><strong aria-hidden="true">1.4.</strong> Дерево</a></li><li class="chapter-item expanded "><a href="algostruct/graph.html"><strong aria-hidden="true">1.5.</strong> Граф</a></li><li class="chapter-item expanded "><a href="algostruct/probability.html"><strong aria-hidden="true">1.6.</strong> Вероятностные</a></li><li class="chapter-item expanded "><a href="algostruct/crypto.html"><strong aria-hidden="true">1.7.</strong> Криптография</a></li><li class="chapter-item expanded "><a href="algostruct/unsorted.html"><strong aria-hidden="true">1.8.</strong> Разное</a></li></ol></li><li class="chapter-item expanded "><a href="db/index.html"><strong aria-hidden="true">2.</strong> Базы Данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/dBTheory/index.html"><strong aria-hidden="true">2.1.</strong> Теория Баз Данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/dBTheory/transactions.html"><strong aria-hidden="true">2.1.1.</strong> Транзакции</a></li><li class="chapter-item expanded "><a href="db/dBTheory/normalForms.html"><strong aria-hidden="true">2.1.2.</strong> Нормальные формы</a></li><li class="chapter-item expanded "><a href="db/dBTheory/distrubedDb/index.html"><strong aria-hidden="true">2.1.3.</strong> Распределенные БД</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/dBTheory/distrubedDb/replication.html"><strong aria-hidden="true">2.1.3.1.</strong> Репликация</a></li><li class="chapter-item expanded "><a href="db/dBTheory/distrubedDb/sharding.html"><strong aria-hidden="true">2.1.3.2.</strong> Шардинг</a></li><li class="chapter-item expanded "><a href="db/dBTheory/distrubedDb/unsorted.html"><strong aria-hidden="true">2.1.3.3.</strong> Разное</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="db/specific/index.html"><strong aria-hidden="true">2.2.</strong> Конкретные БД</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/specific/mysql/index.html"><strong aria-hidden="true">2.2.1.</strong> MySql</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/specific/mysql/architecture.html"><strong aria-hidden="true">2.2.1.1.</strong> Архитектура MySql</a></li><li class="chapter-item expanded "><a href="db/specific/mysql/concurency.html"><strong aria-hidden="true">2.2.1.2.</strong> Конкурентный доступ</a></li><li class="chapter-item expanded "><a href="db/specific/mysql/indexes.html"><strong aria-hidden="true">2.2.1.3.</strong> Индексы</a></li><li class="chapter-item expanded "><a href="db/specific/mysql/sql.html"><strong aria-hidden="true">2.2.1.4.</strong> Основы SQL</a></li><li class="chapter-item expanded "><a href="db/specific/mysql/explain.html"><strong aria-hidden="true">2.2.1.5.</strong> Explain</a></li><li class="chapter-item expanded "><a href="db/specific/mysql/unsorted.html"><strong aria-hidden="true">2.2.1.6.</strong> Разное</a></li></ol></li><li class="chapter-item expanded "><a href="db/specific/postgreSql/index.html"><strong aria-hidden="true">2.2.2.</strong> PostgreSql</a></li><li class="chapter-item expanded "><a href="db/specific/noSql/index.html"><strong aria-hidden="true">2.2.3.</strong> NoSql</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/specific/noSql/redis.html"><strong aria-hidden="true">2.2.3.1.</strong> Redis</a></li><li class="chapter-item expanded "><a href="db/specific/noSql/memcached.html"><strong aria-hidden="true">2.2.3.2.</strong> Memcaced</a></li><li class="chapter-item expanded "><a href="db/specific/noSql/tarantool.html"><strong aria-hidden="true">2.2.3.3.</strong> Tarantool</a></li><li class="chapter-item expanded "><a href="db/specific/noSql/mongo.html"><strong aria-hidden="true">2.2.3.4.</strong> Mongo</a></li></ol></li><li class="chapter-item expanded "><a href="db/specific/clickhouse.html"><strong aria-hidden="true">2.2.4.</strong> ClickHouse</a></li><li class="chapter-item expanded "><a href="db/specific/messages/index.html"><strong aria-hidden="true">2.2.5.</strong> Брокеры сообщений</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="db/specific/messages/rabbit.html"><strong aria-hidden="true">2.2.5.1.</strong> Rabbit</a></li><li class="chapter-item expanded "><a href="db/specific/messages/kafka.html"><strong aria-hidden="true">2.2.5.2.</strong> Kafka</a></li><li class="chapter-item expanded "><a href="db/specific/messages/nats.html"><strong aria-hidden="true">2.2.5.3.</strong> Nats</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="architecture/index.html"><strong aria-hidden="true">3.</strong> Архитектура</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/oopBase.html"><strong aria-hidden="true">3.1.</strong> Основы ООП</a></li><li class="chapter-item expanded "><a href="architecture/gof.html"><strong aria-hidden="true">3.2.</strong> Паттерны GoF(Банда 4)</a></li><li class="chapter-item expanded "><a href="architecture/principles.html"><strong aria-hidden="true">3.3.</strong> Принципы хорошей архитектуры</a></li><li class="chapter-item expanded "><a href="architecture/architecturesPatterns.html"><strong aria-hidden="true">3.4.</strong> Архитектурные паттерны</a></li><li class="chapter-item expanded "><a href="architecture/ddd.html"><strong aria-hidden="true">3.5.</strong> DDD</a></li><li class="chapter-item expanded "><a href="architecture/microserices/index.html"><strong aria-hidden="true">3.6.</strong> Микросервисы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/microserices/integration.html"><strong aria-hidden="true">3.6.1.</strong> Паттерны и протоколы интеграции</a></li><li class="chapter-item expanded "><a href="architecture/microserices/monolithSeparation.html"><strong aria-hidden="true">3.6.2.</strong> Способы распиливания монолита</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/uncategorized.html"><strong aria-hidden="true">3.7.</strong> Разное</a></li></ol></li><li class="chapter-item expanded "><a href="php/index.html"><strong aria-hidden="true">4.</strong> PHP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="php/innovations.html"><strong aria-hidden="true">4.1.</strong> Фичи новых версий</a></li><li class="chapter-item expanded "><a href="php/internals.html"><strong aria-hidden="true">4.2.</strong> PHP Internals</a></li><li class="chapter-item expanded "><a href="php/frameworks/index.html"><strong aria-hidden="true">4.3.</strong> Фреймворки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="php/frameworks/laravel.html"><strong aria-hidden="true">4.3.1.</strong> Laravel</a></li><li class="chapter-item expanded "><a href="php/frameworks/symfony.html"><strong aria-hidden="true">4.3.2.</strong> Symfony</a></li></ol></li><li class="chapter-item expanded "><a href="php/uncategorized.html"><strong aria-hidden="true">4.4.</strong> Разное</a></li></ol></li><li class="chapter-item expanded "><a href="goLang/index.html"><strong aria-hidden="true">5.</strong> GoLang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="goLang/types.html"><strong aria-hidden="true">5.1.</strong> Типы данных</a></li><li class="chapter-item expanded "><a href="goLang/concurrency/index.html"><strong aria-hidden="true">5.2.</strong> Сoncurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="goLang/concurrency/chanel.html"><strong aria-hidden="true">5.2.1.</strong> Каналы</a></li><li class="chapter-item expanded "><a href="goLang/concurrency/gouritine.html"><strong aria-hidden="true">5.2.2.</strong> Горутины</a></li><li class="chapter-item expanded "><a href="goLang/concurrency/sync.html"><strong aria-hidden="true">5.2.3.</strong> Sync</a></li><li class="chapter-item expanded "><a href="goLang/concurrency/patterns.html"><strong aria-hidden="true">5.2.4.</strong> Паттерны</a></li></ol></li><li class="chapter-item expanded "><a href="goLang/scheduler.html"><strong aria-hidden="true">5.3.</strong> Планировщик</a></li><li class="chapter-item expanded "><a href="goLang/memory.html"><strong aria-hidden="true">5.4.</strong> Управление памятью</a></li><li class="chapter-item expanded "><a href="goLang/ecosystem.html"><strong aria-hidden="true">5.5.</strong> Экосистема</a></li></ol></li><li class="chapter-item expanded "><a href="javascript.html"><strong aria-hidden="true">6.</strong> JavaScript</a></li><li class="chapter-item expanded "><a href="ib.html"><strong aria-hidden="true">7.</strong> Информационная безопасность</a></li><li class="chapter-item expanded "><a href="git.html"><strong aria-hidden="true">8.</strong> Git</a></li><li class="chapter-item expanded "><a href="network/index.html"><strong aria-hidden="true">9.</strong> Основы сетей</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network/serverIteractions.html"><strong aria-hidden="true">9.1.</strong> Взаимодействие с веб-сервером</a></li><li class="chapter-item expanded "><a href="network/http.html"><strong aria-hidden="true">9.2.</strong> HTTP</a></li><li class="chapter-item expanded "><a href="network/tls.html"><strong aria-hidden="true">9.3.</strong> TLS</a></li><li class="chapter-item expanded "><a href="network/dns.html"><strong aria-hidden="true">9.4.</strong> DNS</a></li><li class="chapter-item expanded "><a href="network/tcp_ip.html"><strong aria-hidden="true">9.5.</strong> TCP/IP</a></li><li class="chapter-item expanded "><a href="network/networkModels.html"><strong aria-hidden="true">9.6.</strong> Сетевые модели</a></li><li class="chapter-item expanded "><a href="network/realTime.html"><strong aria-hidden="true">9.7.</strong> realTime взаимодействие с сервером</a></li><li class="chapter-item expanded "><a href="network/whatHappenWhen.html"><strong aria-hidden="true">9.8.</strong> Что происходит при нажатии на g</a></li></ol></li><li class="chapter-item expanded "><a href="os.html"><strong aria-hidden="true">10.</strong> Операционые системы</a></li><li class="chapter-item expanded "><a href="devops/index.html"><strong aria-hidden="true">11.</strong> Системное администрирование</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="devops/linux.html"><strong aria-hidden="true">11.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="devops/virtualization/index.html"><strong aria-hidden="true">11.2.</strong> Основы виртуализации</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="devops/virtualization/docker.html"><strong aria-hidden="true">11.2.1.</strong> Docker</a></li><li class="chapter-item expanded "><a href="devops/virtualization/kubernetes.html"><strong aria-hidden="true">11.2.2.</strong> Kubernetes</a></li></ol></li><li class="chapter-item expanded "><a href="devops/deployment.html"><strong aria-hidden="true">11.3.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="devops/monitoring.html"><strong aria-hidden="true">11.4.</strong> Мониторинг</a></li></ol></li><li class="chapter-item expanded "><a href="test.html"><strong aria-hidden="true">12.</strong> Тестирование</a></li><li class="chapter-item expanded "><a href="unsorted/index.html"><strong aria-hidden="true">13.</strong> Разное</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unsorted/bits.html"><strong aria-hidden="true">13.1.</strong> Побитовые операции</a></li><li class="chapter-item expanded "><a href="unsorted/types.html"><strong aria-hidden="true">13.2.</strong> Типизация</a></li><li class="chapter-item expanded "><a href="unsorted/unicode.html"><strong aria-hidden="true">13.3.</strong> Юникод</a></li></ol></li><li class="chapter-item expanded "><a href="devmethods.html"><strong aria-hidden="true">14.</strong> Методологии разработки</a></li><li class="chapter-item expanded "><a href="checkList.html"><strong aria-hidden="true">15.</strong> ЧекЛист</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Backend interview</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arturpanteleev/phpInterview" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Памятка-phpgolang-разработчику-для-подготовки-к-собеседованиям"><a class="header" href="#Памятка-phpgolang-разработчику-для-подготовки-к-собеседованиям">Памятка PHP/GoLang разработчику для подготовки к собеседованиям</a></h1>
<p>Всем привет, меня зовут Артур Пантелеев и вы читаете мою <em>книгу</em> о собеседованиях.</p>
<p>Это методичка(краткий справочник) по темам/вопросам, знание которых может понадобиться при собеседовании на бэкендера (с уклоном в <strong>php</strong>/Golang) и на работе.</p>
<p><strong>Не является</strong> исчерпывающим руководством, а служит лишь <strong>тезисным помощником</strong> в повторении нужного материала для подготовки к собеседованию и структурированию собственных знаний. Также тут есть много полезных ссылок на дополнительные материалы по каждой теме.</p>
<p>Вопросы можно задать в чат <a href="https://t.me/phpgeeks">@phpgeeks</a> или в лс <a href="https://t.me/arturpanteleev">@arturpanteleev</a></p>
<p>Улучшения/дополнения шлите сюда <a href="https://github.com/arturpanteleev/phpInterview">github.com/arturpanteleev/phpInterview</a></p>
<p><em>P.S. Первый кирпич в создание данного пособия заложил, увековечив здесь своё имя, Сергей Пронин.</em></p>
<img src="media/image1.jpeg" height="500px" /><div style="break-before: page; page-break-before: always;"></div><h1 id="Алгоритмы-и-структуры-данных"><a class="header" href="#Алгоритмы-и-структуры-данных">Алгоритмы и структуры данных</a></h1>
<ul>
<li><a href="algostruct/structBasics.html">Базовые структуры</a></li>
<li><a href="algostruct/array.html">Массив</a></li>
<li><a href="algostruct/hashTable.html">Хэш-Таблица</a></li>
<li><a href="algostruct/tree.html">Дерево</a></li>
<li><a href="algostruct/graph.html">Граф</a></li>
<li><a href="algostruct/crypto.html">Криптография</a></li>
<li><a href="algostruct/probability.html">Вероятностные</a></li>
<li><a href="algostruct/unsorted.html">Разные алгоритмы</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Основные-структуры-данных"><a class="header" href="#Основные-структуры-данных">Основные структуры данных</a></h1>
<h3 id="Ассоциативный-массив"><a class="header" href="#Ассоциативный-массив">Ассоциативный массив</a></h3>
<p>Абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу.</p>
<h3 id="Стек-lifo"><a class="header" href="#Стек-lifo">Стек (LIFO)</a></h3>
<p>Абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).</p>
<h3 id="Очередь-fifo"><a class="header" href="#Очередь-fifo">Очередь (FIFO)</a></h3>
<p>Абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел» (FIFO, First In — First Out). Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется. </p>
<h3 id="Двусвязная-очередь"><a class="header" href="#Двусвязная-очередь">Двусвязная очередь</a></h3>
<p>Двусвязная очередь (жарг. дэк, дек от англ. deque — double ended queue; двухсторонняя очередь, двусвязный список, очередь с двумя концами) — структура данных, в которой элементы можно добавлять и удалять как в начало, так и в конец, то есть дисциплинами обслуживания являются одновременно FIFO и LIFO.</p>
<h3 id="Связный-список"><a class="header" href="#Связный-список">Связный список</a></h3>
<p>Базовая динамическая структура данных, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.</p>
<h3 id="Линейный-однонаправленный-список"><a class="header" href="#Линейный-однонаправленный-список">Линейный однонаправленный список</a></h3>
<p>Структура данных, состоящая из элементов одного типа, связанных между собой последовательно посредством указателей. Каждый элемент списка имеет указатель на следующий элемент. Последний элемент списка указывает на NULL. Элемент, на который нет указателя, является первым (головным) элементом списка. Здесь ссылка в каждом узле указывает на следующий узел в списке. В односвязном списке можно передвигаться только в сторону конца списка. Узнать адрес предыдущего элемента, опираясь на содержимое текущего узла, невозможно.</p>
<h3 id="Двусвязный-список-двунаправленный-связный-список"><a class="header" href="#Двусвязный-список-двунаправленный-связный-список">Двусвязный список (двунаправленный связный список)</a></h3>
<p>Здесь ссылки в каждом узле указывают на предыдущий и на последующий узел в списке. По двусвязному списку можно эффективно передвигаться в любом направлении — как к началу, так и к концу. В этом списке проще производить удаление и перестановку элементов, так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.</p>
<h3 id="Кольцевой-связный-список"><a class="header" href="#Кольцевой-связный-список">Кольцевой связный список</a></h3>
<p>Разновидностью связных списков является кольцевой (циклический, замкнутый) список. Он тоже может быть односвязным или двусвязным. Последний элемент кольцевого списка содержит указатель на первый, а первый (в случае двусвязного списка) — на последний.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="http://algolist.manual.ru/ds/index.php">Структуры данных. Algolist</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Массив"><a class="header" href="#Массив">Массив</a></h1>
<p>Структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов, принимающих целые (или приводимые к целым) значения из некоторого заданного непрерывного диапазона. </p>
<h2 id="Сортировки-массивов"><a class="header" href="#Сортировки-массивов">Сортировки массивов</a></h2>
<h3 id="Сортировка-пузырьком--bubble-sort"><a class="header" href="#Сортировка-пузырьком--bubble-sort">Сортировка пузырьком / Bubble sort</a></h3>
<p>Или <strong>сортировка простыми обменами</strong>. Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. Если за проход не произошло ни одного обмена, то массив отсортирован. Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец. Очевидно, не более чем после n итераций массив будет отсортирован. </p>
<pre><code class="language-php">&lt;?php
    
/**
 * Worst O(n^2)
 * Average O(n^2)
 * Best O(n)
 */
function bubbleSort(array $array): array {
    $length = count($array);
    for ($i = $length - 1; $i &gt; 0; $i--) {
        $changes = false;
        for ($j = 0; $j &lt; $i; $j++) {
            if ($array[$j] &gt; $array[$j + 1]) {
                [$array[$j], $array[$j + 1]] = [$array[$j + 1], $array[$j]];
                $changes = true;
            }
        }
        if (!$changes) {
            return $array;
        }
    }

    return $array;
}

print_r(bubbleSort([5, 25, 10, 7, 6, 20, 21, 1, 2, 13]));
</code></pre>
<h3 id="Сортировка-вставками--insertion-sort"><a class="header" href="#Сортировка-вставками--insertion-sort">Сортировка вставками / Insertion sort</a></h3>
<p>Элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.</p>
<pre><code class="language-php">&lt;?php

/**
 * Worst O(n^2)
 * Average O(n^2)
 * Best O(n)
 */ 
function insertSort(array $arr): array {
    $count = count($arr);  
    for ($i = 1; $i &lt; $count; $i++) {
        for ($j = $i; $j &gt;= 1 &amp;&amp; $arr[$j] &lt; $arr[$j-1]; $j--) {
           [$arr[$j], $arr[$j-1]] = [$arr[$j-1], $arr[$j]];
        }
    }
  
    return $arr;
}

print_r(insertSort([3,4,1,2,5,9,6,7,8]));

</code></pre>
<h3 id="Сортировка-выбором--selection-sort"><a class="header" href="#Сортировка-выбором--selection-sort">Сортировка выбором / Selection sort</a></h3>
<p>На очередной итерации будем находить минимум в массиве после текущего элемента и менять его с ним, если надо. Таким образом, после i-ой итерации первые i элементов будут стоять на своих местах. Нужно отметить, что эту сортировку можно реализовать двумя способами – сохраняя минимум и его индекс или просто переставляя текущий элемент с рассматриваемым, если они стоят в неправильном порядке. </p>
<pre><code class="language-php">&lt;?php

/**
 * Worst O(n^2)
 * Average O(n^2)
 * Best O(n^2)
 */
function selectionSort(array $arr): array 
{
    $count = count($arr);
    
    for ($i = 0; $i &lt; $count - 1; $i++) {
        $min = $i;
        
        for ($j = $i + 1; $j &lt; $count; $j++) {
            if ($arr[$j] &lt; $arr[$min]) {
                $min = $j;
            }
        }
        
        if ($min != $i) {
            [$arr[$i], $arr[$min]] = [$arr[$min], $arr[$i]];
        }
    }
    
    return $arr;
}

$array = [3,4,1,2,5,9,6,7,8];
print_r(selectionSort($array));
</code></pre>
<h3 id="Быстрая-сортировка--quicksort"><a class="header" href="#Быстрая-сортировка--quicksort">Быстрая сортировка / Quicksort</a></h3>
<p>Выберем некоторый опорный элемент(пивот). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Рекурсивно вызовемся от каждой из частей. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного. Асимптотика: <strong>O(n logn)</strong> в среднем и лучшем случае, <strong>O(n^2)</strong>. Наихудшая оценка достигается при неудачном выборе опорного элемента. Идем одновременно слева и справа, находим пару элементов, таких, что левый элемент больше опорного, а правый меньше, и меняем их местами. </p>
<pre><code class="language-php">&lt;?php

/**
 * Worst O(n^2)
 * Average O(n logn)
 * Best  O(n logn)
 */ 
function quick(array $arr) : array {
    if (count($arr) &lt; 2) {
        return $arr;
    } 
    
    $pivot = (int)(count($arr) / 2); // самый тупой выбор опорника 
    
    $less_arr = [];
    $more_arr = [];
    
    for ($i = 0; $i &lt;count($arr); $i++) {
        if ($i == $pivot) {
            continue;
        }
        if ($arr[$i] &lt; $arr[$pivot]) {
            $less_arr[] = $arr[$i];
        } else {
            $more_arr[] = $arr[$i];
        }
    }
     
    return array_merge(quick($less_arr), [$arr[$pivot]], quick($more_arr));
}


print_r(quick([3, 4, 1, 2, 5, 9, 6, 7, 8]));
</code></pre>
<h3 id="Сортировка-слиянием--merge-sort"><a class="header" href="#Сортировка-слиянием--merge-sort">Сортировка слиянием / Merge sort</a></h3>
<p>Сортировка, основанная на парадигме «разделяй и властвуй». Разделим массив пополам, рекурсивно отсортируем части, после чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Слияние работает за <strong>O(n)</strong>, уровней всего logn, поэтому асимптотика <strong>O(n logn)</strong>. Эффективно заранее создать временный массив и передать его в качестве аргумента функции. Эта сортировка рекурсивна, как и быстрая, а потому возможен переход на квадратичную при небольшом числе элементов.</p>
<pre><code class="language-php">&lt;?php

 /**
 * Worst O(n log n)
 * Average O(n log n)
 * Best O(n log n)	
 */ 
function merge(array $arr) : array {
    
    if (count($arr) &lt; 2) {
        return $arr;
    }
    
    if (count($arr) == 2) {
        if ($arr[0] &lt;  $arr[1]) {
            return $arr;
        } else {
            return [$arr[1], $arr[0]];
        }
    } 
    
    $halved = array_chunk($arr, ceil(count($arr)/2)); // пополам
   
    // разбиваем и сортируем каждую половину
    $h1 = merge($halved[0]);
    $h2 = merge($halved[1]);

    //сливаем
    $res = [];
    for ($i = 0, $j = 0; $i &lt; count($h1) || $j &lt; count($h2); ) {
        
        if (!isset($h1[$i])) {
            $res[] = $h2[$j];
            $j++;
            continue;
        }
        
        if (!isset($h2[$j])) {
            $res[] = $h1[$i];
            $i++;
            continue;
        }
        
       if ($h1[$i] &lt; $h2[$j]) {
           $res[] = $h1[$i];
           $i++;
       } else {
           $res[] = $h2[$j];
           $j++; 
       }
    }

    return $res;
}

var_dump(merge([3,34,1,33,5,213213,99,1,1,0,0, -123]));
</code></pre>
<h3 id="Сортировка-кучей"><a class="header" href="#Сортировка-кучей">Сортировка кучей</a></h3>
<p><strong>Пирамидальная сортировка</strong> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> <em>Heapsort</em>, «Сортировка кучей») — <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8">алгоритм сортировки</a>, работающий в худшем, в среднем и в лучшем случае (то есть гарантированно) за <strong>O(n*log n)</strong> операций при сортировке <strong>n</strong> элементов. Количество применяемой служебной памяти не зависит от размера массива <strong>O(1)</strong>. Может рассматриваться как усовершенствованная сортировка пузырьком, в которой элемент всплывает/тонет по многим путям.</p>
<pre><code class="language-php">&lt;?php

// Реализация пирамидальной сортировки на Php

// Процедура для преобразования в двоичную кучу поддерева с корневым узлом i, что является
// индексом в arr[]. n - размер кучи

function heapify(&amp;$arr, $n, $i)
{
    $largest = $i; // Инициализируем наибольший элемент как корень
    $l = 2*$i + 1; // левый = 2*i + 1
    $r = 2*$i + 2; // правый = 2*i + 2

    // Если левый дочерний элемент больше корня
    if ($l &lt; $n &amp;&amp; $arr[$l] &gt; $arr[$largest])
        $largest = $l;

    //Если правый дочерний элемент больше, чем самый большой элемент на данный момент
    if ($r &lt; $n &amp;&amp; $arr[$r] &gt; $arr[$largest])
        $largest = $r;

    // Если самый большой элемент не корень
    if ($largest != $i)
    {
        $swap = $arr[$i];
        $arr[$i] = $arr[$largest];
        $arr[$largest] = $swap;

        // Рекурсивно преобразуем в двоичную кучу затронутое поддерево
        heapify($arr, $n, $largest);
    }
}

//Основная функция, выполняющая пирамидальную сортировку
function heapSort(&amp;$arr, $n)
{
    // Построение кучи (перегруппируем массив)
    for ($i = $n / 2 - 1; $i &gt;= 0; $i--)
        heapify($arr, $n, $i);

    //Один за другим извлекаем элементы из кучи
    for ($i = $n-1; $i &gt;= 0; $i--)
    {
        // Перемещаем текущий корень в конец
        $temp = $arr[0];
            $arr[0] = $arr[$i];
            $arr[$i] = $temp;

        // вызываем процедуру heapify на уменьшенной куче
        heapify($arr, $i, 0);
    }
}

/* Вспомогательная функция для вывода на экран массива размера n */
function printArray(&amp;$arr, $n)
{
    for ($i = 0; $i &lt; $n; ++$i)
        echo ($arr[$i].&quot; &quot;) ; 
} 

$arr = array(12, 11, 13, 5, 6, 7);
$n = sizeof($arr)/sizeof($arr[0]);
heapSort($arr, $n);
printArray($arr , $n);

</code></pre>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/post/204600/">Пузырьковая сортировка и все-все-все</a></li>
<li><a href="http://algolist.manual.ru/sort/">Алгоритмы сортировки</a></li>
<li><a href="https://m.habr.com/post/335920/">Описание алгоритмов сортировки и сравнение их производительности</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Хэш-таблица"><a class="header" href="#Хэш-таблица">Хэш таблица</a></h1>
<p><strong>Хеш-таблица(hash table)</strong> — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары <code>ключ =&gt; значение</code> и выполнять три операции:</p>
<ul>
<li>добавление</li>
<li>поиск </li>
<li>удаление</li>
</ul>
<p>Главное свойство hash-таблиц — все операции(вставка, поиск и удаление) в среднем выполняются за <strong>O(1)</strong>, среднее время поиска по ней также равно <strong>O(1)</strong> и <strong>O(n)</strong> в худшем случае.</p>
<p>Выполнение операции в хеш-таблице начинается с вычисления <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">хеш-функции</a> от ключа. Получающееся хеш-значение играет роль индекса. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива. Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BB%D0%BB%D0%B8%D0%B7%D0%B8%D1%8F_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">коллизией</a>. Существует несколько способов разрешения коллизий.</p>
<h3 id="Метод-цепочек"><a class="header" href="#Метод-цепочек">Метод цепочек</a></h3>
<p>Этот метод часто называют <strong>открытым хешированием</strong>. Его суть проста — элементы с одинаковым хешем попадают в одну ячейку в виде <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA">связного списка</a>(возможны оптимизации, где вместо списка будет дерево). Каждая ячейка массива <em>H</em> является указателем на связный список(цепочку) пар ключ-значение, соответствующих одному и тому же хеш-значению ключа. Коллизии просто приводят к тому, что появляются цепочки длиной более одного элемента.</p>
<p><img src="algostruct/../media/algostruct/collision_chain.png" alt="" /></p>
<h3 id="Открытая-индексация-или-закрытое-хеширование"><a class="header" href="#Открытая-индексация-или-закрытое-хеширование">Открытая индексация (или закрытое хеширование)</a></h3>
<p>В массиве <em>H</em> хранятся сами пары ключ-значение. Алгоритм вставки элемента проверяет ячейки массива <em>H</em> в некотором порядке (<strong>последовательность проб</strong>) до тех пор, пока не будет найдена первая свободная ячейка, в которую и будет записан новый элемент. </p>
<p>В общем случае, она зависит только от ключа элемента, то есть это последовательность <em>h</em>0(<em>x</em>), <em>h</em>1(<em>x</em>), …, <em>h**n</em> — 1(<em>x</em>), где <em>x</em> — ключ элемента, а <em>h**i</em>(<em>x</em>) — произвольные функции, сопоставляющие каждому ключу ячейку в хеш-таблице. Первый элемент в последовательности, как правило, равен значению некоторой хеш-функции от ключа, а остальные считаются от него одним из приведённых ниже способов. Для успешной работы алгоритмов поиска последовательность проб должна быть такой, чтобы все ячейки хеш-таблицы оказались просмотренными ровно по одному разу.</p>
<p>Алгоритм поиска просматривает ячейки хеш-таблицы в том же самом порядке, что и при вставке, до тех пор, пока не найдется либо элемент с искомым ключом, либо свободная ячейка (что означает отсутствие элемента в хеш-таблице). Этот порядок вычисляется на лету, что позволяет сэкономить на памяти для указателей, требующихся в хеш-таблицах с цепочками.</p>
<p><img src="algostruct/../media/algostruct/collision_open_hash.png" alt="" /></p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="http://aliev.me/runestone/SortSearch/Hashing.html">Хэширование</a></li>
<li><a href="https://www.wikiwand.com/ru/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">Хэш-Таблица</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Дерево"><a class="header" href="#Дерево">Дерево</a></h1>
<p>Иерархическая структура элементов, называемыми узлами (вершинами). На самом верхнем уровне имеется только один узел — корень дерева. Каждый узел, кроме корня, связан только с одним узлом на более высоком уровне. Каждый элемент может быть связан ребром с одним или несколькими элементами на следующем, более низком, уровне. Элементы, не имеющий потомков называются листьями. От корня до любой вершины существует один путь. Любой узел дерева с потомками на всех уровнях так же образует дерево, называемое поддеревом.</p>
<p><strong>Термины:</strong></p>
<ul>
<li><strong>Корневой узел</strong> — самый верхний узел дерева.</li>
<li><strong>Корень</strong> — одна из вершин, по желанию наблюдателя.</li>
<li><strong>Лист</strong>, <strong>листовой или терминальный узел</strong> — узел, не имеющий дочерних элементов.</li>
<li><strong>Внутренний узел</strong> — любой узел дерева, имеющий потомков, и таким образом, не являющийся листовым узлом.</li>
<li>Дерево считается <strong>ориентированным</strong>, если в корень не заходит ни одно ребро.</li>
<li><strong>Полный сцепленный ключ</strong> — идентификатор записи, который образуется путём конкатенации всех ключей экземпляров родительских записей (групп).</li>
<li><strong>M-арное дерево</strong> - число поддеревьев данного узла образует степень узла, максимальное значение m степени всех узлов дерева является степенью дерева. Дерево степени 2 называется бинарным деревом. Если в дереве на каждом уровне задан порядок следования вершин, то такое дерево называется упорядоченным</li>
</ul>
<h2 id="Бинарное-дерево-поиска"><a class="header" href="#Бинарное-дерево-поиска">Бинарное дерево поиска</a></h2>
<p><code>Поиск -  O(log n); Вставка -  O(log n); Удаление -  O(log n);</code></p>
<p>Это двоичное дерево, для которого выполняются следующие условия:</p>
<ul>
<li>
<p>У каждого узла не более двух детей(так как бинарное).</p>
</li>
<li>
<p>У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X.</p>
</li>
<li>
<p>У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равно, нежели значение ключа данных самого узла X.</p>
<p><img src="algostruct/../media/image2.png" alt="" /></p>
</li>
</ul>
<h3 id="АВЛ-Дерево"><a class="header" href="#АВЛ-Дерево">АВЛ-Дерево</a></h3>
<p><strong>Сбалансированное по высоте</strong> двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1. </p>
<h3 id=""><a class="header" href="#"><img src="algostruct/../media/image3.png" alt="" /></a></h3>
<h2 id="Красно-чёрное-дерево"><a class="header" href="#Красно-чёрное-дерево">Красно-чёрное дерево</a></h2>
<p>Красно-черные деревья - один из способов балансировки деревьев. Название происходит от стандартной раскраски узлов таких деревьев в красный и черный цвета. Цвета узлов используются при балансировке дерева. Во время операций вставки и удаления поддеревья может понадобиться повернуть, чтобы достигнуть сбалансированности дерева. Оценкой как среднего время, так и наихудшего является <strong>O</strong>(log <em>n</em>).</p>
<p>Красно-чёрное дерево - это двоичное дерево поиска, в котором каждый узел имеет атрибут цвет, принимающий значения красный или чёрный. </p>
<p>Как бинарное дерево, красно-черное обладает свойствами:</p>
<ul>
<li>Оба поддерева являются бинарными деревьями поиска.</li>
<li>Для каждого узла с ключом k выполняется критерий упорядочения: ключи всех левых потомков &lt;= k &lt; ключи всех правых потомков(в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать). Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.</li>
</ul>
<p>В дополнение к обычным требованиям, налагаемым на двоичные деревья поиска, к красно-чёрным деревьям применяются следующие требования:</p>
<ul>
<li>
<p>Узел либо красный, либо чёрный.</p>
</li>
<li>
<p>Корень — чёрный. (В других определениях это правило иногда опускается. Это правило слабо влияет на анализ, так как корень всегда может быть изменен с красного на чёрный, но не обязательно наоборот).</p>
</li>
<li>
<p>Все листья(NIL) — чёрные.</p>
</li>
<li>
<p>Оба потомка каждого красного узла — чёрные.</p>
</li>
<li>
<p>Всякий простой путь от данного узла до любого листового узла, являющегося его потомком, содержит одинаковое число чёрных узлов.</p>
<p><img src="algostruct/../media/image4.png" alt="" /></p>
</li>
</ul>
<p>Количество черных узлов на ветви от корня до листа называется черной высотой дерева. Перечисленные свойства гарантируют, что самая длинная ветвь от корня к листу не более чем вдвое длиннее любой другой ветви от корня к листу. Чтобы понять, почему это так, рассмотрим дерево с черной высотой 2. Кратчайшее возможное расстояние от корня до листа равно двум - когда оба узла черные. Длиннейшее расстояние от корня до листа равно четырем - узлы при этом покрашены (от корня к листу) так: красный, черный, красный, черный. Сюда нельзя добавить черные узлы, поскольку при этом нарушится свойство 4, из которого вытекает корректность понятия черной высоты. Поскольку согласно свойству 3 у красных узлов непременно черные наследники, в подобной последовательности недопустимы и два красных узла подряд. Таким образом, длиннейший путь, который мы можем сконструировать, состоит из чередования красных и черных узлов, что и приводит нас к удвоенной длине пути, проходящего только через черные узлы. Все операции над деревом должны уметь работать с перечисленными свойствами. В частности, при вставке и удалении эти свойства должны сохраниться.</p>
<h2 id="Куча"><a class="header" href="#Куча">Куча</a></h2>
<p>Специализированное дерево, которая удовлетворяет *свойству кучи:*если <em>B</em> является узлом-потомком узла <em>A</em>, то ключ(<em>A</em>) ≥ ключ(<em>B</em>). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют <em>max-кучами</em> (в качестве альтернативы, если сравнение перевернуть, то наименьший элемент будет всегда корневым узлом, такие кучи называют <em>min-кучами</em>). Не существует никаких ограничений относительно того, сколько узлов-потомков имеет каждый узел кучи, хотя на практике их число обычно не более двух. Куча является максимально эффективной реализации очереди с приоритетом. Кучи имеют решающее значение в некоторых эффективных алгоритмах на графах, таких как <a href="https://ru.wikipedia.org/w/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D1%8B_%D0%BD%D0%B0_d-%D0%BA%D1%83%D1%87%D0%B0%D1%85&amp;action=edit&amp;redlink=1">алгоритм Дейкстры на d-кучах</a> и сортировка <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">методом пирамиды</a>.</p>
<p>Двои́чная ку́ча, пирами́да, или сортиру́ющее де́рево — такое двоичное дерево, для которого выполнены три условия:</p>
<ul>
<li>
<p>Значение в любой вершине не меньше, чем значения её потомков.</p>
</li>
<li>
<p>Глубина всех листьев (расстояние до корня) отличается не более чем на 1 слой.</p>
</li>
<li>
<p>Последний слой заполняется слева направо без «дырок».</p>
<p><img src="algostruct/../media/biHeap.png" alt="" /></p>
</li>
</ul>
<h2 id="b-дерево"><a class="header" href="#b-дерево">B-дерево</a></h2>
<p><strong>B-дерево</strong> – это структура хранения данных, являющаяся разновидностью дерева поиска. Особенностями В-деревьев является: </p>
<ul>
<li>сбалансированность,</li>
<li>ветвистость, </li>
<li>отсортированность </li>
<li>логарифмическое <strong>O(log n)</strong> время работы всех стандартных операций (поиск, вставка, удаление).</li>
</ul>
<p>Сбалансированность означает, что все листы находятся на одинаковом расстоянии от корня. В отличие от бинарных деревьев В-деревья допускают большое число потомков для любого из узлов. Это свойство называется ветвистостью. Благодаря ветвистости, В-деревья очень удобны для хранения крупных последовательных блоков данных, поэтому такая структура часто находит применение в базах данных и файловых системах.</p>
<p>С точки зрения физической организации B-дерево представляется как мультисписочная структура страниц памяти, то есть каждому узлу дерева соответствует блок памяти (страница). Внутренние и листовые страницы обычно имеют разную структуру.</p>
<p>Порядок(m) В-дерева – это максимальное число потомков для любого узла. Кроме узлов в дереве присутствует ещё одна сущность – ключи. Именно в них и содержится вся полезная информация. Каждый узел дерева можно представить в виде упорядоченной последовательности <em>”потомок1; ключ1; потомок2; ключ2; … потомок(N-1); ключ(N-1); потомокN”</em>. Важно заметить, что ключи располагаются между ссылками на потомков и, таким образом, ключей всегда на 1 меньше. В организации В-дерева можно выделить несколько ключевых правил:</p>
<ul>
<li>Каждый узел содержит строго меньше m (порядок дерева) потомков.</li>
<li>Каждый узел содержит <strong>не менее m/2</strong> потомков.</li>
<li>Корень может содержать <strong>меньше m/2</strong> потомков.</li>
<li>У корневого узла есть хотя бы 2 потомка, если он не является листом.</li>
<li>Все листья находятся на одном уровне и содержат только данные (ключи). Но это <strong>не значит</strong> что ключи находятся только в листьях.</li>
</ul>
<p>Ключи во внутреннем узле окружены указателями или смещениями записей, отсылающими к ключам, которые либо все больше, либо все меньше окруженного ключа. Например, все ключи, меньшие 22, адресуются левой ссылкой, все большие - правой. Для простоты здесь не показаны адреса записей, связанные с каждым ключом.</p>
<p><img src="algostruct/../media/image5.png" alt="" /></p>
<h3 id="b-дерево-1"><a class="header" href="#b-дерево-1"><strong>B+‍‍ дерево</strong></a></h3>
<p><strong>B+‍‍ дерево</strong> — структура данных на основе B-дерева, сбалансированное n-арное дерево поиска с переменным, но зачастую большим количеством потомков в узле. B+‍‍ дерево состоит из корня, внутренних узлов и листьев, корень может быть либо листом, либо узлом с двумя и более потомками.</p>
<p>Изначально структура предназначалась для хранения данных в целях эффективного поиска в блочно-ориентированной среде хранения — в частности, для файловых систем; применение связано с тем, что в отличие от бинарных деревьев поиска, <strong>B+‍‍</strong> деревья имеют очень высокий коэффициент ветвления (число указателей из родительского узла на дочерние, обычно порядка 100 или более), что снижает количество операций ввода-вывода, требующих поиска элемента в дереве.</p>
<p>Построение B+‍‍-дерева может требовать перестройки промежуточной структуры, это связано с тем, что количество ключей в каждом узле (кроме корня) должно быть от <strong>t</strong> до <strong>2t</strong>, где <strong>t</strong> — степень (или порядок) дерева. При попытке вставить в узел <strong>2t+1</strong>-й ключ возникает необходимость разделить этот узел, в качестве ключа-разделителя сформированных ветвей выступает <strong>t+1</strong>-й ключ, который помещается на соседний ярус дерева. Особым же случаем является разделение корня, так как в этом случае увеличивается число ярусов дерева. Особенностью разделения листа B+‍‍-дерева является то, что он делится на неравные части. При разделении внутреннего узла или корня возникают узлы с равным числом ключей <strong>k</strong>. Разделение листа может вызвать «цепную реакцию» деления узлов, заканчивающуюся в корне.</p>
<h2 id="Свойства-структуры"><a class="header" href="#Свойства-структуры"><strong>Свойства структуры:</strong></a></h2>
<ul>
<li>Легко реализуется независимость программы от структуры информационной записи.</li>
<li>Поиск обязательно заканчивается в листе.</li>
<li>Удаление ключа имеет преимущество — удаление всегда происходит из листа.</li>
<li>Другие операции выполняются аналогично B-деревьям.</li>
<li><strong>B+‍‍</strong> деревья требуют больше памяти для представления, чем классические B-деревья.</li>
<li><strong>B+‍‍</strong> деревья имеют возможность последовательного доступа к ключам.</li>
</ul>
<p><img src="algostruct/../media/bAndB+.png" alt="" /></p>
<h2 id="b-дерево-2"><a class="header" href="#b-дерево-2">B* дерево</a></h2>
<p><strong>B*</strong> дерево — разновидность <strong>B</strong> дерева, в которой каждый узел дерева заполнен не менее чем на ⅔ (в отличие от B-дерева, где этот показатель составляет 1/2). <strong>B+</strong> дерево, удовлетворяющее таким требованиям называется <strong>B+</strong>* деревом.</p>
<p><strong>B*</strong> дерево относительно компактнее, так как каждый узел используется полнее. В остальном же этот вид деревьев не отличается от простого <strong>B</strong> дерева.</p>
<p>Для выполнения требования «заполненность узла не менее 2/3», приходится отказываться от простой процедуры разделения переполненного узла. Вместо этого происходит «переливание» в соседний узел. Если же и соседний узел заполнен, то ключи приблизительно поровну разделяются на 3 новых узла.</p>
<h2 id="lsm-Дерево"><a class="header" href="#lsm-Дерево">LSM Дерево</a></h2>
<p><strong>LSM</strong>-дерево (<strong>Log-structured merge-tree</strong> — журнально-структурированное дерево со слиянием) — используемая во многих СУБД структура данных, предоставляющая быстрый доступ по индексу в условиях частых запросов на вставку (например, при хранении журналов транзакций). LSM-деревья, как и другие деревья, хранят пары «ключ — значение». LSM-дерево поддерживает две или более различные структуры, каждая из которых оптимизирована под устройство, в котором она будет храниться. Синхронизация между этими структурами происходит блоками.</p>
<h3 id="Принцип-работы"><a class="header" href="#Принцип-работы">Принцип работы</a></h3>
<p>Простая версия LSM-дерева — двухуровневое дерево — состоит из двух древоподобных структур C0 и C1. C0 меньше по размеру и хранится целиком в оперативной памяти, а C1 находится в энергонезависимой памяти. Новые записи вставляются в C0. Если после вставки размер C0 превышает некоторое заданное пороговое значение, непрерывный сегмент удаляется из C0 и сливается с C1 на устройстве постоянного хранения. Хорошая производительность достигается за счёт того, что деревья оптимизированы под своё хранилище, а слияние осуществляется эффективно и группами по нескольку записей, используя алгоритм, напоминающий <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC">сортировку слиянием</a>.</p>
<p>Большинство LSM-деревьев, используемых на практике, реализует несколько уровней. Уровень 0 (назовём его MemTable) хранится в оперативной памяти и может быть представлен обычным деревом. Данные на устройствах постоянного хранения хранятся в виде отсортированных по ключу таблиц (<a href="https://ru.wikipedia.org/w/index.php?title=SSTable&amp;action=edit&amp;redlink=1">SSTable</a>). Таблица может храниться в виде отдельного файла или набора файлов с непересекающимися значениями ключей. Для поиска конкретного ключа нужно проверить его наличие в MemTable, а затем — пройти по всем SSTable на устройстве постоянного хранения.</p>
<h3 id="Схема-работы-с-lsm-деревом"><a class="header" href="#Схема-работы-с-lsm-деревом">Схема работы с LSM-деревом:</a></h3>
<ul>
<li>индексы SSTable всегда загружены в оперативную память;</li>
<li>запись производится в MemTable;</li>
<li>при чтении сначала проверяется MemTable, а затем, если надо, — SSTable на устройстве постоянного хранения;</li>
<li>периодически MemTable сбрасывается в энергонезависимую память для постоянного хранения в виде SSTable;</li>
<li>периодически SSTable на устройствах постоянного хранения сливаются.</li>
</ul>
<p>Искомый ключ может появиться сразу в нескольких таблицах на устройствах постоянного хранения, и итоговый ответ зависит от программы. Большинству приложений нужно лишь последнее значение, относящееся к данному ключу. Другие, например Apache Cassandra, в которой каждое значение представляет собой строку базы данных (а строка может иметь разное количество столбцов в разных таблицах с устройств постоянного хранения), вынуждены как-либо обрабатывать все имеющиеся значения, чтобы получить корректный результат. Чтобы сократить время выполнения запросов, на практике стараются избегать ситуации со слишком большим количеством таблиц на устройствах постоянного хранения.</p>
<p>Были разработаны расширения к «уровневому» методу для поддержания <a href="https://ru.wikipedia.org/wiki/B%2B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">B+‍-структур</a>, например, bLSM[<a href="https://ru.wikipedia.org/wiki/LSM-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE#cite_note-2">2]</a> и Diff-Index.[<a href="https://ru.wikipedia.org/wiki/LSM-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE#cite_note-3">3]</a></p>
<h3 id="Время-работы"><a class="header" href="#Время-работы">Время работы</a></h3>
<p>Архитектура LSM-дерева позволяет удовлетворить запрос на чтение либо из оперативной памяти, либо за одно обращение к устройствам постоянного хранения. Запись тоже всегда быстра независимо от размеров хранилища.</p>
<p>SSTable на устройствах постоянного хранения неизменяема. Поэтому изменения хранятся в MemTable, а удаления должны добавлять в MemTable специальное значение. Поскольку новые считывания происходят последовательно по индексу, обновлённое значение или запись об удалении значения встретятся раньше, чем старые значения. Периодически запускаемое слияние старых SSTable на устройстве постоянного хранения будет производить эти изменения и действительно удалять и обновлять значения, избавляясь от ненужных данных.</p>
<h2 id="r-дерево"><a class="header" href="#r-дерево">R-дерево</a></h2>
<p><strong>R-дерево</strong> (R-trees) — древовидная структура данных (дерево). Она подобна B-дереву, но используется для организации доступа к пространственным данным, то есть для индексации многомерной информации, такой, например, как географические данные с двумерными координатами (широтой и долготой). Типичным запросом с использованием R-деревьев мог бы быть такой: «Найти все музеи в пределах 2 километров от моего текущего местоположения».</p>
<p>Эта структура данных разбивает многомерное пространство на множество иерархически вложенных и, возможно, пересекающихся, прямоугольников (для двумерного пространства). В случае трехмерного или многомерного пространства это будут прямоугольные параллелепипеды (кубоиды) или параллелотопы.</p>
<p>Алгоритмы вставки и удаления используют эти ограничивающие прямоугольники для обеспечения того, чтобы «близкорасположенные» объекты были помещены в одну листовую вершину. В частности, новый объект попадёт в ту листовую вершину, для которой потребуется наименьшее расширение её ограничивающего прямоугольника. Каждый элемент листовой вершины хранит два поля данных: способ идентификации данных, описывающих объект, (либо сами эти данные) и ограничивающий прямоугольник этого объекта.</p>
<p>Аналогично, алгоритмы поиска (например, пересечение, включение, окрестности) используют ограничивающие прямоугольники для принятия решения о необходимости поиска в дочерней вершине. Таким образом, большинство вершин никогда не затрагиваются в ходе поиска. Как и в случае с B-деревьями, это свойство R-деревьев обусловливает их применимость для баз данных, где вершины могут выгружаться на диск по мере необходимости.</p>
<p>Для расщепления переполненных вершин могут применяться различные алгоритмы, что порождает деление R-деревьев на подтипы: квадратичные и линейные.</p>
<p><img src="algostruct/../media/rtree.png" alt="" /></p>
<h3 id="Структура-r-дерева"><a class="header" href="#Структура-r-дерева">Структура R-дерева</a></h3>
<p>Каждая вершина R-дерева имеет переменное количество элементов (не более некоторого заранее заданного максимума). Каждый элемент нелистовой вершины хранит два поля данных: способ идентификации дочерней вершины и ограничивающий прямоугольник (кубоид), охватывающий все элементы этой дочерней вершины. Все хранимые кортежи хранятся на одном уровне глубины, таким образом, дерево идеально сбалансировано. При проектировании R-дерева нужно задать некоторые константы:</p>
<ul>
<li>MaxEntries — максимальное число детей у вершины</li>
<li>MinEntries — минимальное число детей у вершины, за исключением корня.</li>
</ul>
<p>Для корректной работы алгоритмов необходимо выполнение условия MinEntries &lt;= MaxEntries / 2. В корневой вершине может быть от 2 до MaxEntries потомков. Часто выбирают MinEntries = 2, тогда для корня выполняются те же условия, что и для остальных вершин. Также иногда разумно выделять отдельные константы для количества точек в листовых вершинах, так как их часто можно делать больше.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Граф"><a class="header" href="#Граф">Граф</a></h2>
<p>Граф — это совокупность объектов со связями между ними. Объекты представляются как вершины, или узлы графа, а связи — как дуги, или рёбра. Для разных областей применения виды графов могут различаться направленностью, ограничениями на количество связей и дополнительными данными о вершинах или рёбрах. Граф называется:</p>
<ul>
<li><strong>связным</strong>, если для любых вершин u,v есть путь из u в v.</li>
<li><strong>деревом</strong>, если он связный и не содержит простых циклов.</li>
<li><strong>полным</strong>, если любые его две (различные, если не допускаются петли) вершины соединены ребром.</li>
<li><strong>двудольным</strong>, если его вершины можно разбить на два непересекающихся подмножества V1 и V2 так, что всякое ребро соединяет вершину из V1 с вершиной из V2.</li>
<li><strong>планарным</strong>, если граф можно изобразить диаграммой на плоскости без пересечений рёбер.</li>
<li><strong>ориентированным</strong>, если рёбрам которого присвоено направление. Направленные рёбра именуются также <em>дугами</em>, а в некоторых источниках и просто рёбрами.</li>
</ul>
<h2 id="Что-такое-обход-графа"><a class="header" href="#Что-такое-обход-графа">Что такое обход графа?</a></h2>
<p>Простыми словами, обход графа — это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи (линии, соединяющие вершины) называются направлениями, путями, гранями или ребрами графа. Вершины графа также именуются узлами.</p>
<p>Двумя основными алгоритмами обхода графа являются поиск в глубину <strong>(Depth-First Search, DFS)</strong> и поиск в ширину <strong>(Breadth-First Search, BFS)</strong>.</p>
<h3 id="Поиск-в-глубину"><a class="header" href="#Поиск-в-глубину">Поиск в глубину</a></h3>
<p><strong>Поиск в глубину(Depth-First Search, DFS)</strong> находит такой путь от данной вершины, до нужной, что этот путь содержит минимальную сумму ребер графа. Например, если мы ищем на карте метро путь от Сокольников, до Парка Победы, требующий наименьшее время для переезда(расстояние между каждыми соседними станциями, будет весом ребра), то мы ищем в глубину.</p>
<p><strong>DFS</strong> следует концепции «погружайся глубже, головой вперед» («go deep, head first»). Идея заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути) до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или расхождения путей) и идем по другому маршруту.</p>
<h3 id="Поиск-в-ширину"><a class="header" href="#Поиск-в-ширину">Поиск в ширину</a></h3>
<p><strong>Поиск в ширину(Breadth-First Search, BFS)</strong> — это один из основных алгоритмов на графах. В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер. Например, если мы ищем на карте метро путь от Сокольников, до Парка Победы, содержащий наименьшее число станций, то мы ищем в ширину.</p>
<p><strong>BFS</strong> следует концепции «расширяйся, поднимаясь на высоту птичьего полета» («go wide, bird’s eye-view»). Вместо того чтобы двигаться по определенному пути до конца, BFS предполагает движение вперед по одному соседу за раз.</p>
<h2 id="Алгоритм-Дейкстры"><a class="header" href="#Алгоритм-Дейкстры">Алгори́тм Де́йкстры</a></h2>
<p>Алгори́тм Де́йкстры (Dijkstra’s algorithm) — алгоритм на графах, изобретённый нидерландским учёным Эдсгером Дейкстрой в 1959 году. Находит кратчайшие пути от одной из вершин графа до всех остальных. Алгоритм работает только для графов <strong>без рёбер отрицательного веса</strong>.</p>
<p>Каждой вершине из V сопоставим метку — минимальное известное расстояние от этой вершины до a. Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.</p>
<p>Инициализация. Метка самой вершины a полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от a до других вершин пока неизвестны. Все вершины графа помечаются как не посещённые.</p>
<p>Шаг алгоритма. Если все вершины посещены, алгоритм завершается. В противном случае из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку. Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут рёбра из u, назовём соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/post/504374/">Обход графа: поиск в глубину и поиск в ширину простыми словами на примере JavaScript</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вероятностные-структуры-данных"><a class="header" href="#Вероятностные-структуры-данных">Вероятностные структуры данных</a></h1>
<h2 id="Фильтр-Блума"><a class="header" href="#Фильтр-Блума">Фильтр Блума</a></h2>
<p>Фильтр Блума (англ. Bloom filter) — это вероятностная структура данных, придуманная Бёртоном Блумом в 1970 году, позволяющая проверять принадлежность элемента к множеству. При этом существует возможность получить ложноположительное срабатывание (элемента в множестве нет, но структура данных сообщает, что он есть), но не ложноотрицательное.</p>
<p>Фильтр Блума может использовать любой объём памяти, заранее заданный пользователем, причём чем он больше, тем меньше вероятность ложного срабатывания. Поддерживается операция добавления новых элементов в множество, но не удаления существующих (если только не используется модификация со счётчиками).</p>
<p>По сравнению с <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">хеш-таблицами</a> фильтр Блума может обходиться на несколько порядков меньшими объёмами памяти, жертвуя детерминизмом. Обычно он используется для уменьшения числа запросов к несуществующим данным в структуре данных с более дорогостоящим доступом (например, расположенной на жестком диске или в сетевой базе данных), то есть для «фильтрации» запросов к ней.</p>
<p>Как фильтр это делает? Как я уже говорил, идея до гениальности проста. Заводится массив битов фиксированного размера <code>m</code> и набор из <code>k</code> различных хеш-функций, выдающих значения от <code>0</code> до <code>m - 1</code>. При необходимости добавить элемент к множеству, для элемента считается значение каждой хеш-функции и в массиве устанавливаются биты с соответствующими индексами.</p>
<p>Для проверки принадлежности, как вы уже догадались, достаточно посчитать значения хеш-функций для потенциального члена и убедиться, что все соответствующие биты установлены в единицу — это и будет ответом «возможно». Если же хотя бы один бит не равен единице, значит множество этого элемента не содержит — ответ «нет», элемент отфильтрован.</p>
<p>Примеры практических применений:</p>
<ul>
<li>
<p>Прокси-сервер <a href="https://ru.wikipedia.org/wiki/Squid">Squid</a> использует фильтры Блума для опции <a href="http://wiki.squid-cache.org/SquidFaq/CacheDigests">cache digests</a>.</p>
</li>
<li>
<p><a href="https://ru.wikipedia.org/wiki/Google_(%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BD%D0%B8%D1%8F)">Google</a> <a href="https://ru.wikipedia.org/wiki/BigTable">BigTable</a> использует фильтры Блума для уменьшения числа обращений к жесткому диску при проверке на существование заданной строки или столбца в таблице базы данных.</p>
</li>
<li>
<p>Компьютерные программы для проверки орфографии.</p>
</li>
<li>
<p>MinHash</p>
</li>
<li>
<p>LogLog</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Криптография"><a class="header" href="#Криптография">Криптография</a></h1>
<p>Криптогра́фия — наука о методах обеспечения конфиденциальности (невозможности прочтения информации посторонним), целостности данных (невозможности незаметного изменения информации), аутентификации (проверки подлинности авторства или иных свойств объекта), а также невозможности отказа от авторства.</p>
<h2 id="Терминология"><a class="header" href="#Терминология">Терминология</a></h2>
<ul>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%B9_%D1%82%D0%B5%D0%BA%D1%81%D1%82">Открытый (исходный) текст</a></strong> — данные (необязательно текстовые), передаваемые без использования криптографии или другими словами незашифрованные данные.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D1%82%D0%B5%D0%BA%D1%81%D1%82">Шифротекст</a></strong>, <strong>шифрованный (закрытый) текст</strong> — данные, полученные после применения криптосистемы (обычно — с некоторым указанным <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D1%8E%D1%87_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)">ключом</a>). Другое название <strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0">криптограмма</a></strong></p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80">Шифр</a></strong>, <strong>криптосистема</strong> — семейство обратимых преобразований открытого текста в шифрованный.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D1%8E%D1%87_(%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F)">Ключ</a></strong> — параметр шифра, определяющий выбор конкретного преобразования данного текста. В современных шифрах <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D1%82%D0%BE%D0%B9%D0%BA%D0%BE%D1%81%D1%82%D1%8C">криптографическая стойкость</a> шифра целиком определяется секретностью ключа (<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%9A%D0%B5%D1%80%D0%BA%D0%B3%D0%BE%D1%84%D1%84%D1%81%D0%B0">принцип Керкгоффса</a>). Также выделяют <strong>ключ шифрования</strong> (<em>encription key</em>) и <strong>ключ расшифрования</strong> (<em>decryption key</em>)</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Шифрование</a></strong> — процесс нормального применения криптографического преобразования открытого текста на основе алгоритма и ключа, в результате которого возникает шифрованный текст.</p>
</li>
<li>
<p><strong>Расшифровывание</strong> — процесс нормального применения криптографического преобразования шифрованного текста в открытый.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D1%88%D0%B8%D1%84%D1%80">Асимметричный шифр</a></strong>, <strong>двухключевой шифр</strong>, <strong>шифр с открытым ключом</strong> — шифр, в котором используются два ключа, шифрующий и расшифровывающий. При этом, зная лишь ключ зашифровывания, нельзя расшифровать сообщение, и наоборот.</p>
</li>
<li>
<p><strong>Открытый ключ</strong> — тот из двух ключей асимметричной системы, который свободно распространяется. Шифрующий для секретной переписки и расшифровывающий — для электронной подписи.</p>
</li>
<li>
<p><strong>Секретный ключ</strong>, <strong>закрытый ключ</strong> — тот из двух ключей асимметричной системы, который хранится в секрете.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7">Криптоанализ</a></strong> — наука, изучающая математические методы нарушения конфиденциальности и целостности информации.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D1%82%D0%B8%D0%BA">Криптоаналитик</a></strong> — учёный, создающий и применяющий методы криптоанализа.</p>
</li>
<li>
<p>Криптография и криптоанализ составляют <strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F">криптологию</a></strong>, как единую <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%83%D0%BA%D0%B0">науку</a> о создании и взломе шифров (<em>такое деление привнесено с <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BF%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F_%D1%86%D0%B8%D0%B2%D0%B8%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">запада</a>, до этого в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%A1%D0%A1%D0%A0">СССР</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F">России</a> не применялось специального деления</em>).</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%B0%D1%82%D0%B0%D0%BA%D0%B0">Криптографическая атака</a></strong> — попытка криптоаналитика вызвать отклонения в атакуемой защищённой системе обмена информацией. Успешную криптографическую атаку называют <strong>взлом</strong> или <strong>вскрытие</strong>.</p>
</li>
<li>
<p><strong>Дешифрование (дешифровка)</strong> — процесс извлечения открытого текста без знания криптографического ключа на основе известного шифрованного. Термин дешифрование обычно применяют по отношению к процессу криптоанализа шифротекста (криптоанализ сам по себе, вообще говоря, может заключаться и в анализе криптосистемы, а не только зашифрованного ею открытого сообщения).</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D1%82%D0%BE%D0%B9%D0%BA%D0%BE%D1%81%D1%82%D1%8C">Криптографическая стойкость</a></strong> — способность криптографического алгоритма противостоять криптоанализу.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B8%D1%82%D0%BE%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0">Имитозащита</a></strong> — защита от навязывания ложной информации. Другими словами, текст остаётся открытым, но появляется возможность проверить, что его не изменяли ни случайно, ни намеренно. Имитозащита достигается обычно за счёт включения в пакет передаваемых данных имитовставки.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%B8%D1%82%D0%BE%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0">Имитовставка</a></strong> — блок информации, применяемый для имитозащиты, зависящий от ключа и данных.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%86%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C">Электронная цифровая подпись</a></strong>, или <strong>электронная подпись</strong> — асимметричная имитовставка (ключ защиты отличается от ключа проверки). Другими словами, такая имитовставка, которую проверяющий не может подделать.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BD%D1%82%D1%80_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8">Центр сертификации</a></strong> — сторона, чья честность неоспорима, а открытый ключ широко известен. Электронная подпись центра сертификации подтверждает подлинность открытого ключа.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Хеш-функция</a></strong> — функция, которая преобразует сообщение произвольной длины в число («свёртку») фиксированной длины. Для криптографической хеш-функции (в отличие от хеш-функции общего назначения) сложно вычислить обратную и даже найти два сообщения с общей хеш-функцией.</p>
</li>
<li>
<p><a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%B1%D1%80%D0%B8%D0%B4%D0%BD%D0%B0%D1%8F_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0"><strong>Гибри́дная криптосисте́ма</strong></a> — это система <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">шифрования</a>, совмещающая преимущества <a href="https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%BC_%D0%BA%D0%BB%D1%8E%D1%87%D0%BE%D0%BC">криптосистемы с открытым ключом</a> с производительностью <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B">симметричных криптосистем</a>.</p>
</li>
</ul>
<h2 id="Криптографические-примитивы"><a class="header" href="#Криптографические-примитивы">Криптографические примитивы</a></h2>
<p>В основе построения криптостойких систем лежит многократное использование относительно простых преобразований, так называемых криптографических примитивов. <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%BE%D0%B4_%D0%A8%D0%B5%D0%BD%D0%BD%D0%BE%D0%BD">Клод Шеннон</a>, известный американский математик и электротехник, предложил использовать подстановки (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> <em>substitution</em>) и перестановки (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> <em>permutation</em>). Схемы, которые реализуют эти преобразования, называются SP-сетями. Нередко используемыми криптографическими примитивами являются также преобразования типа <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B4%D0%B2%D0%B8%D0%B3">циклический сдвиг</a> или <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">гаммирование</a>. Ниже приведены основные криптографические примитивы и их использование.</p>
<ul>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Симметричное шифрование</a>.</strong> Заключается в том, что обе стороны-участники обмена данными имеют абсолютно одинаковые <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D1%8E%D1%87%D0%B8">ключи</a> для шифрования и расшифровки данных. Данный способ осуществляет преобразование, позволяющее предотвратить просмотр информации третьей стороной.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%B8%D0%BC%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Асимметричное шифрование</a>.</strong> Предполагает использовать в паре два разных ключа — открытый и секретный. В асимметричном шифровании ключи работают в паре — если данные шифруются открытым ключом, то расшифровать их можно только соответствующим <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87">секретным ключом</a> и наоборот — если данные шифруются секретным ключом, то расшифровать их можно только соответствующим <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87">открытым ключом</a>. Использовать открытый ключ из одной пары и секретный с другой — невозможно. Каждая пара асимметричных ключей связана математическими зависимостями. Данный способ также нацелен на преобразование информации от просмотра третьей стороной.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C">Цифровые подписи</a></strong>. <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C">Цифровые подписи</a> используются для установления подлинности документа, его происхождения и авторства, исключает искажения информации в электронном документе.</p>
</li>
<li>
<p><strong><a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Хеширование.</a></strong> Преобразование входного массива данных произвольной длины в выходную битовую строку фиксированной длины. Такие преобразования также называются хеш-функциями или функциями свёртки, а их результаты называют хеш-кодом, контрольной суммой или дайджестом сообщения (англ. message digest). Результаты хеширования статистически уникальны. Последовательность, отличающаяся хотя бы одним байтом, не будет преобразована в то же самое значение.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Разное"><a class="header" href="#Разное">Разное</a></h1>
<h2 id="Асимптотический-анализ"><a class="header" href="#Асимптотический-анализ">Асимптотический анализ</a></h2>
<p>Асимптотический анализ показывает порядок роста алгоритма - как увеличивается время работы алгоритма при увеличении объема входных данных. По факту измеряем не время, а число операций, например - сравнения,присваивания,выделение памяти. Обычно измеряется наихудший случай выполнения, если не оговорено иное. Записывается, как O(n) (О нотация, О большое) . Примеры:</p>
<ul>
<li>Константный — O(1)</li>
<li>Линейный — O(n)</li>
<li>Логарифмический — O( log n)</li>
<li>Линеарифметический — O(n·log n)</li>
<li>Квадратичный — O(n 2)</li>
<li>И другие</li>
</ul>
<h2 id="Бинарный-поиск"><a class="header" href="#Бинарный-поиск">Бинарный поиск</a></h2>
<p>Ищет элемент в отсортированном массиве:</p>
<ol>
<li>Определение значения элемента в середине структуры данных. Полученное значение сравнивается с ключом.</li>
<li>Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.</li>
<li>Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с ключом.</li>
<li>Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.</li>
</ol>
<pre><code class="language-php">&lt;?php

function binarySearch( array $arr, int $needle): ?int
{
    $min = 0;
    $max = count($arr) - 1;

    while ($min &lt; $max) {
        
        $middleKey =  floor($min + ($max - $min) / 2);
        $middleVal = $arr[$middleKey];

        if ($needle &lt; $middleVal) {
            $max = $middleKey - 1;
        } elseif ($needle &gt; $middleVal) {
            $min = $middleKey + 1;
        } else {
            return $middleKey;
        }
    }

    return null;
}

$arr = [0,11,22,33,44,55,66,77,88,99];
print_r(binarySearch($arr, 44));
</code></pre>
<h2 id="Рекурсия"><a class="header" href="#Рекурсия">Рекурсия</a></h2>
<p><strong>Рекурсия</strong> – это когда функция вызывает сама себя(напрямую или через функцию посредника), как правило, с другими аргументами. Рекурсия помогает писать код более компактно и понятно, однако имеет оверхэд по памяти из-за необходимости хранить стек вызова. Для оптимизации можно переписать алгоритм используя циклы - любая рекурсия может быть переделана в цикл, как правило, вариант с циклом будет эффективнее. Также есть хвостовая рекурсия.</p>
<p>Хвостовая рекурсия — частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции. Подобный вид рекурсии примечателен тем, что может быть легко заменён на итерацию путём формальной и гарантированно корректной перестройки кода функции. Оптимизация хвостовой рекурсии путём преобразования её в плоскую итерацию реализована во многих оптимизирующих компиляторах. В некоторых функциональных языках программирования спецификация гарантирует обязательную оптимизацию хвостовой рекурсии.</p>
<h2 id="Разделяй-и-властвуй"><a class="header" href="#Разделяй-и-властвуй">Разделяй и властвуй</a></h2>
<p><strong>Разделяй и властвуй</strong>(divide and conquer) — важная парадигма разработки алгоритмов, заключающаяся в рекурсивном разбиении решаемой задачи на две или более подзадачи того же типа, но меньшего размера, и комбинировании их решений для получения ответа к исходной задаче; разбиения выполняются до тех пор, пока все подзадачи не окажутся элементарными.</p>
<p>Типичный пример — алгоритм сортировки слиянием. Чтобы отсортировать массив чисел по возрастанию, он разбивается на две равные части, каждая сортируется, затем отсортированные части сливаются в одну. Эта процедура применяется к каждой из частей до тех пор, пока сортируемая часть массива содержит хотя бы два элемента (чтобы можно было её разбить на две части). </p>
<h2 id="Динамическое-программирование"><a class="header" href="#Динамическое-программирование">Динамическое программирование</a></h2>
<p>Динамическое программирование — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, выглядящим как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.</p>
<p>Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.</p>
<p>Метод динамического программирования сверху — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. Динамическое программирование снизу включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач. <strong>The difference between dynamic programming and greedy algorithms is that with dynamic programming, there are overlapping subproblems, and those subproblems are solved using memoization</strong>. &quot;Memoization&quot; is the technique whereby solutions to subproblems are used to solve other subproblems more quickly.</p>
<p>The difference is that dynamic programming requires you to remember the answer for the smaller states, while a greedy algorithm is local in the sense that all the information needed is in the current state. Of course, there is some intersection.</p>
<h2 id="Жадный-алгоритм"><a class="header" href="#Жадный-алгоритм">Жадный алгоритм</a></h2>
<p><strong>Жадный алгоритм</strong> — алгоритм, заключающийся в принятии локально <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D1%82%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5">оптимальных решений</a> на каждом этапе, допуская, что конечное решение также окажется оптимальным. В общем случае нельзя сказать, можно ли получить оптимальное решение с помощью жадного алгоритма применительно к конкретной задаче. Но есть две особенности, характерные для задач, которые решаются с помощью жадных алгоритмов: принцип жадного выбора и свойство оптимальности для подзадач.</p>
<h3 id="Принцип-жадного-выбора"><a class="header" href="#Принцип-жадного-выбора">Принцип жадного выбора</a></h3>
<p>Говорят, что к задаче оптимизации применим принцип жадного выбора, если последовательность локально оптимальных выборов дает глобально оптимальное решение. <strong>В этом состоит главное отличие жадных алгоритмов от динамического программирования: во втором просчитываются сразу последствия всех вариантов.</strong></p>
<p>Чтобы доказать, что жадный алгоритм дает оптимум, нужно попытаться провести доказательство, аналогичное доказательству алгоритма задачи о выборе заявок. Сначала мы показываем, что жадный выбор на первом шаге не закрывает путь к оптимальному решению: для любого решения есть другое, согласованное с жадным выбором и не хуже первого. Потом мы показываем, что подзадача, возникшая после жадного выбора на первом шаге, аналогична исходной. По индукции будет следовать, что такая последовательность жадных выборов дает оптимальное решение.</p>
<h3 id="Оптимальность-для-подзадач"><a class="header" href="#Оптимальность-для-подзадач">Оптимальность для подзадач</a></h3>
<p>Это свойство говорит о том, что оптимальное решение всей задачи содержит в себе оптимальные решения подзадач.</p>
<h2 id="Задача-np-полная-np-complete-problem"><a class="header" href="#Задача-np-полная-np-complete-problem">Задача NP-полная (NP-complete problem)</a></h2>
<p>Тип задач, принадлежащих классу NP (non-deterministic polynomial – «недетерминированные с полиномиальным временем»), для которых отсутствуют быстрые алгоритмы решения. Время работы алгоритмов решения таких задач существенно (обычно, экспоненциально) возрастает с увеличением объема входных данных.</p>
<p>Однако, если предоставить алгоритму некоторые дополнительные сведения, то временные затраты могут быть существенно снижены. При этом, если будет найден быстрый алгоритм для какой-либо из NP-полных задач, то для любой другой задачи из класса NP можно будет найти соответствующее решение.</p>
<p>В теории алгоритмов - задача с ответом «да» или «нет» из класса NP, к которой можно свести любую другую задачу из этого класса за полиномиальное время (то есть при помощи операций, число которых не превышает некоторого полинома в зависимости от размера исходных данных).</p>
<p>Таким образом, NP-полные задачи образуют в некотором смысле подмножество «типовых» задач в классе NP: если для какой-то из них найден «полиномиально быстрый» алгоритм решения, то и любая другая задача из класса NP может быть решена так же «быстро».</p>
<p>К классу NP-полных относятся задача о коммивояжере, о вершинном покрытии и покрытии множеств.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Базы-данных"><a class="header" href="#Базы-данных">Базы данных</a></h1>
<p>В данном разделе рассказывается о классической теории баз данных + об особенностях работы и устройства различных реально существующих СУБД.</p>
<ul>
<li><a href="db/dBTheory/README.html">Теория Баз Данных</a></li>
<li><a href="db/specific/README.html">Конкретные БД</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Теория-баз-данных"><a class="header" href="#Теория-баз-данных">Теория баз данных</a></h1>
<p>Классическая теория БД не привязанна к каким-либо конкретным системам хранения и обработки данных.</p>
<p>База данных — представленная в объективной форме совокупность самостоятельных материалов (статей, расчётов, нормативных актов, судебных решений и иных подобных материалов), систематизированных таким образом, чтобы эти материалы могли быть найдены и обработаны с помощью электронной вычислительной машины. Многие специалисты указывают на распространённую ошибку, состоящую в некорректном использовании термина «база данных» вместо термина «система управления базами данных», и указывают на необходимость различения этих понятий.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Транзакции"><a class="header" href="#Транзакции">Транзакции</a></h1>
<p><strong>Транзакция</strong> - атомарное действие над БД, переводящее ее из одного целостного состояния в другое целостное состояние. Другими словами, транзакция - это последовательность операций, которые должны быть или все выполнены, или все не выполнены.</p>
<h3 id="acid"><a class="header" href="#acid">ACID</a></h3>
<p>В информатике акроним <strong>ACID</strong> описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу. Требования <strong>ACID</strong> были в основном сформулированы в конце 70-х годов Джимом Греем.</p>
<h3 id="atomicity--Атомарность"><a class="header" href="#atomicity--Атомарность">Atomicity — Атомарность</a></h3>
<p>Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)</p>
<h3 id="consistency--Согласованность"><a class="header" href="#consistency--Согласованность">Consistency — Согласованность</a></h3>
<p>Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.</p>
<p>Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.</p>
<h3 id="isolation--Изолированность"><a class="header" href="#isolation--Изолированность">Isolation — Изолированность</a></h3>
<p>Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию</p>
<h3 id="durability--Долговечность"><a class="header" href="#durability--Долговечность">Durability — Долговечность</a></h3>
<p>Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.</p>
<h3 id="Проблемы-параллельного-доступа-с-использованием-транзакций"><a class="header" href="#Проблемы-параллельного-доступа-с-использованием-транзакций">Проблемы параллельного доступа с использованием транзакций</a></h3>
<p>При параллельном выполнении транзакций возможны следующие проблемы:</p>
<ul>
<li>потерянное обновление (англ. lost update) — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;</li>
</ul>
<table><thead><tr><th>Транзакция 1</th><th>Транзакция 2</th></tr></thead><tbody>
<tr><td><code>UPDATE tbl1 SET f2=f2+20 WHERE f1=1;</code></td><td><code>UPDATE tbl1 SET f2=f2+25 WHERE f1=1;</code></td></tr>
</tbody></table>
<ul>
<li>«грязное» чтение (англ. dirty read) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);</li>
</ul>
<table><thead><tr><th>Транзакция 1</th><th>Транзакция 2</th></tr></thead><tbody>
<tr><td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code></td><td></td></tr>
<tr><td></td><td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td></tr>
<tr><td><code>ROLLBACK WORK;</code></td><td></td></tr>
</tbody></table>
<ul>
<li>неповторяющееся чтение (англ. non-repeatable read) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;</li>
</ul>
<table><thead><tr><th>Транзакция 1</th><th>Транзакция 2</th></tr></thead><tbody>
<tr><td></td><td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td></tr>
<tr><td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code></td><td></td></tr>
<tr><td><code>COMMIT;</code></td><td></td></tr>
<tr><td></td><td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td></tr>
</tbody></table>
<ul>
<li>фантомное чтение (англ. phantom reads) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки, или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.</li>
</ul>
<table><thead><tr><th>Транзакция 1</th><th>Транзакция 2</th></tr></thead><tbody>
<tr><td></td><td><code>SELECT SUM(f2) FROM tbl1;</code></td></tr>
<tr><td><code>INSERT INTO tbl1 (f1,f2) VALUES (15,20);</code></td><td></td></tr>
<tr><td><code>COMMIT;</code></td><td></td></tr>
<tr><td></td><td><code>SELECT SUM(f2) FROM tbl1;</code></td></tr>
</tbody></table>
<h2 id="Уровень-изолированности-транзакций"><a class="header" href="#Уровень-изолированности-транзакций">Уровень изолированности транзакций</a></h2>
<p><strong>Уровень изолированности транзакций</strong> — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.</p>
<p>Стандарт <a href="http://www.contrib.andrew.cmu.edu/%7Eshadow/sql/sql1992.txt">SQL-92</a> определяет шкалу из четырёх уровней изоляции: Read uncommitted, Read committed, Repeatable read, Serializable.</p>
<h3 id="read-uncommitted-чтение-незафиксированных-данных"><a class="header" href="#read-uncommitted-чтение-незафиксированных-данных">Read uncommitted (чтение незафиксированных данных)</a></h3>
<p>Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений[1]. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.</p>
<p>Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.</p>
<h3 id="read-committed-чтение-фиксированных-данных"><a class="header" href="#read-committed-чтение-фиксированных-данных">Read committed (чтение фиксированных данных)</a></h3>
<p>На этом уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая транзакция будет работать с другим набором данных.</p>
<p>Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или версионности:</p>
<ul>
<li><strong>Блокирование читаемых и изменяемых данных</strong>. Заключается в том, что читающая транзакция блокирует читаемые данные в разделяемом (shared) режиме, в результате чего параллельная транзакция, пытающаяся изменить эти данные, приостанавливается, а пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению.</li>
<li><strong>MVCC(Multiversion concurrency control) Сохранение нескольких версий параллельно изменяемых строк</strong>. При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать изменившая данные транзакция, в то время как любой другой «читающей» транзакции возвращается последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает бо́льшую скорость, так как предотвращает блокировки. Однако он требует, по сравнению с первым, существенно бо́льшего расхода оперативной памяти, которая тратится на хранение версий строк. Кроме того, при параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько параллельных транзакций произведут несогласованные изменения одних и тех же данных (поскольку блокировки отсутствуют, ничто не помешает это сделать). Тогда та транзакция, которая зафиксируется первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется невозможно зафиксировать (так как это приведёт к потере обновления первой транзакции). Единственное, что может в такой ситуации СУБД — это откатить остальные транзакции и выдать сообщение об ошибке «Запись уже изменена».</li>
</ul>
<h3 id="repeatable-read-повторяемость-чтения"><a class="header" href="#repeatable-read-повторяемость-чтения">Repeatable read (повторяемость чтения)</a></h3>
<p>Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.</p>
<p>Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими уровнями транзакций без необходимости обычно не рекомендуется.</p>
<h3 id="serializable-упорядочиваемость"><a class="header" href="#serializable-упорядочиваемость">Serializable (упорядочиваемость)</a></h3>
<p>Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/company/oleg-bunin/blog/358984/">Как устроены базы данных</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Нормализация-и-нормальные-формы"><a class="header" href="#Нормализация-и-нормальные-формы">Нормализация и нормальные формы</a></h1>
<p><strong>Нормализация</strong> — это процесс организации данных в базе данных, включающий создание таблиц и установление отношений между ними в соответствии с правилами (нормальными формами), которые обеспечивают защиту данных и делают базу данных более гибкой, устраняя избыточность и несогласованные зависимости.</p>
<p>Процесс проектирования БД с использованием метода НФ является итерационным и заключается в последовательном переводе отношения из 1НФ в НФ более высокого порядка по определенным правилам. Каждая следующая НФ ограничивается определенным типом функциональных зависимостей и устранением соответствующих аномалий при выполнении операций над отношениями БД, а также сохранении свойств предшествующих НФ.</p>
<p><strong>Нормальная форма</strong> — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).</p>
<p><strong>Функциональная зависимость</strong> между атрибутами (множествами атрибутов) X и Y означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. Например, если значение атрибута «Название компании» — Canonical Ltd, то значением атрибута «Штаб-квартира» в таком кортеже всегда будет Millbank Tower, London, United Kingdom. Обозначение: {X} -&gt; {Y}.</p>
<p><strong>Метод нормальных форм (НФ)</strong> состоит в сборе информации об объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений. </p>
<p><strong>Цель нормализации</strong>: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежей(строк таблицы).</p>
<p><strong>Аномалией</strong> называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не ключевых атрибутов.</p>
<p><strong>Аномалии-модификации</strong> проявляются в том, что изменение одних данных может повлечь просмотр всей таблицы и соответствующее изменение некоторых записей таблицы.</p>
<p><strong>Аномалии-удаления</strong> — при удалении какого либо кортежа из таблицы может пропасть информация, которая не связана на прямую с удаляемой записью.</p>
<p><strong>Аномалии-добавления</strong> возникают, когда информацию в таблицу нельзя поместить, пока она не полная, либо вставка записи требует дополнительного просмотра таблицы.</p>
<h4 id="Первая-нормальная-форма"><a class="header" href="#Первая-нормальная-форма">Первая нормальная форма</a></h4>
<p>Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.</p>
<p>Например, есть таблица «Автомобили»:</p>
<table><thead><tr><th>Фирма</th><th>Модели</th></tr></thead><tbody>
<tr><td>BMW</td><td>M5, X5M, M1</td></tr>
<tr><td>Nissan</td><td>GT-R</td></tr>
</tbody></table>
<p>Нарушение нормализации 1НФ происходит в моделях BMW, т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, т.е. он не является атомарным. Преобразуем таблицу к 1НФ:</p>
<table><thead><tr><th>Фирма</th><th>Модели</th></tr></thead><tbody>
<tr><td>BMW</td><td>M5</td></tr>
<tr><td>BMW</td><td>X5M</td></tr>
<tr><td>BMW</td><td>M1</td></tr>
<tr><td>Nissan</td><td>GT-R</td></tr>
</tbody></table>
<h4 id="Вторая-нормальная-форма"><a class="header" href="#Вторая-нормальная-форма">Вторая нормальная форма</a></h4>
<p>Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(ПК).</p>
<p>Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.</p>
<p>Например, дана таблица:</p>
<table><thead><tr><th>Модель</th><th>Фирма</th><th>Цена</th><th>Скидка</th></tr></thead><tbody>
<tr><td>M5</td><td>BMW</td><td>5500000</td><td>5%</td></tr>
<tr><td>X5M</td><td>BMW</td><td>6000000</td><td>5%</td></tr>
<tr><td>M1</td><td>BMW</td><td>2500000</td><td>5%</td></tr>
<tr><td>GT-R</td><td>Nissan</td><td>5000000</td><td>10%</td></tr>
</tbody></table>
<p>Таблица находится в первой нормальной форме, но не во второй. Цена машины зависит от модели и фирмы. Скидка зависит от фирмы, то есть зависимость от первичного ключа неполная. Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят от ПК.</p>
<table><thead><tr><th>Модель</th><th>Фирма</th><th>Цена</th></tr></thead><tbody>
<tr><td>M5</td><td>BMW</td><td>5500000</td></tr>
<tr><td>X5M</td><td>BMW</td><td>6000000</td></tr>
<tr><td>M1</td><td>BMW</td><td>2500000</td></tr>
<tr><td>GT-R</td><td>Nissan</td><td>5000000</td></tr>
</tbody></table>
<table><thead><tr><th>Фирма</th><th>Скидка</th></tr></thead><tbody>
<tr><td>BMW</td><td>5%</td></tr>
<tr><td>Nissan</td><td>10%</td></tr>
</tbody></table>
<h4 id="Третья-нормальная-форма"><a class="header" href="#Третья-нормальная-форма">Третья нормальная форма</a></h4>
<p>Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от первичного ключа. Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.</p>
<p>Рассмотрим таблицу:</p>
<table><thead><tr><th>Модель</th><th>Магазин</th><th>Телефон</th></tr></thead><tbody>
<tr><td>BMW</td><td>Риал-авто</td><td>87-33-98</td></tr>
<tr><td>Audi</td><td>Риал-авто</td><td>87-33-98</td></tr>
<tr><td>Nissan</td><td>Некст-Авто</td><td>94-54-12</td></tr>
</tbody></table>
<p>Таблица находится во 2НФ, но не в 3НФ.</p>
<p>В отношении атрибут «Модель» является первичным ключом. Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.</p>
<p>Таким образом, в отношении существуют следующие функциональные зависимости: Модель → Магазин, Магазин → Телефон, Модель → Телефон.</p>
<p>Зависимость Модель → Телефон является транзитивной, следовательно, отношение не находится в 3НФ.</p>
<p>В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:</p>
<p>Риал-авто 87-33-98 </p>
<p>Риал-авто 87-33-98 </p>
<p>Некст-Авто 94-54-12 </p>
<table><thead><tr><th>Модель</th><th>Магазин</th></tr></thead><tbody>
<tr><td>BMW</td><td>Риал-авто</td></tr>
<tr><td>Audi</td><td>Риал-авто</td></tr>
<tr><td>Nissan</td><td>Некст-Авто</td></tr>
</tbody></table>
<h4 id="Нормальная-форма-Бойса-Кодда-НФБК-частная-форма-третьей-нормальной-формы"><a class="header" href="#Нормальная-форма-Бойса-Кодда-НФБК-частная-форма-третьей-нормальной-формы">Нормальная форма Бойса-Кодда (НФБК) (частная форма третьей нормальной формы)</a></h4>
<p>Определение 3НФ не совсем подходит для следующих отношений:</p>
<ol>
<li>
<p>отношение имеет две или более потенциальных ключа;</p>
</li>
<li>
<p>два и более потенциальных ключа являются составными;</p>
</li>
<li>
<p>они пересекаются, т.е. имеют хотя бы один атрибут.</p>
</li>
</ol>
<p>Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.</p>
<p>Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным ключом в качестве детерминанта.</p>
<p>Предположим, рассматривается отношение, представляющее данные о бронировании стоянки на день:</p>
<table><thead><tr><th>Номер стоянки</th><th>Время начала</th><th>Время окончания</th><th>Тариф</th></tr></thead><tbody>
<tr><td>1</td><td>09:30</td><td>10:30</td><td>Бережливый</td></tr>
<tr><td>1</td><td>11:00</td><td>12:00</td><td>Бережливый</td></tr>
<tr><td>1</td><td>14:00</td><td>15:30</td><td>Стандарт</td></tr>
<tr><td>2</td><td>10:00</td><td>12:00</td><td>Премиум-В</td></tr>
<tr><td>2</td><td>12:00</td><td>14:00</td><td>Премиум-В</td></tr>
<tr><td>2</td><td>15:00</td><td>18:00</td><td>Премиум-А</td></tr>
</tbody></table>
<p>Тариф имеет уникальное название и зависит от выбранной стоянки и наличии льгот, в частности:</p>
<ul>
<li>«Бережливый»: стоянка 1 для льготников</li>
<li>«Стандарт»: стоянка 1 для не льготников</li>
<li>«Премиум-А»: стоянка 2 для льготников</li>
<li>«Премиум-B»: стоянка 2 для не льготников.</li>
</ul>
<p>Таким образом, возможны следующие составные первичные ключи: {Номер стоянки, Время начала}, {Номер стоянки, Время окончания}, {Тариф, Время начала}, {Тариф, Время окончания}.</p>
<p>Отношение находится в 3НФ. Требования второй нормальной формы выполняются, так как все атрибуты входят в какой-то из потенциальных ключей, а неключевых атрибутов в отношении нет. Также нет и транзитивных зависимостей, что соответствует требованиям третьей нормальной формы. Тем не менее существует функциональная зависимость Тариф → Номер стоянки, в которой левая часть (детерминант) не является потенциальным ключом отношения, то есть отношение не находится в нормальной форме Бойса — Кодда.</p>
<p>Недостатком данной структуры является то, что, например, по ошибке можно приписать тариф «Бережливый» к бронированию второй стоянки, хотя он может относиться только к первой стоянки.</p>
<p>Можно улучшить структуру с помощью декомпозиции отношения на два и добавления атрибута </p>
<p><strong>Имеет льготы</strong>, получив отношения, удовлетворяющие НФБК (подчёркнуты атрибуты, входящие в первичный ключ.):</p>
<p>Тарифы</p>
<table><thead><tr><th>Тариф</th><th>Номер стоянки</th><th>Имеет льготы</th></tr></thead><tbody>
<tr><td>Бережливый</td><td>1</td><td>Да</td></tr>
<tr><td>Стандарт</td><td>1</td><td>Нет</td></tr>
<tr><td>Премиум-А</td><td>2</td><td>Да</td></tr>
<tr><td>Премиум-В</td><td>2</td><td>Нет</td></tr>
</tbody></table>
<p>Бронирование</p>
<table><thead><tr><th>Тариф</th><th>Время начала</th><th>Время окончания</th></tr></thead><tbody>
<tr><td>Бережливый</td><td>09:30</td><td>10:30</td></tr>
<tr><td>Бережливый</td><td>11:00</td><td>12:00</td></tr>
<tr><td>Стандарт</td><td>14:00</td><td>15:30</td></tr>
<tr><td>Премиум-В</td><td>10:00</td><td>12:00</td></tr>
<tr><td>Премиум-В</td><td>12:00</td><td>14:00</td></tr>
<tr><td>Премиум-А</td><td>15:00</td><td>18:00</td></tr>
</tbody></table>
<p>Также еще есть несколько нормальных форм(4,5,Доменно-ключевая,6) но на них всем похуй.</p>
<p><em><strong>Дополнительное чтение:</strong></em></p>
<p><a href="https://habr.com/post/254773/">Нормализация отношений. Шесть нормальных форм</a></p>
<p><a href="http://www.libma.ru/kompyutery_i_internet/bazy_dannyh_konspekt_lekcii/p10.php">Лекция № 10. Нормальные формы</a></p>
<p><a href="http://www.mstu.edu.ru/study/materials/zelenkov/ch_4_2.html">4.2.Теория нормальных форм.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Распределенные-системы"><a class="header" href="#Распределенные-системы">Распределенные системы</a></h1>
<ul>
<li><a href="db/dBTheory/distrubedDb/replication.html">Репликация</a></li>
<li><a href="db/dBTheory/distrubedDb/sharding.html">Шардинг</a></li>
<li><a href="db/dBTheory/distrubedDb/unsorted.html">Разное</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Репликация-replication"><a class="header" href="#Репликация-replication">Репли­ка­ция (replication)</a></h1>
<p><strong>Репликация</strong> — одна из техник масштабирования баз данных. Состоит эта техника в том, что данные с одного сервера базы данных постоянно копируются (реплицируются) на один или несколько других (называемые репликами). Для приложения появляется возможность использовать не один сервер для обработки всех запросов, а несколько. Таким образом появляется возможность распределить нагрузку с одного сервера на несколько.</p>
<p>Репликация — это синхронное или асинхронное копирование данных между несколькими серверами. Ведущие сервера называют <strong>master</strong>, а ведомые сервера <strong>slave</strong>. Мастера используются для изменения данных, а слэйвы для считывания. В классической схеме репликации обычно один мастер и несколько слэйвов, так как в большей части веб-проектов операций чтения на несколько порядков больше, чем операций записи. Однако в более сложной схеме репликации может быть и несколько мастеров.</p>
<p>Например, создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слэйвы под конкретные ресурсоёмкие задачи и таким образом, например, упростить составление серьёзных аналитических отчётов — используемый для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.</p>
<h2 id="Проблемы-решаемые-репликацией"><a class="header" href="#Проблемы-решаемые-репликацией">Проблемы, решаемые репликацией</a></h2>
<ul>
<li>
<p><strong>Распространение данных</strong>. Обычно репликация в MySQL потребляет не очень большую часть пропускной способности сети, к тому же ее можно в любой момент остановить и затем возобновить. Это полезно, если хранение копии данных происходит в географически удаленном пункте, например в другом центре обработки данных. Удаленный подчиненный сервер может работать даже с непостоянным (намеренно или по другим причинам) соединением. Однако если вы хотите обеспечить минимальное отставание реплики, то следует использовать надежный канал с малым временем задержки.</p>
</li>
<li>
<p><strong>Балансировка нагрузки</strong>. С помощью репликации можно распределить запросы на чтение между несколькими серверами MySQL; в приложениях с интенсивным чтением эта тактика работает очень хорошо. Реализовать несложное балансирование нагрузки можно, внеся совсем немного изменений в код. Для небольших приложений достаточно просто «зашить» в программу несколько доменных имен или воспользоваться циклическим (round-robin) разрешением DNS-имен (когда с одним доменным именем связано несколько IP-адресов). Возможны и более изощренные решения. Стандартные технологии балансирования нагрузки, в частности сетевые балансировщики, прекрасно послужат для распределения нагрузки между несколькими серверами MySQL.</p>
</li>
<li>
<p><strong>Резервное копирование</strong>. Репликация – это ценное подспорье для резервного копирования. Однако подчиненный сервер все же не может использоваться в качестве резервной копии и не является заменой настоящему резервному копированию.</p>
</li>
<li>
<p><strong>Высокая доступность и аварийное переключение на резервный сервер(failover)</strong>. Репликация позволяет исправить ситуацию, при которой сервер MySQL является единственной точкой отказа приложения. Хорошая сис тема аварийного переключения при отказе, имеющая в составе реплицированные подчиненные серверы, способна существенно сократить время простоя. </p>
</li>
</ul>
<p><img src="db/dBTheory/distrubedDb/../../../media/replicationHl.jpg" alt="" /></p>
<h2 id="Топологии-репликации"><a class="header" href="#Топологии-репликации">Топологии репликации</a></h2>
<h3 id="master-slave-репликация"><a class="header" href="#master-slave-репликация">Master-Slave репликация</a></h3>
<p>В этом подходе выделяется один основной сервер базы данных, который называется Master. На нем происходят все изменения в данных (любые запросы MySQL INSERT/UPDATE/DELETE). Слейв сервер постоянно копирует все изменения с Master. С приложения на Слейв сервер отправляются запросы чтения данных (запросы SELECT). Таким образом Master сервер отвечает за изменения данных, а Slave за чтение.</p>
<h3 id="master-master-репикация"><a class="header" href="#master-master-репикация">Master-Master репикация</a></h3>
<p>Существует также схема Master-Master в ней любой из серверов может использоваться как для чтения, так и для записи. Но вероятные поломки делают Master-Master репликацию непривлекательной. Выход из строя одного из серверов практически всегда приводит к потере каких-то данных. Последующее восстановление также сильно затрудняется необходимостью ручного анализа данных, которые успели либо не успели скопироваться.</p>
<p>Следует отметить, что репликация сама по себе не очень удобный механизм масштабирования. Причиной тому — рассинхронизация данных и задержки в копировании с мастера на слейв. Зато это отличное средство для обеспечения отказоустойчивости. Вы всегда можете переключиться на слейв, если мастер ломается и наоборот. Чаще всего репликация используется совместно с шардингом именно из соображений надежности.</p>
<h3 id="Репликация-без-master"><a class="header" href="#Репликация-без-master">Репликация без Master</a></h3>
<p>Некоторые системы хранения данных используют подход, отказываясь от концепции ведущего узла и позволяя непосредственное поступление информации об операциях записи на все реплики. В ряде ранних реплицируемых информационных систем не было ведущего узла, но за время доминирования реляционных баз данных эта идея была практически забыта. Такая архитектура снова вошла в моду после того, как Amazon задействовал ее для своей предназначенной для внутреннего использования системы <strong>Dynamo</strong>. <strong>Riak</strong>, <strong>Cassandra</strong> и <strong>Voldemort</strong> представляют собой вдохновленные Dynamo склады данных с открытым исходным кодом, применяющие модели репликации без ведущего узла. Поэтому подобный тип БД называют Dynamo-подобной базой данных (<strong>Dynamo-style database</strong>). </p>
<p>В некоторых реализациях репликации без ведущего узла клиент непосредственно отправляет информацию о своих операциях записи на несколько реплик, в то время как для остальных данную манипуляцию от имени клиента совершает узел-координатор. Однако он, в отличие от БД с ведущим узлом, не навязывает определенный порядок операций записи. Как мы увидим в дальнейшем, это отличие в архитектуре приводит к очень серьезным последствиям в смысле стиля использования базы данных</p>
<h2 id="Как-работает-репликация"><a class="header" href="#Как-работает-репликация">Как работает репликация</a></h2>
<p>Главный сервер записывает изменения данных в двоичный журнал. Эти записи называются событиями двоичного журнала. Конкретные реализации репликации могут быть нескольких видов.</p>
<h3 id="Операторнаякомандная"><a class="header" href="#Операторнаякомандная"><strong>Операторная</strong>(командная).</a></h3>
<p>В простейшем случае ведущий узел записывает в журнал <strong>каждый</strong> выполняемый запрос на запись (оператор) и отправляет данный журнал выполнения операторов ведомым узлам. В случае реляционной БД это значит, что каждый оператор <strong>INSERT</strong>, <strong>UPDATE</strong> или <strong>DELETE</strong> пересылается ведомым узлам, и каждый ведомый узел производит синтаксический разбор и выполнение этого оператора SQL так, как если бы он был получен от клиента.</p>
<p>Но есть проблемы:</p>
<ul>
<li>Все операторы, вызывающие недетерминированные функции (например, функцию NOW() для получения текущего времени или RAND() — для случайного числа), вероятно, будут генерировать разные значения для каждой реплики.</li>
<li>Если операторы используют столбец с автоматически увеличиваемым значением или зависят от существующих данных из базы (например, UPDATE … WHERE &lt;какое-то условие&gt;), то они должны выполняться на всех репликах в строго одинаковом порядке, иначе их результаты будут различными. Это может быть неудобно в случае множества параллельно выполняемых транзакций. </li>
<li>Операторы с побочными действиями (например, триггеры, хранимые процедуры, пользовательские функции) могут приводить к различным побочным действиям на разных репликах, за исключением случая, когда все побочные действия полностью детерминированы. </li>
</ul>
<p>Эти проблемы решаемы: например, ведущий узел может заменять все вызовы недетерминированных функций фиксированным возвращаемым значением при записи оператора в журнал, чтобы все ведомые узлы получали одно значение. Однако в связи с большим количеством граничных случаев обычно предпочитают другие методы репликации. Операторная репликация использовалась в MySQL вплоть до версии 5.1. Она иногда применяется и сейчас, в силу своей компактности, но по умолчанию MySQL переключается на построчную репликацию при малейших признаках недетерминизма в операторе. VoltDB задействует операторную репликацию и обеспечивает ее надежную работу путем требования детерминизма транзакций.</p>
<h3 id="Перенос-журнала-упреждающей-записи-walфизическая-репликация"><a class="header" href="#Перенос-журнала-упреждающей-записи-walфизическая-репликация">Перенос журнала упреждающей записи WAL(физическая репликация)</a></h3>
<p>В двоичный журнал записывает фактические изменения данных Самое существенное достоинство заключается в том, что теперь MySQL может корректно реплицировать любую команду, причем в некоторых случаях это происходит гораздо более эффективно. Основной недостаток – это то, что двоичный журнал стал намного больше и из него непонятно, какие команды привели к обновлению данных, так что использовать его для аудита с помощью программы mysqlbinlog уже невозможно. Команды не включаются в журнал событий, поэтому будет сложно определить, какая команда выполнялась. Во многих случаях знать это так же важно, как и знать об изменении строк. Фактически процесс применения изменений при построчной репликации в значительной степени является черным ящиком — не видно, что делает сервер. Кроме того, он плохо документирован и объяснен, поэтому когда что-то работает неправильно, устранить неполадки довольно сложно. Например, если подчиненный сервер выберет неэффективный способ поиска строк для изменения, вы этого не заметите.</p>
<ul>
<li>
<p>Подчиненный сервер копирует события двоичного журнала в свой журнал ретрансляции (relay log).</p>
</li>
<li>
<p>Подчиненный сервер воспроизводит события из журнала ретрансляции, применяя изменения к собственным данным.</p>
</li>
</ul>
<p><img src="db/dBTheory/distrubedDb/../../../media/masterSlaveReplication.png" alt="" /></p>
<p>Основной его недостаток метода состоит в том, что журнал описывает данные на очень низком уровне: WAL содержит все подробности того, какие байты менялись в тех или иных дисковых блоках. Это тесно связывает репликацию с подсистемой хранения. Если база данных меняет формат хранения с одной версии на другую, то обычно становится невозможной работа различных версий СУБД на ведущем и ведомых узлах.</p>
<p>На первый взгляд, это лишь незначительный нюанс реализации, но влияние его на эксплуатацию огромно. Если протокол репликации допускает использование ведомыми узлами более нового программного обеспечения, чем ведущим, то появляется возможность выполнять обновление ПО базы данных без всякого простоя: сначала обновляются ведомые узлы, а затем производится восстановление после отказа, чтобы сделать один из этих обновленных узлов новым ведущим. Если же протокол репликации не допускает подобного расхождения версий, как часто бывает при переносе журнала упреждающей записи, то подобные обновления требуют простоя системы</p>
<h3 id="Логическая-построчная-журнальная-репликация"><a class="header" href="#Логическая-построчная-журнальная-репликация">Логическая (построчная) журнальная репликация</a></h3>
<p>Альтернатива — использовать разные форматы журнала для репликации и подсистемы хранения; это даст возможность расцепить журнал репликации с внутренним устройством подсистемы хранения. Такой вид журнала называется логическим журналом (<strong>logical log</strong>), чтобы различать его с физическим представлением данных подсистемы хранения. </p>
<p>Логический журнал для реляционных баз данных обычно представляет собой последовательность строк, описывающих операции записи в таблицы базы на уровне строк:</p>
<ul>
<li>при вставке строки журнал включает новые значения всех столбцов;</li>
<li>при удалении строки журнал содержит информацию, достаточную для однозначной идентификации удаляемой строки. Обычно это первичный ключ, но если в таблице он отсутствует, то сохраняются старые значения всех столбцов; </li>
<li>при обновлении строки журнал содержит информацию, достаточную для однозначной идентификации обновляемой строки, и новые значения всех столбцов (или по крайней мере новые значения всех изменившихся столбцов). </li>
</ul>
<p>Транзакция, меняющая несколько строк, приводит к генерации нескольких подобных записей в журнале, за которыми следует запись, указывающая, что транзакция была зафиксирована. Этот подход использует бинарный журнал СУБД MySQL (в случае, когда он настроен на применение построчной репликации). Поскольку логический журнал расцеплен с внутренним устройством подсистемы хранения, оказывается проще поддерживать его обратную совместимость, благодаря чему на ведущем и ведомых узлах могут выполняться различные версии СУБД или даже различные подсистемы хранения. Формат логического журнала также удобнее для синтаксического разбора внешними приложениями. Этот аспект играет важную роль при необходимости отправить содержимое БД во внешнюю систему, например в склад данных для офлайн-анализа или построения пользовательских индексов и кэшей. Такая методика называется захватом изменений данных (change data capture).</p>
<h3 id="Триггерная-репликация"><a class="header" href="#Триггерная-репликация">Триггерная репликация</a></h3>
<p>Описанные до сих пор подходы к репликации реализовались СУБД без участия кода приложения. Во многих случаях именно это и нужно, но встречаются обстоятельства, когда требуется большая гибкость. Например, если необходимо реплицировать только подмножество данных, или выполнить репликацию из БД одного типа в БД другого, или задействовать логику разрешения конфликтов, то может понадобиться перенести репликацию на уровень приложения. Некоторые утилиты, например Oracle GoldenGate, позволяют приложению получить доступ к данным с помощью чтения журнала БД. Или же можно воспользоваться возможностями, имеющимися во многих реляционных БД: триггерами (trigger) и хранимыми процедурами (stored procedure). Триггеры позволяют регистрировать пользовательский код, автоматически запускаемый при возникновении в БД события изменения данных (транзакции записи). Триггер получает возможность занести изменения в отдельную таблицу, из которой их сможет прочитать внешний процесс. Затем этот внешний процесс сможет применить любую логику приложения, которая только понадобится, и реплицировать изменения данных в другую систему. Накладные расходы при триггерной репликации обычно выше, чем при других типах репликации, и она сильнее подвержена ошибкам и более ограниченна, чем встроенная репликация базы данных. Однако благодаря своей гибкости может оказаться полезной</p>
<h2 id="Синхронная-и-асинхронная"><a class="header" href="#Синхронная-и-асинхронная">Синхронная и асинхронная</a></h2>
<p><img src="db/dBTheory/distrubedDb/../../../media/replicationUpdate.jpg" alt="img" /></p>
<h3 id="Синхронная"><a class="header" href="#Синхронная">Синхронная</a></h3>
<p>В случае синхронной репликации, если данная реплика обновляется, все другие реплики того же фрагмента данных также должны быть обновлены в одной и той же транзакции. Логически это означает, что существует лишь одна версия данных.</p>
<p>В большинстве продуктов синхронная репликация реализуется с помощью триггерных процедур (возможно, скрытых и управляемых системой). Но синхронная репликация имеет тот недостаток, что она создаёт дополнительную нагрузку при выполнении всех транзакций, в которых обновляются какие-либо реплики (кроме того, могут возникать проблемы, связанные с доступностью данных).</p>
<p>Синхронная означает, если у вас commit прошел, то база вам обещает, что не просто commit прошел, а он еще и прошел на удаленных нодах. Т.е. мы commit сделали, подключились к одной конкретной ноде, к одному конкретному серверу, эти данные в идеале, чтобы обеспечить и масштабируемость по чтениям и доступность данных, должны улететь на соседние машины, и транзакции там должны зафиксироваться. Это синхронная репликация.</p>
<h3 id="Асинхронная"><a class="header" href="#Асинхронная">Асинхронная</a></h3>
<p>В случае <em>асинхронной репликации</em> обновление одной реплики распространяется на другие спустя некоторое время, а не в той же транзакции. Таким образом, при асинхронной репликации вводится задержка, или время ожидания, в течение которого отдельные реплики могут быть фактически неидентичными (то есть определение <em>реплика</em> оказывается не совсем подходящим, поскольку мы не имеем дело с точными и своевременно созданными копиями).</p>
<p>В большинстве продуктов асинхронная репликация реализуется посредством чтения журнала транзакций или постоянной очереди тех обновлений, которые подлежат распространению. Преимущество асинхронной репликации состоит в том, что дополнительные издержки репликации не связаны с транзакциями обновлений, которые могут иметь важное значение для функционирования всего предприятия и предъявлять высокие требования к производительности.</p>
<p>К недостаткам этой схемы относится то, что данные могут оказаться несовместимыми (то есть несовместимыми с точки зрения пользователя). Иными словами, избыточность может проявляться на логическом уровне, а это, строго говоря, означает, что термин контролируемая избыточность в таком случае не применим.</p>
<p>Асинхронность репликации означает, что данные на Слейве могут появиться с небольшой задержкой. Поэтому, в последовательных операциях необходимо использовать чтение с Мастера, чтобы получить актуальные данные.</p>
<p>Рассмотрим кратко проблему согласованности (или, скорее, несогласованности). Дело в том, что реплики могут становиться несовместимыми в результате ситуаций, которые трудно (или даже невозможно) избежать и последствия которых трудно исправить.</p>
<p>В частности, конфликты могут возникать по поводу того, в каком порядке должны применяться обновления. Например, предположим, что в результате выполнения транзакции А происходит вставка строки в реплику X, после чего транзакция B удаляет эту строку, а также допустим, что Y — реплика X. Если обновления распространяются на Y, но вводятся в реплику Y в обратном порядке (например, из-за разных задержек при передаче), то транзакция B не находит в Y строку, подлежащую удалению, и не выполняет своё действие, после чего транзакция А вставляет эту строку. Суммарный эффект состоит в том, что реплика Y содержит указанную строку, а реплика X — нет.</p>
<p>Но ок, транзакция зафиксировалась локально, это тебе что-нибудь гарантирует? Правильный ответ – нет. Потому что возможно, что все остальные реплики лежат дохлые, и те данные, которые вы вкатили на master, они у вас никуда не резервируются. Если у вас master просто упадет, в смысле SQL-сервер упадет, то все хорошо условно, он эти изменения с Write-Ahead Log'a проиграет, но если у вас внезапно демоническая сила подожжет сервер, и он сгорит, прям весь, то данные, которые вы якобы зафиксировали, они на самом деле зафиксировались на одной машине.</p>
<h4 id="Полусинхронная"><a class="header" href="#Полусинхронная">Полусинхронная</a></h4>
<p>Синхронность – хорошо с точки зрения надежности, но медленно. Асинхронность полная – зафиксировали локально транзакцию и не ждем вообще удаленные реплики – очевидно быстро (ничем же не отличается от локального commit'a), но никаких гарантий по надежности.</p>
<p>Возникает промежуточный вариант – полусинхронная репликация – это когда commit возвращает успех, в тот момент, когда локально транзакция уже зафиксирована, селекты к master'у уже начнут возвращать новое состояние, новый баланс, и удаленные сервера уже скачали эти данные, уже скачали эту транзакцию, но возможно еще не успели накатить, то ли накатят через 2 секунды, то ли через 2 недели – как повезет. Это самый важный момент, с которым на практике придется сталкиваться, и делать выбор, настраивать и т.д.</p>
<p>Также есть другое определение полусинхронности: делать все ведомые узлы синхронными неразумно: перебой в обслуживании одного любого узла приведет к замедлению работы системы вплоть до полной остановки. На практике активизация в СУБД синхронной репликации обычно означает, что один из ведомых узлов — синхронный, а остальные — асинхронны. В случае замедления или недоступности синхронного ведомого узла в него превращается один из асинхронных ведомых узлов. Это гарантирует наличие актуальной копии данных по крайней мере на двух узлах: ведущем и одном синхронном ведомом. Такая конфигурация иногда называется полусинхронной (semi-synchronous).</p>
<h3 id="Инвалидация-кеша-при-репликации"><a class="header" href="#Инвалидация-кеша-при-репликации">Инвалидация кеша при репликации</a></h3>
<p>https://emacsway.github.io/ru/cache-dependencies/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Шардинг-sharding"><a class="header" href="#Шардинг-sharding">Шардинг (sharding)</a></h1>
<p>Шардинг — прием, который позволяет распределять данные между разными физическими серверами. Процесс шардинга предполагает разнесения данных между отдельными шардами на основе некого ключа шардинга. Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключу, а этот набор хранится в пределах одного физического шарда. Это существенно облегчает обработку данных. </p>
<p>Шардинг можно рассматривать как частный случай партиционирования. Партиционирование(partitioning, также секционирование) — это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным администратором критериям. Партиционирование таблиц делит весь объем операций по обработке данных на несколько независимых и параллельно выполняющихся потоков, что существенно ускоряет работу СУБД. Для правильного конфигурирования параметров партиционирования необходимо, чтобы в каждом потоке было примерно одинаковое количество записей.</p>
<p><em>Например, на новостных сайтах имеет смысл партиционировать записи по дате публикации, так как свежие новости на несколько порядков более востребованы и чаще требуется работа именно с ними, а не со всех архивом за годы существования новостного ресурса.</em></p>
<p>Самая важная и сложная задача, возникающая при шардинге – поиск и выборка данных. Способ поиска зависит от того, как они шардированы. Наша цель состоит в том, чтобы самые важные и часто встречающиеся запросы затрагивали как можно меньше секций. В этом плане очень важно выбрать ключ (или ключи) секционирования данных. Ключ шардирования определяет, в какую секцию попадает та или иная строка. Если известен ключ шардирования некоторого объекта, то можно ответить на два вопроса:</p>
<ul>
<li>Где следует сохранить данные?</li>
<li>Где найти запрошенные данные?</li>
</ul>
<p>Запросы к нескольким шарданм хуже, чем к одному, но если они затрагивают не слишком много шардов, то все еще не так плохо. Самый худший случай – когда у вас нет ни малейшего представления о том, где находятся данные, и приходится просматривать все шарды без исключения.</p>
<h4 id="Выбор-ключа-шардирования"><a class="header" href="#Выбор-ключа-шардирования">Выбор ключа шардирования</a></h4>
<p>Обычно хорошим ключом секционирования является идентификатор какой-нибудь важной сущности в базе данных. Такие сущности называются единицами шардирвания (unit of sharding). Например, если
информация секционируется по идентификатору пользователя или клиента, то единицей секционирования является соответственно пользователь или клиент.</p>
<p>Если модель данных сложна, то и секционировать ее труднее. Во многих приложениях существует более одного ключа секционирования, особенно если в данных можно выделить несколько важных «измерений». Иными словами, приложение должно иметь возможность эффективно взглянуть на информацию под разными углами зрения и получить целостное представление. Это означает, что некоторые данные придется хранить в двух разных видах.</p>
<h3 id="Распределение-данных"><a class="header" href="#Распределение-данных">Распределение данных</a></h3>
<p>Существует два основных способа распределения данных по секциям: фиксированное и динамическое. Для обеих стратегий необходима функция секционирования, которая принимает на входе ключ секционирования строки и возвращает номер секции, в которой эта строка находится. Здесь слово «функция» употребляется в математическом смысле как отображение множества входных значений (области определения) во множество выходных значений (область значений), такую функцию можно реализовать разными способами, в том числе с использованием справочной таблицы в базе данных.</p>
<h5 id="Фиксированное-распределение"><a class="header" href="#Фиксированное-распределение">Фиксированное распределение</a></h5>
<p>Для фиксированного распределения применяется функция разбиения, которая зависит только от значения ключа секционирования. В качестве примеров можно привести деление по модулю или хеш-функции. Такие функции отображают значения ключей секционирования на конечное число «ячеек» (buckets), в которых хранятся данные.
Пусть имеется всего 100 ячеек и требуется найти, в какую из них поместить пользователя 111. С применением деления по модулю ответ ясен:остаток от деления 111 на 100 равен 11, поэтому пользователь должен находиться в секции 11.</p>
<p>Однако у этой стратегии есть и недостатки.</p>
<ul>
<li>Если секции велики и их немного, то балансировать нагрузку между ними будет сложно.</li>
<li>При фиксированном распределении вы лишены возможности решать, куда помещать конкретную запись, а это важно в приложениях, где нагрузка на единицы секционирования неравномерна. Некоторые части данных используются гораздо чаще, чем остальные, и когда такие обращения по большей части адресуются к одной и той же секции, стратегия фиксированного распределения не позволяет снять нагрузку, переместив часть данных в другую секцию. Эта проблема не так серьезна, если элементы данных малы, но их количество в каждой секции велико; закон больших чисел все расставит по своим местам.</li>
<li>Как правило, изменить алгоритм секционирования сложнее, потому что требуется перераспределить все существующие данные. Например, если секционирование производилось делением по модулю 10, то имеется 10 секций. Когда приложение вырастет, и секции станут слишком большими, возникнет желание увеличить их количество до 20. Но для этого придется перехешировать все заново, обновить очень много данных и перераспределить их по новым секциям.</li>
</ul>
<h5 id="Динамическое-распределение"><a class="header" href="#Динамическое-распределение">Динамическое распределение</a></h5>
<p>Альтернативой фиксированному распределению является динамическое распределение, описание которого хранится отдельно в виде отображения единицы секционирования на номер секции. Примером может служить таблица с двумя столбцами: идентификатор пользователя и идентификатор секции:</p>
<pre><code class="language-sql">CREATE TABLE user_to_shard (
  user_id INT NOT NULL,
  shard_id INT NOT NULL,
  PRIMARY KEY (user_id)
);
</code></pre>
<p>Функцией разбиения служит сама таблица. Зная ключ секционирования (идентификатор пользователя), можно найти соответствующий номер секции. Если подходящей строки не существует, можно выбрать нужную секцию и добавить строку в таб лицу. Впоследствии сопоставление можно будет изменить, потому стратегия и называется динамической.</p>
<p>Table functions – это когда у вас просто какой-то config. Использование подходов Table functions к шардингу очень тесно завязано на таком понятии как virtual bucket. Вспомните, у вас есть функция отображения ключа на шард. Представьте себе, что у вас посередине появляется некое промежуточное отображение, т.е. это отображение превращается в два. Сначала вы отображаете ключ на некоторый виртуальный bucket, потом виртуальный bucket – на соответствующую координату в пространстве вашего кластера.</p>
<p>Существует не очень много методов это все сделать. А еще мы помним о том, что самое главное – это дать свободу и удобство работы системному администратору. Виртуальные bucket-ы, как правило, выбираются в достаточно большом количестве. Почему они виртуальные? Потому что на самом деле они не отражают реального физического сервера. И используется несколько методов для отображения непосредственно ключа на шард.</p>
<p>Один метод – это когда первая часть «key to bucket» function – это просто какой-то хэш или консистентный хэш, т.е. какая-то часть, которая определяется по формуле, а bucket непосредственно на шард отображается через config. Вторая вещь более сложная – когда вы и то и то отображаете через config. Более сложная, потому что вам, условно говоря, для каждого ключа нужно еще помнить, где он лежит. Вы приобретаете возможность передвинуть любой ключ куда угодно, но с другой стороны вы теряете возможность легко и быстро, имея просто маленький config в «bucket to shard», из ключа определить bucket и потом пойти достаточно быстро пойти в нужное место.</p>
<p>С динамическим распределением связаны определенные накладные расходы, так как требуется обращение к внешнему ресурсу, например серверу каталогов (узлу, на котором хранится отображение). Для поддержания приемлемой эффективности такая архитектура часто нуждается в дополнительных слоях программного обеспечения. Например, можно использовать распределенную сис тему кэширования, в памяти
которой хранятся данные с сервера каталогов, которые на практике изменяются довольно редко.
Основное достоинство динамического распределения – более точное управление местом хранения данных. Это упрощает равномерное разделение данных по секциям и позволяет гибко адаптироваться к непредвиденным изменениям.</p>
<p>Кроме того, динамическое распределение дает возможность выстраивать многоуровневую стратегию шардировани поверх простого отображения ключей на секции. Например, можно организовать двойное отображение, при котором каждой единице секционирования сопоставляется некоторая группа (например, группа членов клуба книголюбов), а сами группы по возможности размещаются в одной секции. Это позволяет воспользоваться преимуществами близости шардов и избегать межсекционных запросов. Динамическое распределение дает возможность создавать несбалансированные секции. Это полезно, когда не все сервера одинаково мощные или когда некоторые серверы используются еще и для других целей, например для архивирования данных. Если при этом имеется еще и возможность в любой момент перебалансировать шарды, то можно поддерживать взаимно-однозначное соответствие между секциями и узлами, не растрачивая впустую емкость дисков. Некоторым нравится та простота, которая свойственна хранению в каждом узле ровно одной сек
ции (но не забывайте, что имеет смысл делать шарды относительно небольшими). Динамическое распределение позволяет организовать стратегию секционирования любой сложности, фиксированное такого богатства выбора не предоставляет.</p>
<h5 id="Комбинирование-динамического-и-фиксированного-распределений"><a class="header" href="#Комбинирование-динамического-и-фиксированного-распределений">Комбинирование динамического и фиксированного распределений</a></h5>
<p>Можно также применять комбинацию динамического и фиксированного распределения. Это часто бывает полезно, а иногда даже необходимо. Динамическое распределение хорошо работает, когда отображение
не слишком велико. С ростом количества единиц секционирования его эффективность падает.</p>
<p>В качестве примера рассмотрим сис тему, в которой хранятся ссылки между сайтами. В ней необходимо хранить десятки миллиардов строк, а ключом секционирования является комбинация исходного и конечного URL. На любой из двух URL могут быть сотни миллионов ссылок, поэтому ни один URL по отдельности не является достаточно избирательным. Однако невозможно хранить все комбинации исходного и конечного URL в таб лице сопоставления, поскольку их слишком много, а каждый URL занимает много места.</p>
<p>Одно из возможных решений – конкатенировать URL и написать хеш-функцию, отображающую получившиеся строки на фиксированное число ячеек, которые затем можно динамически отображать на шарды. Если количество ячеек достаточно велико, скажем, миллион, то в каждый шард их можно поместить довольно много. В результате мы получаем многие преимущества динамического секционирования, не заводя гигантскую таблицу отображения.</p>
<h4 id="Поиск-данных"><a class="header" href="#Поиск-данных">Поиск данных</a></h4>
<p>Самых распространенных метода – три:</p>
<ul>
<li><strong>Умный клиент</strong> </li>
</ul>
<p>Представьте себе, что у вас есть табличная функция, которая использует маппинг ключа на bucket. Используется какой-то хэш, какая-то формула. Затем у вас есть некоторый config, который состоит из всего лишь небольшого количества данных, например, 1000 маппингов, 1000 строк, 1000 соответствий ключ-значение. В результате это все где-то зашито в вашем клиенте. Ваш клиент получил ключ, сразу определил, на какой сервер идти, и сразу пошел на этот сервер.</p>
<p>В принципе, хороший метод, самый простой и самый клевый. За одним исключением – в случае, если у вас разрастается инфраструктура, и вам в какой-то момент нужно задевелопить кучу других каких-то клиентов, на других языках, для других приложений, то вам нужно повторить эту логику – это во-первых. Во-вторых, если вам нужно сделать каким-то образом решардинг, и сделать это с нулевым maintenance subwindow, то это сделать довольно сложно, потому что вся логика – в процессах приложений, которые сейчас работают. Каким-то образом вам надо сигнализировать, что что-то сейчас будет меняться, карта такая-то будет становиться другой и т.д. Все это, в общем, достаточно сложно.</p>
<ul>
<li><strong>Прокси</strong></li>
</ul>
<p>Представьте себе, что прокси делает следующее: он принимает запрос, как будто к одной ноде, вернее, как будто к одному приложению, и клиент просто не знает о том, что на самом деле за этим прокси есть много нод.</p>
<p>Какая-то логика применяется внутри прокси, он определяет, на какую ноду идти, делает запрос, получает данные, потом передает эти данные назад клиенту. Это очень удобно, хотя бы потому, что ничего специально учить не надо, разговаривать можно как с одной базой, как мы привыкли, и если у нас есть какие-то клиентские приложения, которые уже написаны, нам их переписывать не надо.</p>
<p>Жирные стрелочки на этом слайде указывают, где потекли данные. Например, видно, что жирные данные текут уже в два места. Одно место – это между прокси и, собственно, нодой данных. Другое место – это между прокси и клиентом. Для больших производительных систем это является неким дополнительным условием, которое надо иметь в виду – удвоение трафика внутри площадки.</p>
<p>Прокси перегружается. Вы увеличиваете их количество. Прокси выходят из строя, у вас появляется еще одна точка отказа. Решение неидеальное, но какой еще потенциальный профит у этого решения? Вы в прокси можете также заниматься load balancing-ом, вы можете смотреть, какие ноды у вас вышли из строя, т.е. автоматически определять, делать failover полностью прозрачным для прокси. Т.е. прокси позволяет сделать логику приложения очень простой.</p>
<p>Есть некий способ упростить всю эту технологию, если сделать так, чтобы прокси работала на том же хосте, на котором работает само приложение. Проблема прокси – вы должны распространять состояние шардинга, т.е. прокси должны знать, где какой ключ находится. И тут мы приходим к следующей технологии, которая упрощает именно эту историю – технологии вынесения этого состояния в единое место – в координатор.</p>
<ul>
<li><strong>Координатор</strong></li>
</ul>
<p>Координатор – это вещь, похожая на предыдущие (т.е. клиент, по- прежнему, ничего не знает), но совершенно другая. Координатор – это просто такой классный парень, который очень быстро отвечает на простые вопросы «Куда мне идти?». Получает маленькую порцию вопросов, т.е. длина вопроса небольшая, быстро дает ответ, после этого клиент сам устанавливает соединение и идет на нужную дата-ноду. Здесь преимущество заключается в том, что у вас убирается сложность прокси.</p>
<p>Эта архитектура обладает определенными проблемами. Если координатор вдруг упадет, то все пропало. Но с другой стороны, координатор – вещь крайне простая и ее очень легко резервировать через асинхронный мастер-мастер, даже мастер-слэйв.</p>
<h4 id="Перераспределине-данныхрешардинг"><a class="header" href="#Перераспределине-данныхрешардинг">Перераспределине данных(решардинг)</a></h4>
<p>При необходимости можно переместить данные из одной секции в другую, чтобы сбалансировать нагрузку. Например, многие читатели, намверное, слышали, как разработчики больших сайтов фотогалерей или
популярных социальных сетей рассказывали о своих инструментах перемещения пользователей в другие секции. Способность перемещать данные открывает целый ряд возможностей. Например, чтобы модернизировать оборудование, можно перенести всех пользователей из старой секции в новую, не останавливая секцию целиком и не переводя ее в режим чтения.</p>
<p>Однако мы стараемся по возможности избегать перебалансирования, так как это может вызвать приостановку обслуживания. Из-за перемещения данных становится сложнее добавлять в приложение новые функции, поскольку их приходится учитывать в сценариях перебалансирования. Если секции не слишком велики, то прибегать к этому, возможно, и не понадобится; часто для балансирования нагрузки достаточно перенести секцию целиком, а это гораздо проще, чем перемещать часть секции (и более эффективно, если говорить о стоимости в расчете на одну строку данных).</p>
<p>Один из подходов – «update is a move». Идея следующая – всегда, когда вы меняете кокой-то ключ, вы его неявно двигаете. Допустим, у вас ключ шардинга – это, собственно, ключ шардинга и timestamp. Когда вы меняете данные, вы меняете timestamp, и он у вас естественным образом оказывается на другом шарде. Вы можете в какой-то момент закрыть апдейты на определенный шард и рано или поздно просто его вывести из строя. Т.е. очень просто передвигать данные, очень просто выводить данные из строя.</p>
<p>Второй подход – «data expiration». В нем просто добавили несколько серверов, явно не решардили, данные естественным образом заэкспайрились – получилась новая схема шардинга. Этот же подход можно использовать где угодно, где вы можете старые данные просто удалять. Тогда вы новые данные льете на новые ноды или закрываете какие-то старые ноды. Данные сами собой просто постепенно переезжают.</p>
<p>Здесь ключевым моментом являются части – горячая и холодная. Автоматически появляются на вашем кластере горячая и холодная части, и может оказаться, что если вы неправильно подобрали какие-то конфигурации или веса, то горячая часть будет очень маленькой, и число серверов, которые вам нужно постоянно добавлять для того, чтобы поддерживать горячую часть (например, если это на twitter или выборы Обамы)...</p>
<h3 id="Консистентный-хэш"><a class="header" href="#Консистентный-хэш">Консистентный хэш</a></h3>
<p>Способ создания распределенных хеш-таблиц, при котором вывод из строя одного или более серверов-хранилищ не приводит к необходимости полного переразмещения всех хранимых ключей и значений. Консистентное хеширование позволяет перераспределять только те ключи, которые использовались удаленным сервером или которые будут использоваться новым сервером. Таким образом, в случае выхода из строя одного узла, ключи не просто переходят на следующую ноду, а равномерно распределяются по нескольким следующим нодам.</p>
<p>Идея простая, возьмем окружность и будем рассматривать ее как интервал на котором определена хеш-функция функция. Применив хеш-функцию к набору ключей (синие точки) и серверов (зеленые точки) сможем разместить их на окружности. Для того чтобы определить на каком сервере размещен ключ, найдем ключ на окружности и будем двигаться по часовой стрелке до ближайшего сервера. Теперь в случае падения (недоступности) сервера, загрузить на новые сервер необходимо только недоступные данные. Все остальные хеши не меняют свое местоположение, то есть консистентны. При добавлении нового сервера соседний разделяет с ним часть своих данных.</p>
<p><img src="http://dyagilev.org/images/consistent-hashing/consistent_hashing11.png" alt="img" /></p>
<p>На практике также применяют следующий трюк. Сервер можно пометить на окружности не одной точкой, а несколькими. Что это дает ? - более равномерное распределение данных по серверам - при падении сервера данные распределяются не на один соседний, а на несколько, распределяя тем самым нагрузку - при добавлении нового сервера, точки можно делать ‘активными’ постепенно одна за другой, предотвращая шквальную нагрузку на сервер - если конфигурация серверов отличается, например размером диска, количество данных можно контролировать числом его точек. Больше точек - большая длина окружности принадлежит этому серверу и соответственно больше данных.</p>
<p><img src="http://dyagilev.org/images/consistent-hashing/consistent_hashing4.png" alt="img" /></p>
<p>Для реализации храним хеши серверов в виде какого-либо дерева, например Red-Black. Операция поиска сервера по ключу будет занимать <code>O(log n)</code>.</p>
<p><em><strong>Дополнительно:</strong></em></p>
<ul>
<li>http://dyagilev.org/blog/2012/03/23/consistent-hashing/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Распределенные-системы-Разное"><a class="header" href="#Распределенные-системы-Разное">Распределенные системы. Разное</a></h1>
<h2 id="2-phase-commit"><a class="header" href="#2-phase-commit">2 Phase Commit</a></h2>
<p><strong>Алгоритм двухфазного коммита</strong> — классический централизованный оптимистичный алгоритм распределённого консенсуса из баз данных для подтверждения распределённых транзакций.</p>
<p>После того как мы завершили транзакцию, её надо атомарно подтвердить на всех участниках (participants). У каждой транзакции есть выделенный координатор (transaction coordinator). Алгоритм работает в две фазы:</p>
<ol>
<li><strong>Запрос (request)</strong>: координатор спрашивает каждого участника: &quot;готов ли ты <em>очень быстро и гарантированно</em> завершить транзакцию?&quot;. Если кто-нибудь ответил &quot;нет&quot;, то отменяем транзакцию. Если кто-то отвечает &quot;да&quot;, то он должен уметь обеспечить завершение транзакции даже если упадёт и поднимается (например, все данные уже в журнале).</li>
<li><strong>Завершение</strong>: координатор принимает решение о закреплении (commit) или отмене (rollback) транзакции и записывает его в свою надёжную память, после чего рассылает всем решение. После рассылки можно сообщить о фиксации транзакции, подтверждения от участников ждать не нужно (но тогда может быть проблема с тем, что следующие чтения из СУБД будут возвращать старые данные, пока не закоммитили).</li>
</ol>
<p>При этом проблемы двух генералов на практике обычно нет: после того, как координатор принял решение о транзакции, он будет его доносить до всех любопытствующих узлов.</p>
<p>Всего на коммит требуется 3N сообщений (NN — количество участников транзакции) и задержка порядка 3⋅RTT (round-trip time).</p>
<p>Так как это алгоритм консенсуса, к нему применима <a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%B8%D1%88%D0%B5%D1%80%D0%B0-%D0%9B%D0%B8%D0%BD%D1%87%D0%B0-%D0%9F%D0%B0%D1%82%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0_(FLP)">FLP</a>. Если у нас есть отказы узлов или связи, то 2PC будет ждать, пока связь не восстановится:</p>
<ul>
<li>Если отказ произошёл на первой фазе, то координатор может отменить транзакцию по таймауту.</li>
<li>После того как координатор перешёл на вторую фазу, он не имеет права успокоиться, пока не донесёт своё решение до всех узлов.</li>
<li>Если узел отказал, а потом восстановился, то он спрашивает координатора, какое решение было принято. Если &quot;да&quot;, то обязан закрепить транзакцию (т.е. координатор должен хранить все подтверждённые транзакции, которые подтвердили не все узлы).</li>
<li>Если отказал координатор, то, если узел ответил &quot;да&quot;, он не имеет права забить на транзакцию, пока координатор не восстановится.</li>
</ul>
<p>Но алгоритм классический, простой, на практике неплохо работает, потому что сложно только с отказами координатора и отказами узлов на второй фазе (когда решение о коммите уже принято), а такое бывает не так часто.</p>
<h2 id="eventual-consistency"><a class="header" href="#eventual-consistency">Eventual Consistency</a></h2>
<p><strong>Согласованность в конечном счёте</strong> (eventual consistency) — одна из моделей согласованности, используемая в распределённых системах для достижения высокой доступности, в рамках которой гарантируется, что в отсутствии изменений данных, через какой-то промежуток времени после последнего обновления («в конечном счёте») все запросы будут возвращать последнее обновлённое значение.</p>
<p>Пример консистентной в конечном счёте системы — DNS: обновлённая DNS-запись распространяется по серверам в соответствии с настройками интервалов кэширования и, хоть и не моментально, но в конечном счёте все клиенты увидят обновление.</p>
<h2 id="Теорема-cap"><a class="header" href="#Теорема-cap">Теорема CAP</a></h2>
<p><strong>Теорема САР</strong> (теорема Брюера) — эвристическое утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:</p>
<ul>
<li><strong>Сonsistency</strong>(согласованность) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу. При обращении к системе, которая обеспечивает консистентность, вы не получите ответа(получите ошибку), если не будет гарантии, что данные с запрашиваемого узла, совпадают с остальными.</li>
<li><strong>Availability</strong>(доступность)— любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают. То есть система обязательно вернет какие-то данные, но не факт что они будут актуальными.</li>
<li><strong>Partition Tolerance (Устойчивость к разделению системы).</strong> Потеря сообщений между компонентами системы (возможно даже потеря всех сообщений) не влияет на работоспособность системы. Здесь очень важный момент состоит в том, что если какие-то компоненты выходят из строя, то это тоже подпадает под этот случай, так как можно считать, что данные компоненты просто теряют связь со всей остальной системой.</li>
</ul>
<p>В теореме говорится, что если вы строите распределенную систему, то можете удовлетворить только два из вышеупомянутых свойства, т.е. обязательно надо пожертвовать одним из свойств. Главный вопрос, который вызывает недопонимание — это что значит пожертвовать Partition Tolerance.</p>
<p>Не требовать partition tolerance для распределённой системы означает работу в сети, гарантирующей никогда не терять (или даже задерживать) сообщения, и чьи узлы гарантированно никогда не падают. Вы и я не работаем с такими системами, потому что их не существует.</p>
<p>Другими словами, требование partition tolerance для распределённой системы — это не выбор инженера, а просто практическая данность, и выбирать остаётся только между consistency и availability. Даже если инженер упрямо решит построить систему с расчётом на 100% надёжность сети, то при следующем сбое она либо потеряет данные и станет неконсистентной, или не сможет вернуть ответ на запрос, и будет недоступной.</p>
<p>Еще другими словами: Если у вас есть место куда вы пишите и читаете, то в случае сетевого сбоя, вам нужно выбрать либо вы продолжаете читать и писать(availibility) либо вам нужны консистентные данные.</p>
<p>Таким образом, так как нельзя пожертвовать Partition Tolerance, для себя я формулирую CAP теорему следующим образом. При построении распределенной системы, которая могла бы пережить отказ некоторых из ее компонент необходимо пожертвовать либо доступностью (avalability), либо согласованностью (consistency).</p>
<p>Соответственно, если система называет себя CP (т.е. consistency и partition tolerance), то при разрыве (если у нас есть кластер, и он разнесен, например, по двум дата-центрам, и связь рвется между дата-центрами) как ведет себя консистентная система? Она, если мы обращаемся на узел, и узел видит, что он не может надежно обеспечить эту запись, что у него нет, например, связи с большинством узлов системы, то он просто откажет приложению в этой записи, и она не удастся. Когда потом связь восстановится, приложение может попробовать снова и у него может получиться.</p>
<p>А если система называет себя AP, то она будет всеми силами стараться удовлетворить запросы приложения путем отдачи ему устаревших данных, она может принять себе запрос на запись и куда-то ее себе записать, чтобы потом выполнить на всем кластере. Здесь есть нюансы. Например, если у нас разделился кластер надвое, и мы пишем в обе части, то есть шанс, что мы получим конфликты, т.е. мы в одной части записали в один ключ одни данные, а в другом – другие, а когда связь восстанавливается, то возникает проблема – какая версия данных корректная?</p>
<h2 id="mapreduce"><a class="header" href="#mapreduce">MapReduce</a></h2>
<p>MapReduce — модель распределённых вычислений, представленная компанией Google, используемая для параллельных вычислений над очень большими, вплоть до нескольких петабайт, наборами данных в компьютерных кластерах.</p>
<p>Работа MapReduce состоит из двух шагов: Map и Reduce, названных так по аналогии с одноименными функциями высшего порядка, map и reduce. На Map-шаге происходит предварительная обработка входных данных. Для этого один из компьютеров (называемый главным узлом — master node) получает входные данные задачи, разделяет их на части и передает другим компьютерам (рабочим узлам — worker node) для предварительной обработки. На Reduce-шаге происходит свёртка предварительно обработанных данных. Главный узел получает ответы от рабочих узлов и на их основе формирует результат — решение задачи, которая изначально формулировалась.</p>
<p>Преимущество MapReduce заключается в том, что он позволяет распределенно производить операции предварительной обработки и свертки. Операции предварительной обработки работают независимо друг от друга и могут производиться параллельно (хотя на практике это ограничено источником входных данных и/или количеством используемых процессоров). Аналогично, множество рабочих узлов может осуществлять свертку — для этого необходимо только чтобы все результаты предварительной обработки с одним конкретным значением ключа обрабатывались одним рабочим узлом в один момент времени. Хотя этот процесс может быть менее эффективным по сравнению с более последовательными алгоритмами, MapReduce может быть применен к большим объёмам данных, которые могут обрабатываться большим количеством серверов. Так, MapReduce может быть использован для сортировки петабайта данных, что займет всего лишь несколько часов. Параллелизм также дает некоторые возможности восстановления после частичных сбоев серверов: если в рабочем узле, производящем операцию предварительной обработки или свертки, возникает сбой, то его работа может быть передана другому рабочему узлу (при условии, что входные данные для проводимой операции доступны).</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/post/434496/">Двухфазный коммит и будущее распределённых систем</a></li>
<li><a href="http://softwaremaniacs.org/blog/2012/01/16/partition-tolerance/">Partition tolerance</a></li>
<li><a href="https://habr.com/ru/post/100891/">Согласованные в конечном счете (Eventually Consistent)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Конкретные-БД"><a class="header" href="#Конкретные-БД">Конкретные БД</a></h1>
<p>В данном разделе содержится информация относящаяся к конкретным реализациям различных СУБД.</p>
<ul>
<li><a href="db/specific/mysql/README.MD">MySql</a>
<ul>
<li><a href="db/specific/mysql/architecture.html">Архитектура MySql</a></li>
<li><a href="db/specific/mysql/concurency.html">Конкурентный доступ</a></li>
<li><a href="db/specific/mysql/indexes.html">Индексы</a></li>
<li><a href="db/specific/mysql/sql.html">Основы SQL</a>
<ul>
<li><a href="db/specific/mysql/explain.html">Explain</a></li>
<li><a href="db/specific/mysql/unsorted.html">Разное</a></li>
</ul>
</li>
<li><a href="db/specific/postgreSql/README.html">PostgreSql</a></li>
<li><a href="db/specific/noSql/README.html">NoSql</a>
<ul>
<li><a href="db/specific/noSql/memcached.html">Memcaced</a> </li>
<li><a href="db/specific/noSql/redis.html">Redis</a> </li>
<li><a href="db/specific/noSql/tarantool.html">Tarantool</a></li>
<li><a href="db/specific/noSql/mongo.html">Mongo</a> </li>
</ul>
</li>
<li><a href="db/specific/clickhouse.html">ClickHouse</a> </li>
<li><a href="db/specific/messages/README.html">Брокеры сообщений</a>
<ul>
<li><a href="db/specific/messages/rabbit.html">Rabbit</a> </li>
<li><a href="db/specific/messages/kafka.html">Kafka</a> </li>
<li><a href="db/specific/messages/nats.html">Nats</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">MySql</a></h1>
<ul>
<li><a href="db/specific/mysql/architecture.html">Архитектура MySql</a></li>
<li><a href="db/specific/mysql/concurency.html">Конкурентный доступ</a></li>
<li><a href="db/specific/mysql/dataTypes.html">Типы данных</a></li>
<li><a href="db/specific/mysql/indexes.html">Индексы</a></li>
<li><a href="db/specific/mysql/queryOptimization.html">Оптимизация запросов</a></li>
<li><a href="db/specific/mysql/sql.html">Основы SQL</a></li>
<li><a href="db/specific/mysql/explain.html">Explain</a></li>
<li><a href="db/specific/mysql/unsorted.html">Разное</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Логическая-архитектура-mysql"><a class="header" href="#Логическая-архитектура-mysql">Логическая архитектура Mysql</a></h2>
<p><img src="db/specific/mysql/../../../media/mySqlArchitecture.png" alt="Архитектура Mysql" /></p>
<p>На самом верхнем уровне содержатся службы, которые не являются уникальными для MySQL. Эти службы необходимы большинству сетевых клиент-серверных инструментов и серверов: они обеспечивают
поддержку соединений, идентификацию, безопасность и т. п.</p>
<p>Второй уровень представляет гораздо больший интерес. Здесь сосредоточена значительная часть интеллекта MySQL: синтаксический анализ запросов, оптимизация, кэширование и все встроенные функции (например, функции работы с датами и временем, математические функции, шифрование). На этом уровне реализуется любая независимая от подсистемы хранения данных функциональность, например хранимые
процедуры, триггеры и представления.</p>
<p>Третий уровень содержит подсистемы хранения данных. Они отвечают за сохранение и извлечение всех данных, хранимых в MySQL. Подобно различным файловым системам GNU/Linux, каждая подсистема хранения данных имеет свои сильные и слабые стороны. Сервер взаимодействует с ними с помощью API подсистемы хранения данных. Этот интерфейс скрывает различия между подсистемами хранения данных и делает их почти прозрачными на уровне запросов. Кроме того, данный интерфейс содержит пару десятков низкоуровневых функций, выполняющих операции типа «начать транзакцию» или «извлечь строку с таким первичным ключом». Подсистемы хранения не производят синтаксический анализ кода SQL и не взаимодействуют друг с другом, они просто отвечают на исходящие от сервера запросы.</p>
<h2 id="Управление-соединениями-и-безопасность"><a class="header" href="#Управление-соединениями-и-безопасность">Управление соединениями и безопасность</a></h2>
<p>Для каждого клиентского соединения выделяется отдельный поток внутри процесса сервера. Запросы по данному соединению исполняются в пределах этого потока, который, в свою очередь, выполняется одним ядром или процессором. Сервер кэширует потоки, так что их не нужно создавать или уничтожать для каждого нового соединения. Когда клиенты (приложения) подключаются к серверу MySQL, сервер должен их идентифицировать. Идентификация основывается на имени пользователя, адресе хоста, с которого происходит соединение, и пароле. Также можно использовать сертификаты X.509 при соединении по протоколу Secure Sockets Layer (SSL). После того как клиент подключился, для каждого запроса сервер проверяет наличие необходимых привилегий (например, разрешено ли клиенту использовать команду SELECT применительно к таблице Country базы данных world). </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Управление-конкурентным-доступом"><a class="header" href="#Управление-конкурентным-доступом">Управление конкурентным доступом</a></h1>
<h2 id="Блокировки"><a class="header" href="#Блокировки">Блокировки</a></h2>
<p>Есть два базовых типа блокировок:</p>
<ul>
<li><strong>shared lock</strong> — совместная блокировка, блокировка на чтение - позволяет другим транзакциям читать строку и ставить на нее такую же совместную блокировку, но не позволяет изменять строку или ставить исключительную блокировку.</li>
<li><strong>exclusive lock</strong> — исключительная блокировка, блокировка на запись - запрещает другим транзакциям блокировать строку, а также может блокировать строку как на запись, так и на чтение в зависимости от текущего уровня изоляции.</li>
</ul>
<p>Также блокировки можно поделить по детальности:</p>
<ul>
<li><strong>Табличная блокировка</strong> - блокирует всю таблицу. Когда клиент хочет выполнить запись в таблицу
(вставку, удаление, обновление и т. п.), он захватывает блокировку на запись для всей таблицы. Такая блокировка предотвращает все остальные операции чтения и записи. В тот момент, когда никто не производит запись, любой клиент может получить блокировку на чтение и она не будет конфликтовать с другими аналогичными блокировками.</li>
<li><strong>Построчная блокировка</strong> - Блокировки строк реализуются подсистемами хранения данных, а не
сервером (взгляните на иллюстрацию логической архитектуры). Сервер ничего не знает о блокировках, реализованных подсистемой хранения данных.</li>
</ul>
<h3 id="Явные-и-неявные-блокировки"><a class="header" href="#Явные-и-неявные-блокировки">Явные и неявные блокировки</a></h3>
<p>В подсистеме InnoDB используется двухфазный протокол блокировки. Она может устанавливать блокировки в любой момент времени на протяжении всей транзакции, но не снимает их до выполнения команды
COMMIT или ROLLBACK. Все блокировки снимаются одновременно. Описанные ранее механизмы блокировки являются неявными. InnoDB обрабатывает блокировки автоматически в соответствии с уровнем изоляции.
Однако InnoDB поддерживает и явную блокировку, которая в стандарте SQL вообще не упоминается:</p>
<p><strong>SELECT… LOCK IN SHARE MODE</strong> — блокирует считываемые строки на запись.
Другие сессии могут читать, но ждут окончания транзакции для изменения затронутых строк. Если же в момент такого SELECT'а строка уже изменена другой транзакцией, но еще не зафиксирована, то запрос ждет окончания транзакции и затем читает свежие данные. Данная конструкция нужна, как правило, для того чтобы получить свежайшие данные (независимо от времени жизни транзакции) и заодно убедиться в том, что их никто не изменит. </p>
<p><strong>SELECT… FOR UPDATE</strong> — блокирует считываемые строки на чтение. Точно такую же блокировку ставит обычный UPDATE, когда считывает данные для обновления.</p>
<p>MySQL также поддерживает команды LOCK TABLES и UNLOCK TABLES, которые реализуются сервером, а не подсистемой хранения. У них есть свое применение, но они не являются заменой транзакциям. Если вам нужны транзакции, используйте транзакционную подсистему хранения.</p>
<p>Существует еще 2 типа блокировок, назовем их блокировками «о намерениях». Нельзя просто так взять и заблокировать запись в InnoDB. Блокировки <strong>intention shared</strong> и <strong>intention exclusive</strong> являются блокировками на уровне таблицы и блокируют только создание других блокировок и операции на всей таблице типа LOCK TABLE. Наложение такой блокировки транзакцией лишь сообщает о намерении данной транзакции получить соответствующую совместную или исключительную блокировку строки. </p>
<p>InnoDB накладывает блокировки не на сами строки с данными, а на записи индексов. Они бывают следующих типов:</p>
<h3 id="record-lock"><a class="header" href="#record-lock">Record Lock</a></h3>
<p><strong>Блокировка индексной записи</strong> - такая блокировка происходит, если условие запроса ограничивает только одну запись уникального индекса (<a href="http://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_unique_index">unique index</a>); например, если в таблице <code>t</code> поле <code>c1</code> является уникальным индексом и существует запись для которой <code>с1 = 10</code>, то при выполнении блокирующего чтения <strong><code>SELECT * FROM t WHERE c1 = 10 FOR UPDATE</code></strong> InnoDB установит блокировку на этот индекс и не допустит чтобы другая транзакция вставила, обновила или удалила строку с полем <strong><code>с1 = 10</code></strong> если выполнить тот же запрос, но записи с полем <strong><code>с1 = 10</code></strong> (а соответственно и записи индекса) не будет существовать, то это уже будет блокировка интервала</p>
<h3 id="gap-lock"><a class="header" href="#gap-lock">Gap Lock</a></h3>
<p><strong>Блокировка интервала</strong> - происходит, когда блокируется интервал между индексными записями, интервал до первой индексной записи или интервал после последней индексной записи; допустим что в таблице есть две строки для которых <strong><code>с1 = 10</code></strong> и <strong><code>c1 = 20</code></strong>, т.е. индекс содержит значения 10 и 20. интервалами будут являться следующие отрезки: <strong>(минус бесконечность, 10), (10, 20), (20, плюс бесконечность</strong>); если мы выполним запрос на блокирующее чтение несуществующей пока записи <strong><code>SELECT * FROM t WHERE c1 = 15 FOR UPDATE</code></strong>, то будет блокирован <strong>интервал от 10 до 20, но не включительно</strong>, т.е. обновить граничные записи можно, можно даже их удалить, а вот вставка новой строки в этот интервал будет блокирована; еще один интересный пример: если выполнить предыдущий запрос на блокирующее чтение строки, но таблица <code>t</code> будет пуста, то заблокируется интервал, размером во все индексное пространство, т.е. вся таблица</p>
<h3 id="next-key-lock"><a class="header" href="#next-key-lock">Next Key Lock</a></h3>
<p><strong>Блокировка следующего ключа</strong> - комбинация блокировок индексных записей и блокировок интервалов; возьмем предыдущий пример, но выполним другой запрос: <strong><code>SELECT * FROM t WHERE c1 &gt; 15</code></strong> в данном случае помимо <strong>индекса со значением 20 заблокируются также интервалы (10, 20) и (20, плюс бесконечность)</strong>. При этом строку с индексом 10 можно изменять, т.к. она не блокируется; в общем случае блокируемых индексных интервалов и индексных записей может быть гораздо больше, все зависит от условий блокирующего запроса</p>
<p>В момент первого запроса в транзакции создается снэпшот данных БД (т.н. <strong>read view</strong>), на который не влияют изменения в параллельных транзакциях, но влияют изменения в текущей. Чтение из такого снэпшота называют <strong>неблокирующим согласованным чтением</strong>. <strong>Неблокирующим</strong> — потому что для создания такого снэпшота не требуется навешивание блокировок, согласованным — потому что никакие катаклизмы во внешнем мире (кроме DROP TABLE и ALTER TABLE) не повлияют на уютный мирок снэпшота. InnoDB можно попросить сделать снэпшот и до первого запроса в транзакции, для этого нужно упомянуть об этом во время старта транзакции — <strong>START TRANSACTION WITH CONSISTENT SNAPSHOT</strong>. </p>
<h2 id="deadlock"><a class="header" href="#deadlock">DeadLock</a></h2>
<p>Deadlock(взаимоблокировка) -  ситуация, где транзакции не способны продолжить работу потому, заблокировали ресурсы, нужные друг другу. Происходит, когда две или более транзакции запрашивают блокировку одних и тех же ресурсов, в результате чего образуется циклическая зависимость. Они также возникают в случае, если +транзакции пытаются заблокировать ресурсы в разном порядке. </p>
<p>Для разрешения этой проблемы в системах баз данных реализованы различные формы обнаружения взаимоблокировок и тайм-аутов. InnoDB, обнаруживают циклические зависимости и немедленно возвращают ошибку. На самом деле это очень хорошо, иначе взаимоблокировки проявлялись бы как очень медленные запросы. Другие системы в подобных ситуациях откатывают транзакцию по истечении тайм-аута, что не очень хорошо. При обнаружении дедлока, InnoDB автоматически откатывает транзакцию, с наименьшим числом эффектед(вставленных, удаленных или измененных) строк.</p>
<p>InnoDB использует автоматическую блокировку уровня строки. Вы можете создать взаимоблокировку даже в случае транзакций, которые всего лишь добавляют или удаляют единичную строку. Это происходит из-за того, что в действительности эти операции не являются &quot;атомарными&quot;: они автоматически устанавливают блокировку на индексные записи добавляемых/удаляемых строк (или на несколько записей).</p>
<p>Взаимоблокировку нельзя разрешить без отката одной из транзакций, частичного либо полного. Существование взаимоблокировок в транзакционных системах – непреложный факт, с учетом которого ваше приложение и нужно проектировать. При возникновении такой ситуации многие приложения могут просто попытаться выполнить транзакцию с самого начала.</p>
<p>Вы можете избежать взаимоблокировок или уменьшить их количество, следуя следующим приемам:</p>
<ul>
<li>Используйте <code>SHOW INNODB STATUS</code> в MySQL начиная с 3.23.52 и 4.0.3 для определения причины последней взаимоблокировки. Это поможет вам настроить ваше приложение, что бы избежать взаимоблокировок.</li>
<li>Всегда подготавливайте перезапуск транзакции, если произошел откат из-за взаимоблокировки. Взаимоблокировка не опасна: всего лишь попробуйте еще раз.</li>
<li>Чаще фиксируйте свои транзакии. Маленькие транзакции меньше склонны к противоречиям.</li>
<li>Если вы используете чтение с блокировкой <code>SELECT ... FOR UPDATE</code> или <code>... LOCK IN SHARE MODE</code>, попробуйте использовать более низкий уровень изоляции <code>READ COMMITTED</code>.</li>
<li>Производите операции с вашими таблицами и строками в фиксированном порядке. Тогда транзакции будут формировать очередь и не будет происходить взаимоблокировка.</li>
<li>Добавьте хорошие индексы на ваши таблицы. Тогда ваши запросы будут сканировать меньше индексных записей и, соответственно, будут устанавливать меньше блокировок. Используйте <code>EXPLAIN SELECT</code> для того, чтобы узнать, выбирает ли MySQL соответствующий индекс для ваших запросов.</li>
<li>Используйте меньше блокировок: если вы можете допустить, чтобы <code>SELECT</code> возвращал данные из старого снимка, не добавляйте к выражению <code>FOR UPDATE</code> или <code>LOCK IN SHARE MODE</code>. Используйте уровень изоляции <code>READ COMMITTED</code>, который больше всего подходит для данной ситуации, так как каждое согласованное чтение внутри одной и той же транзакции читает свой собственный свежий снимок.</li>
<li>Если ничего не помогло, сериализируйте свои транзакции с блокировкой уровня таблиц: <code>LOCK TABLES t1 WRITE, t2 READ, ... ; [здесь можете развлекаться с таблицами t1 и t2]; UNLOCK TABLES</code>. Блокировка на уровне таблиц выстраивает ваши транзакции в очередь, и позволяет избежать взаимоблокировки. Заметьте, что <code>LOCK TABLES</code> неявным образом начинает транзакцию наподобие <code>BEGIN</code>, и <code>UNLOCK TABLES</code> неявным образом завершает ее в <code>COMMIT</code>.</li>
<li>Другое решение для сериализации транзакций - это создание вспомогательного &quot;семафора&quot; таблицы, где есть всего лишь одна строка. Каждая транзакция обновляет эту строку перед доступом к другой таблице. В этом случае все транзакции выполняются в виде очереди. Отметим что таким же образом в настоящий момент работает и алгоритм определения взаимоблокировок в InnoDB, так как блокировка сериализации - это блокировка уровня строки. При блокировке на уровне таблицы в MySQL мы используем метод таймаута для разрешения взаимоблокировки.</li>
</ul>
<p>Динамическая взаимоблокировка (<strong>livelock</strong>) означает такую ситуацию: система не «застревает» (как в обычной взаимной блокировке), а занимается бесполезной работой, её состояние постоянно меняется — но, тем не менее, она «зациклилась», не производит никакой полезной работы.</p>
<p>Жизненный пример такой ситуации: двое встречаются лицом к лицу. Каждый из них пытается посторониться, но они не расходятся, а несколько секунд сдвигаются в одну и ту же сторону.</p>
<blockquote>
<p><strong>Livelock</strong>- это программы, которые активно выполняют параллельные операции, но эти операции никак не влияют на продвижение состояния программы вперед.</p>
</blockquote>
<p>Ситуация, в которой два или более процессов непрерывно изменяют свои состояния в ответ на изменения в других процессах без какой-либо полезной работы. Это похоже на deadlock, но разница в том, что процессы становятся “<em>вежливыми</em>” и позволяют другим делать свою работу.</p>
<p>Выполнение алгоритмов поиска удаления взаимных блокировок может привести к <strong>livelock</strong> — взаимная блокировка образуется, сбрасывается, снова образуется, снова сбрасывается и так далее.</p>
<p>Livelock — это подмножество более широкого набора проблем, называемых <strong>Starvation.</strong></p>
<blockquote>
<p><strong>Starvation</strong> — это любая ситуация, когда параллельный процесс не может получить все ресурсы, необходимые для выполнения его работы.</p>
</blockquote>
<h2 id="multiversion-concurrency-control-mvcc"><a class="header" href="#multiversion-concurrency-control-mvcc">Multiversion Concurrency Control (MVCC)</a></h2>
<p>Большая часть транзакционных подсистем хранения в MySQL, например InnoDB, используют не просто механизм блокировки строк, а блокировку строк в сочетании с методикой повышения степени конкурентности под названием <strong>MVCC</strong> (multiversion concurrency control – многоверсионное управление конкурентным доступом). MVCC позволяет во многих случаях вообще отказаться от блокировки и способна значительно снизить накладные расходы. В зависимости от способа реализации она может допускать чтение без блокировок, а блокировать лишь необходимые строки во время операций записи.</p>
<p>Принцип работы MVCC заключается в сохранении мгновенного снимка данных, какими они были в некоторый момент времени. Это означает, что вне зависимости от своей длительности транзакции могут видеть согласованное представление данных. Это также означает, что различные транзакции могут видеть разные данные в одних и тех же таблицах в одно и то же время! Если вы никогда не сталкивались с этим
раньше, то наверняка будете удивлены.</p>
<p>InnoDB реализует MVCC путем сохранения с каждой строкой двух дополнительных скрытых значений, в которых записано, когда строка была создана и когда срок ее хранения истек (или она была удалена). Вместо записи реальных значений момента времени, когда произошли указанные события, строка хранит системный номер версии для этого момента. Данное число увеличивается на единицу в начале каждой транзакции. Новая транзакция на момент ее начала хранит свою собственную запись текущей версии системы. Любой запрос должен сравнивать номера версий каждой строки с версией транзакции. Давайте посмотрим, как эта методика применяется к конкретным операциям, когда транзакция имеет уровень изоляции REPEATABLE READ:</p>
<p><strong>SELECT</strong> - Подсистема InnoDB должна проверить каждую строку, чтобы убедиться, что она отвечает двум критериям:</p>
<ul>
<li>
<p>InnoDB должна найти версию строки, которая по крайней мере такая же старая, как версия транзакции (то есть ее номер версии должен быть меньше или равен номеру версии транзакции). Это гарантирует, что-либо строка существовала до начала транзакции, либо транзакция создала или изменила эту строку.</p>
</li>
<li>
<p>Версия удаления строки должна быть не определена или ее значение больше, чем версия транзакции. Это гарантирует, что строка не была удалена до начала транзакции. Строки, которые проходят обе проверки, могут быть возвращены как результат запроса.</p>
<ul>
<li><strong>INSERT</strong> - InnoDB записывает текущий системный номер версии вместе с новой строкой.</li>
<li><strong>DELETE</strong> - InnoDB записывает текущий системный номер версии как идентификатор удаления строки.</li>
<li><strong>UPDATE</strong> - InnoDB создает новую копию строки, используя системный номер версии в качестве версии новой строки. Она также записывает системный номер версии как версию удаления старой строки. </li>
</ul>
</li>
</ul>
<p>Результатом хранения всех этих дополнительных записей является то, что большинство запросов на чтение никогда не ставит блокировки. Они просто считывают данные настолько быстро, насколько можно, обеспечивая выборку только тех строк, которые удовлетворяют заданному критерию. Недостатком подобного подхода является то, что подсистема хранения должна записывать для каждой строки дополнительные данные, выполнять лишнюю работу при проверке строк и производить некоторые дополнительные служебные операции.</p>
<p>Методика <strong>MVCC</strong> работает только на уровнях изоляции <strong>REPEATABLE READ</strong> и <strong>READ COMMITTED</strong>. Уровень <strong>READ UNCOMMITTED</strong> несовместим с <strong>MVCC</strong>, поскольку запросы не считывают версию строки, соответствующую их версии транзакции. Они читают самую последнюю версию, несмотря ни на что. Уровень <strong>SERIALIZABLE</strong> несовместим с MVCC, поскольку операции чтения блокируют каждую возвращаемую строку.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html</li>
<li><a href="https://habr.com/ru/company/oleg-bunin/blog/358984/">Как устроены базы данных</a></li>
<li><a href="https://medium.com/german-gorelkin/deadlocks-livelocks-starvation-ccd22d06f3ae">Deadlocks, Livelocks и Starvation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Индексы"><a class="header" href="#Индексы">Индексы</a></h1>
<p>Индексы представляют собой структуры, которые помогают MySQL эффективно извлекать данные. Они критичны для достижения хорошей производительности, но многие часто забывают о них или плохо понимают их смысл, поэтому индексирование является главной причиной проблем с производительностью в реальных условиях. </p>
<p>Важность индексов (именуемых в MySQL также ключами) увеличивается по мере роста объема данных. Небольшие, слабо загруженные базы зачастую могут удовлетворительно работать даже без правильно построенных индексов, но по мере роста объемов хранимой в базе информации производительность может упасть очень быстро.</p>
<p>Самый простой способ понять, как работает индекс в MySQL, – представить себе алфавитный указатель в книге. Чтобы выяснить, в какой части издания обсуждается конкретный вопрос, вы смотрите в алфавитный указатель и находите номер страницы, где упоминается термин. MySQL использует индексы сходным образом. Она ищет значение в структурах данных индекса. Обнаружив соответствие, она может перейти к самой строке. </p>
<p>Следует понимать, что индексы - дорогая штука. Они имеют свой оверхед, как на запись(что все понимают) так и на чтение:</p>
<ul>
<li>При вставке новых значений, нужно обновлять индекс</li>
<li>При изменении значений, по которому построен индекс - нужно обновлять индекс</li>
<li>При поиске значения по индексу, мы сначала ищем индексную запись(примари кей) уже потом сами значения(покрывающие и кластерные не обладают этой проблемой)</li>
<li>Имея много индексов таблицы Mysql тратит время на выбор подходящего</li>
</ul>
<p>Индексы используются для того, чтобы:</p>
<ul>
<li>Быстро найти строки, соответствующие выражению <code>WHERE</code>.</li>
<li>Извлечь строки из других таблиц при выполнении объединений.</li>
<li>Найти величины  <code>MAX()</code>  или <code>MIN()</code>  для заданного индексированного столбца.</li>
<li>Производить сортировку или группирование в таблице, если эти операции делаются на крайнем слева префиксе используемого ключа (например <code>ORDER BY key_part_1,key_part_2</code>). Если за всеми частями ключа следует <code>DESC</code>, то данный ключ читается в обратном порядке.</li>
<li>Производить join(индекс накладывается на поле правой таблицы)</li>
</ul>
<h2 id="Типы-индексов"><a class="header" href="#Типы-индексов">Типы индексов</a></h2>
<h3 id="b-tree"><a class="header" href="#b-tree">B-Tree</a></h3>
<p>Когда говорят об индексе без упоминания типа, обычно имеют в виду B-Tree индексы, в которых для хранения данных используется структура, называемая B-Tree. Мы используем термин «B-tree» для этих индексов потому, что именно так MySQL называет их в CREATE TABLE и других командах. Однако на внутреннем уровне подсистемы хранения могут использовать совершенно другие структуры данных.
Общая идея B-дерева заключается в том, что значения хранятся по порядку, и все листовые страницы находятся на одинаковом расстоянии от корня. На рисунке показано абстрактное представление B-Tree индекса, которое приблизительно соответствует тому, как работают индексы InnoDB (InnoDB использует структуру данных B+Tree).</p>
<p><img src="db/specific/mysql/../../../media/bTreeIndex.png" alt=" " /></p>
<p>Предположим, у нас есть следующая таблица:</p>
<pre><code>CREATE TABLE People (
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum(‘m’, ‘f’) not null,
    key(last_name, first_name, dob)
);
</code></pre>
<p>Примерно так это будет храниться в индексе:</p>
<p><img src="db/specific/mysql/../../../media/bTreeExample.png" alt=" " /></p>
<p>Рассмотрим когда B-Tree будет реально полезен, на примере этой таблицы:</p>
<ul>
<li>
<p><strong>Поиск по полному значению</strong> При поиске с полным значением ключа задаются критерии для всех
столбцов, по которым построен индекс. Например, индекс позволит найти человека по имени Cuba Allen, родившегося 1 января 1960.</p>
</li>
<li>
<p><strong>Поиск по самому левому префиксу</strong> Индекс позволит найти всех людей с фамилией Allen. В этом случае используется только первый столбец индекса.</p>
</li>
<li>
<p><strong>Поиск по префиксу столбца</strong> Вы можете искать соответствие по началу значения столбца. Рассматриваемый индекс позволит найти всех людей, чьи фамилии начинаются с буквы J. В этом случае используется только первый столбец индекса.</p>
</li>
<li>
<p><strong>Поиск по диапазону значений</strong> Индекс позволит найти всех людей с фамилиями, начиная с Allen и кончая Barrymore. В этом случае также используется только первый столбец индекса.</p>
</li>
<li>
<p><strong>Поиск по полному совпадению одной части и диапазону в другой части</strong> Индекс позволит найти всех людей с фамилией Allen, чьи имена начинаются с буквы K (Kim, Karl и т. п.). Полное совпадение со столбцом last_name и поиск по диапазону значений столбца first_name.</p>
<p><img src="db/specific/mysql/../../../media/multiColumnIndex.png" alt=" " /></p>
<p><img src="db/specific/mysql/../../../media/multiSortIndex.png" alt=" " /></p>
</li>
</ul>
<h3 id="hash-index"><a class="header" href="#hash-index">Hash index</a></h3>
<p>Хешиндекс строится на основе хеш-таблицы и полезен только для точного поиска с указанием всех столбцов индекса. Для каждой строки подсистема хранения вычисляет хешкод индексированных столбцов –
сравнительно короткое значение, которое, скорее всего, будет различно для строк с разными значениями ключей. В индексе хранятся хеш-коды и указатели на соответствующие строки.</p>
<p>В MySQL только подсистема хранения Memory поддерживает явные хеш-индексы. Этот тип индекса принимается по умолчанию для таблиц типа Memory, хотя над ними можно строить также и B-Tree-индексы. Подсистема Memory поддерживает неуникальные хеш-индексы, что в мире баз данных является необычным. Если для нескольких строк хеш-код одинаков, то в индексе будет храниться связанный список указателей на эти строки.</p>
<p>Подсистема хранения InnoDB поддерживает так называемые адаптивные хешиндексы. Когда InnoDB замечает, что доступ к некоторым значениям индекса происходит очень часто, она строит для них хешиндекс в памяти, помимо уже имеющихся B-Tree-индексов. Тем самым к B-Tree-индексам добавляются некоторые свойства хеш-индексов, например очень быстрый поиск. Этот процесс полностью автоматический, и вы не можете ни контролировать, ни настраивать его.</p>
<p>Также можно симулировать хеш-индекс в ручную - добавить колонку, хранящую вычисляемый хеш для другой колонки и строить индекс для колонки хранящей хеш.</p>
<h3 id="r-tree"><a class="header" href="#r-tree">R-Tree</a></h3>
<p>MyISAM поддерживает пространственные индексы, которые можно строить по столбцам пространственного типа, например GEOMETRY. Однако для того чтобы R-Tree индексы работали, необходимо использовать
геоинформационные функции MySQL, например MBRCONTAINS(). В целом пространственные индексы в MySql гавно, лучше юзать Postgres для этого.</p>
<h3 id="Полнотекстовые-индексы"><a class="header" href="#Полнотекстовые-индексы">Полнотекстовые индексы</a></h3>
<p>Полнотекстовый (FULLTEXT) индекс позволяет искать в тексте ключевые слова, а не сравнивать искомое значение со значениями в столбце. Полнотекстовый поиск не имеет ничего общего с другими типами поиска. С ним связано много тонкостей, например стоп-слова, стемминг, учет множественного числа, а также булевский поиск. Он гораздо больше напоминает поисковые системы, нежели обычное сравнение с критерием во фразе WHERE.</p>
<p>Наличие полнотекстового индекса по столбцу не делает B-Tree-индекс по этому же столбцу менее ценным. Полнотекстовые индексы предназначены для операций MATCH AGAINST, а не обычных операций с фразой WHERE. </p>
<h2 id="Селективность"><a class="header" href="#Селективность">Селективность</a></h2>
<p><strong>Селективность</strong> индекса – это отношение количества различных проиндексированных значений (<strong>кардинальности</strong>) к общему количеству строк в таблице distinct / count(). Индекс с высокой селективностью хорош тем, что позволяет MySQL при поиске соответствий отфильтровывать больше строк. Уникальный индекс имеет селективность, равную единице. </p>
<h2 id="Кластерные-индексы"><a class="header" href="#Кластерные-индексы">Кластерные индексы</a></h2>
<p><strong>Кластерные индексы</strong> не являются отдельным типом индекса. Скорее, это подход к хранению данных. Детали в разных реализациях отличаются, но в InnoDB кластерный индекс фактически содержит и B-Tree-
индекс, и сами строки в одной и той же структуре. Когда над таб лицей построен кластерный индекс, в листовых страницах индекса хранятся сами строки. Термин «кластерный» означает, что строки с близкими значениями ключа хранятся по соседству. Над таблицей можно построить только один кластерный индекс, поскольку
невозможно хранить одну и ту же строку одновременно в двух местах(однако покрывающие индексы позволяют эмулировать несколько кластерных индексов).</p>
<h2 id="Покрывающие-индексы"><a class="header" href="#Покрывающие-индексы">Покрывающие индексы</a></h2>
<p>Индексы являются средством эффективного поиска строк, но MySQL может также использовать индекс для извлечения данных, не считывая строку таблицы. В конце концов, листовые узлы индекса содержат те значения, которые они индексируют. Зачем просматривать саму строку, если чтение индекса уже может дать нужные данные? Индекс, который содержит (или «покрывает») все данные, необходимые для
формирования результатов запроса, называется <strong>покрывающим индексом</strong>.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>
<p><a href="https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/">The physical structure of InnoDB index pages</a></p>
</li>
<li>
<p><a href="https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/">B+Tree index structures in InnoDB</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/266811/">Как работает реляционная БД</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Основы-языка-sql"><a class="header" href="#Основы-языка-sql">Основы языка SQL</a></h1>
<p>SQL (structured query language — «язык структурированных запросов») — декларативный язык программирования, применяемый для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.</p>
<h2 id="Операторы"><a class="header" href="#Операторы">Операторы</a></h2>
<p>Операторы SQL делятся на:</p>
<ul>
<li>операторы определения данных (Data Definition Language, DDL):
<ul>
<li>CREATE создаёт объект БД (саму базу, таблицу, представление, пользователя и т. д.),</li>
<li>ALTER изменяет объект,</li>
<li>DROP удаляет объект;</li>
</ul>
</li>
<li>операторы манипуляции данными (Data Manipulation Language, DML):
<ul>
<li>SELECT выбирает данные, удовлетворяющие заданным условиям,</li>
<li>INSERT добавляет новые данные,</li>
<li>UPDATE изменяет существующие данные,</li>
<li>DELETE удаляет данные;</li>
</ul>
</li>
<li>операторы определения доступа к данным (Data Control Language, DCL):
<ul>
<li>GRANT предоставляет пользователю (группе) разрешения на определённые операции с объектом,</li>
<li>REVOKE отзывает ранее выданные разрешения,</li>
<li>DENY задаёт запрет, имеющий приоритет над разрешением;</li>
<li>операторы управления транзакциями (Transaction Control Language, TCL):</li>
<li>COMMIT применяет транзакцию,</li>
<li>ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,</li>
<li>SAVEPOINT делит транзакцию на более мелкие участки.</li>
</ul>
</li>
</ul>
<p><img src="db/specific/mysql/../../../media/joins.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain"><a class="header" href="#explain">Explain</a></h1>
<p>Оператор <code>EXLPAIN</code> используется для анализа запросов. При помощи этого оператора можно увидеть какие запросы не являются оптимальными и оптимизировать их. Для получения информации о запросе необходимо записать оператор <code>EXPLAIN</code> прямо перед самим запросом, например:</p>
<pre><code class="language-sql">EXPLAIN SELECT * FROM student ;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | student | ALL  | NULL          | NULL | NULL    | NULL |    8 | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
1 row in set (0.14 sec)
</code></pre>
<ul>
<li>
<p><strong>id</strong> – порядковый номер для каждого SELECT’а внутри запроса, строк будет столько, сколько операторов SELECT в запросе.</p>
</li>
<li>
<p><strong>select_type</strong> – тип запроса SELECT.</p>
<ul>
<li><strong>SIMPLE</strong> — Простой запрос SELECT без подзапросов или UNION’ов</li>
<li><strong>PRIMARY</strong> – данный SELECT – самый внешний запрос в JOIN’е</li>
<li><strong>DERIVED</strong> – данный SELECT является частью подзапроса внутри FROM</li>
<li><strong>SUBQUERY</strong> – первый SELECT в подзапросе</li>
<li><strong>DEPENDENT SUBQUERY</strong> – подзапрос, который зависит от внешнего запроса</li>
<li><strong>UNCACHABLE SUBQUERY</strong> – не кешируемый подзапрос (существуют определенные условия для того, чтобы запрос кешировался)</li>
<li><strong>UNION</strong> – второй или последующий SELECT в UNION’е</li>
<li><strong>DEPENDENT UNION</strong> – второй или последующий SELECT в UNION’е, зависимый от внешнего запроса</li>
<li><strong>UNION RESULT</strong> – результат UNION’а</li>
</ul>
</li>
<li>
<p><strong>table</strong> – таблица, которая использована для запроса. Значения могут совпадать с существующими таблицами, либо могут принимать специальные значения, например <derived> если был записан запрос в предложении FROM или <union> если был использован оператор UNION.</p>
</li>
<li>
<p><strong>type</strong> — то как система осуществляет соединение таблиц. Иногда говорят, что это то, как осуществляется доступ к значениям в таблице. Например, производился поиск по всей таблице, либо же по определенному интервалу. Или же поиск производился исключительно по индексу. Это одно из наиболее полезных полей в выводе потому, что может сообщать об отсутствующих индексах или почему написанный запрос должен быть пересмотрен и переписан. Возможные значения:</p>
<ul>
<li><strong>System</strong> – таблица имеет только одну строку</li>
<li><strong>Const</strong> – таблица имеет только одну соответствующую строку, которая проиндексирована. Это наиболее быстрый тип соединения потому, что таблица читается только один раз и значение строки может восприниматься при дальнейших соединениях как константа.</li>
<li><strong>Eq_ref</strong> – все части индекса используются для связывания. Используемые индексы: PRIMARY KEY или UNIQUE NOT NULL. Это еще один наилучший возможный тип связывания.</li>
<li><strong>Ref</strong> – все соответствующие строки индексного столбца считываются для каждой комбинации строк из предыдущей таблицы. Этот тип соединения для индексированных столбцов выглядит как использование операторов = или &lt; = &gt;</li>
<li><strong>Ref_or_null</strong> – то же самое, что и ref, но также содержит строки со значением null для столбца</li>
<li><strong>Fulltext</strong> – соединение использует полнотекстовый индекс таблицы</li>
<li><strong>Index_merge</strong> – соединение использует список индексов для получения результирующего набора. Столбец key вывода команды EXPLAIN будет содержать список использованных индексов.</li>
<li><strong>Unique_subquery</strong> – подзапрос IN возвращает только один результат из таблицы и использует первичный ключ.</li>
<li><strong>Index_subquery</strong> – то же, что и предыдущий, но возвращает более одного результата.</li>
<li><strong>Range</strong> – индекс, использованный для нахождения соответствующей строки в определенном диапазоне, обычно, когда ключевой столбец сравнивается с константой, используя операторы вроде: BETWEEN, IN, &gt;, &gt;=, etc.</li>
<li><strong>Index</strong> – сканируется все дерево индексов для нахождения соответствующих строк.</li>
<li><strong>All</strong> – Для нахождения соответствующих строк используются сканирование всей таблицы. Это наихудший тип соединения и обычно указывает на отсутствие подходящих индексов в таблице.</li>
</ul>
</li>
<li>
<p><strong>possible_keys</strong> – показывает индексы, которые могут быть использованы для нахождения строк в таблице. На практике они могут использоваться, а могут и не использоваться. Фактически, этот столбец может сослужить добрую службу в деле оптимизации запросов, т.к. значение NULL указывает на то, что не найдено ни одного подходящего индекса.</p>
</li>
<li>
<p><strong>key</strong>– указывает на использованный индекс. Этот столбец может содержать индекс, не указанный в столбце possible_keys. Это происходит в тех случаях, когда, например, SELECT FROM таблицы никаких условий WHERE нет. Оптимизатор видит, что, вроде как, никаких ключей использовать не надо, а потом смотрит, что столбцы являются частью ключа и, в принципе, можно их выбрать именно по индексу и тогда делать покрывающий индекс. Так может получиться, что possible_key: NULL, а key – покрывающий индекс, это значит, что он будет использовать именно индекс.</p>
</li>
<li>
<p><strong>key_len</strong> – длина индекса, которую оптимизатор MySQL выбрал для использования. Например, значение key_len, равное 4, означает, что памяти требуется для хранения 4 знаков.</p>
</li>
<li>
<p><strong>ref</strong> – указываются столбцы или константы, которые сравниваются с индексом, указанным в поле key. MySQL выберет либо значение константы для сравнения, либо само поле, основываясь на плане выполнения запроса.</p>
</li>
<li>
<p><strong>rows</strong> – отображает число записей, обработанных для получения выходных данных. Это еще одно очень важное поле, которое дает повод оптимизировать запросы, особенно те, которые используют JOIN’ы и подзапросы.</p>
</li>
<li>
<p><strong>extra</strong> – содержит дополнительную информацию, относящуюся к плану выполнения запроса:</p>
<ul>
<li><strong>Distinct</strong> - После нахождения первой совпадающей строки MySQL не будет продолжать поиск строк для текущей комбинации строк.</li>
<li><strong>Not exists</strong> - MySQL смог осуществить оптимизацию LEFT JOIN для запроса и после нахождения одной строки, соответствующей критерию LEFT JOIN, не будет искать в этой таблице последующие строки для предыдущей комбинации строк. Например: SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL; Предположим, что столбец t2.id определен как NOT NULL. В этом случае MySQL просмотрит таблицу t1 и будет искать строки в t2 соответствующие t1.id. Если MySQL находит в t2 нужную строку, он знает, что t2.id никогда не может иметь значение NULL, и не будет искать в t2 оставшуюся часть строк, имеющих тот же самый id. Другими словами, для каждой строки в t1 MySQL должен выполнить только один поиск в t2, независимо от того, сколько совпадающих строк содержится в t2.</li>
<li><strong>range checked for each record (index map: #)</strong> - MySQL не нашел достаточно хорошего индекса для использования. Вместо этого для каждой комбинации строк в предшествующих таблицах он будет проверять, какой индекс следует использовать (если есть какой-либо индекс), и применять его для поиска строк в таблице. Это делается не очень быстро, но таким образом таблицы связываются быстрее, чем без индекса.</li>
<li><strong>Using filesort</strong> - MySQL должен будет сделать дополнительный проход, чтобы выяснить, как извлечь строки в порядке сортировки. Для выполнения сортировки выполняется просмотр всех строк согласно типу связывания (join type) и сохраняются ключ сортировки + указатель на строку для всех строк, удовлетворяющих выражению WHERE. После этого ключи сортируются и строки извлекаются в порядке сортировки.</li>
<li><strong>Using index</strong> - Для извлечения данных из столбца используется только информация дерева индексов; при этом нет необходимости производить собственно чтение записи. Это применимо для случаев, когда все используемые столбцы таблицы являются частью одного индекса.</li>
<li><strong>Using temporary</strong> - Чтобы выполнить запрос, MySQL должен будет создать временную таблицу для хранения результата. Это обычно происходит, если предложение ORDER BY выполняется для набора столбцов, отличного от того, который используется в предложении GROUP BY.</li>
<li><strong>Where used</strong> - Выражение WHERE будет использоваться для выделения тех строк, которые будут сопоставляться со следующей таблицей или тех, которые будут посланы клиенту. Если этой информации нет, а таблица имеет тип ALL или index, то, значит, в вашем запросе есть какая-то ошибка (если вы не собираетесь делать выборку/тестирование всех строк таблицы).</li>
</ul>
</li>
</ul>
<p>Также есть расширенный вариант <code>EXPLAIN EXTENDED</code>. <code>EXPLAIN EXTENDED</code> умеет показывать, что же конкретно делает с Вашим запросом оптимизатор MySQL. Для разработчика может быть совсем не очевидно, насколько сильно может отличаться написанный им запрос от того, который в действительности будет выполнен сервером. Этот процесс называется механизмом перезаписи запросов (query-rewrite), и он является частью любого хорошего SQL-оптимизатора. Команда EXPLAIN EXTENDED добавляет дополнительные предупреждения (warnings) к выводу команды EXPLAIN, в том числе и переписанный SQL-запрос. </p>
<p>Кроме того появился json формат вывода EXPLAIN - он менее удобен для чтения, но чуть более информативен.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>
<p>https://habr.com/post/211022/</p>
</li>
<li>
<p>http://www.mysql.ru/docs/man/EXPLAIN.html</p>
</li>
<li>
<p>https://habr.com/post/31129/</p>
</li>
<li>
<p>https://devionity.com/ru/courses/mysql-pro/explain</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql-1"><a class="header" href="#mysql-1">Mysql</a></h1>
<h2 id="Движки-таблиц-mysql"><a class="header" href="#Движки-таблиц-mysql">Движки таблиц MySql</a></h2>
<h3 id="myisam"><a class="header" href="#myisam">MyIsam</a></h3>
<p>Одна из основных (наряду с InnoDB) систем хранения данных в СУБД MySQL. Она основывается на принципах ISAM и обладает в сравнении с ним рядом полезных дополнений. Поддерживается с версий MySQL 3.x, до версий MySQL 5.5 являлась системой хранения по умолчанию. MyISAM имеет возможности по сжатию данных, по созданию полнотекстовых индексов. Однако не является устойчивой к сбоям и не выполняет требования ACID.[1]</p>
<h3 id="innodb"><a class="header" href="#innodb">InnoDB</a></h3>
<p>Одна из выбираемых подсистем низкого уровня в СУБД MySQL, входит во все стандартные сборки для различных операционных систем. Основным отличием InnoDB от других подсистем низкого уровня MySQL является наличие механизма транзакций и внешних ключей.</p>
<p>В отличие от таблиц <a href="https://ru.wikipedia.org/wiki/MyISAM">MyISAM</a>, где для каждой таблицы создается один файл данных, данные InnoDB в настройках по умолчанию хранятся в больших совместно используемых файлах (изменить это можно с помощью настроек опции <code>innodb_file_per_table</code>), что позволяет использовать постраничный кэш страниц базы данных. Формат данных InnoDB обеспечивает надежное хранение данных за счет транзакционности и блокировки данных на уровне строки.</p>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<p>Таблица, хранимая в памяти. Поддерживает хеш индекс. Может подойти для справочных» таблиц или таблиц «соответствия», например для таблицы, в которой почтовым кодам соответствуют названия регионов; Для кэширования результатов периодического агрегирования данных; для промежуточных результатов при анализе данных.</p>
<h3 id="csv"><a class="header" href="#csv">CSV</a></h3>
<p>хранит таблицы в CSV формате
позволяет редактировать таблицы внешними приложениями
плохо документирован, есть открытые баги</p>
<h3 id="federated"><a class="header" href="#federated">FEDERATED</a></h3>
<p>Представляет собой «прозрачное» подключение к другому серверу (не репликация). Есть множество ограничений, планируется возможность подключения к отличным от MySQL серверам.</p>
<h3 id="blackhole"><a class="header" href="#blackhole">BLACKHOLE</a></h3>
<p>Данные идут «вникуда», двоичные логи пишутся. Оптимизация репликации (мастер-сервер не пишет данные на диск)</p>
<h2 id="Разное-1"><a class="header" href="#Разное-1">Разное</a></h2>
<h3 id="char--varchar"><a class="header" href="#char--varchar">Char &amp; Varchar</a></h3>
<p>При выборе типов строк действует правило минимума. Оцените максимальную длину строки и поставьте ограничение. Тип <strong>CHAR</strong> — тип фиксированной длины. Это значит, что для любой строки будет выделено всегда одно и то же количество байт.
<strong>VARCHAR</strong> — тип переменной длины. В такой колонке строка будет занимать ровно свою длину (в количестве символов).
Однако Mysql прибавит еще 1 или 2 байта на хранение длины самой строки. Также стоит учесть, что обновление такой строки может быть дорогой операцией (чревато фрагментацией данных, а значит — замедлением чтения). Используйте такое правило:</p>
<p><strong>Если значения в текстовой колонке похожи по длине, выбирайте CHAR, иначе — VARCHAR.</strong></p>
<h2 id="innodb-vs-myisam"><a class="header" href="#innodb-vs-myisam">Innodb VS MyIsam</a></h2>
<ul>
<li>
<p>MyISAM поддерживает сжатие таблиц в отличие от InnoDB.</p>
</li>
<li>
<p>MyISAM имеет встроенные полнотекстный поиск в отличие от InnoDB.</p>
</li>
<li>
<p>InnoDB поддерживает транзакции в отличие от MyISAM.</p>
</li>
<li>
<p>InnoDB поддерживает блокировки уровня строки (MyISAM - только уровня таблицы).</p>
</li>
<li>
<p>InnoDB поддерживает ограничения внешних ключей (MyISAM - нет).</p>
</li>
<li>
<p>InnoDB более надежна при больших объемах данных.</p>
</li>
<li>
<p>InnoDB в теории немного быстрее.</p>
</li>
</ul>
<table border="1" width="100%" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="65%">Описание</td>
<td width="15%"><strong>MyISAM</strong></td>
<td width="20%"><strong>InnoDB</strong></td>
</tr>
<tr>
<td><strong>Транзакционный движок?</strong>Транзакция (Transaction) — блок операторов SQL, который в случае ошибки в одном запросе, возвращается к предыдущему состоянию (Rollback), и только в случае выполнения всех запросов подтверждается (Commit)</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Поддержка внешних ключей</strong>Внешние ключи — это способ связать записи в двух таблицах по определенным полям так, что при обновлении поля в родительской автоматически происходит определенное изменение поля в дочерней (дочернюю и родительскую выбираешь при создании ключа; точнее, создаешь ключ в дочерней, который ссылается на родительскую).</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td><strong>Блокировка.</strong>Блокировка на уровне строк, т.е. если процессу нужно обновить строку в таблице, то он блокирует только эту строку, позволяя другим обновлять другие строки параллельно</td>
<td>Блокировка на уровне таблиц</td>
<td>Блокировка на уровне строк</td>
</tr>
<tr>
<td>Одновременные запросы к разным частям таблицы.</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>При смешанной нагрузке в таблице (select/update/delete/insert)</td>
<td>Медленнее</td>
<td>Быстрее</td>
</tr>
<tr>
<td>Операция Insert</td>
<td>Быстрее</td>
<td>Медленнее, ибо есть оверхед на транзакцию, но это цена надежности</td>
</tr>
<tr>
<td>Если преобладают операции чтения (SELECT)</td>
<td>Работает быстрее</td>
<td>Работает медленнее</td>
</tr>
<tr>
<td><strong>Deadlock</strong>Deadlock — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии бесконечного ожидания ресурсов, захваченных самими этими процессами.</td>
<td>Не возникают</td>
<td>Возможны.</td>
</tr>
<tr>
<td>Поддержка полнотекстового поиска</td>
<td>Да</td>
<td>Нет (доступен начиная с версии MySQL 5.6.4)</td>
</tr>
<tr>
<td>Запрос Count(*)</td>
<td>Быстрее</td>
<td>Медленнее</td>
</tr>
<tr>
<td><strong>Поддержка mysqlhotcopy</strong>Утилита mysqlhotcopy представляет собой Perl-сценарий, использующий SQL-команды LOCK TABLES, FLUSH TABLES и Unix-утилиты cp или scp для быстрого получения резервной копии базы данных.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Файловое хранение таблиц</td>
<td>Каждой таблице отдельный файл</td>
<td>Данные при настройках по умолчанию хранятся в больших совместно используемых файлах</td>
</tr>
<tr>
<td><strong>Бинарное копировании таблиц?</strong>Табличные файлы можно перемещать между компьютерами разных архитектур и разными операционными системами без всякого преобразования.</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Размер таблиц в БД</td>
<td>Меньше</td>
<td>Больше</td>
</tr>
<tr>
<td>Поведение в случае сбоя</td>
<td>Крашится вся таблица</td>
<td>По логам можно все восстановить</td>
</tr>
<tr>
<td>В случае хранения «логов» и подобного</td>
<td>Лучше</td>
<td>Хуже</td>
</tr>
</tbody>
</table>
<h2 id="datatime-vs-timestamp"><a class="header" href="#datatime-vs-timestamp">DATATIME vs TIMESTAMP</a></h2>
<p>TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. При получении из базы отображается с учётом часового пояса. Предназначен для хранения даты и/или времени происхождения неких событий. Важное отличие от DATATIME в диапазонах значений: очевидно, что TIMESTAMP не годится для хранения исторических событий (даже таких, как дни рождений), но отлично подходит для хранения текущих (логирование, даты размещения статей, добавления товаров, оформления заказов) и предстоящих, в обозримом будущем, событий (выходы новых версий, календари и планировщики и т.д).</p>
<p>Основное удобство использования типа TIMESTAMP состоит в том, что для столбцов этого типа в таблицах можно задавать значение по умолчанию в виде подстановки текущего времени, а так же установки текущего времени при обновлении записи. Если вам требуется эти возможности, то с вероятностью 99% TIMESTAMP — именно то, что вам нужно.</p>
<p>Не стоит бояться того, что с приближением к 2038 году ваш софт перестанет работать. Во-первых, до этого времени вашим софтом, скорее всего, просто перестанут пользоваться (особенно версиями, которые пишутся сейчас). Во-вторых, с приближением к этой дате разработчики MySQL обязательно что-нибудь придумают для сохранения работоспособности вашего софта. Все решится так же хорошо, как проблема Y2K.</p>
<p>Итак, тип TIMESTAMP используем для хранения дат и времени свершения событий нашего времени, а DATETIME и DATE — для хранения дат и времени свершения исторических событий, или событий глубокого будущего.</p>
<p>Диапазоны значений — это важное отличие между типами TIMESTAMP, DATETIME и DATE, но не главное. Главное то, что TIMESTAMP хранит значение в UTC. При сохранении значения оно переводится из текущего временной зоны в UTC, а при его чтении — во время текущей временной зоны из UTC. DATETIME и DATE хранят и выводят всегда одно и то же время, независимо от временных зон.</p>
<p>Временные зоны устанавливаются в СУБД MySQL глобально или для текущего подключения. Последнее можно использовать для обеспечения работы разных пользователей в разных временных зонах на уровне СУБД. Все значения времени физически будут храниться в UTC, а приниматься от клиента и отдаваться клиенту — в значениях его временной зоны. Но только при использовании типа данных TIMESTAMP. DATE и DATETIME всегда принимают, хранят и отдают одно и то же значение.</p>
<p>Функция NOW() и ее синонимы возвращают значение времени в текущей временной зоне пользователя.</p>
<p>Учитывая все эти обстоятельства, необходимо быть крайне внимательными при изменении временной зоны в пределах подключения к серверу и использовании типов DATE и DATETIME. Если надо хранить дату (например, дату рождения), то никаких проблем не будет. Дата рождения в любой зоне одинаковая. Т.е. если вы родились 1 января в 0:00 UTC/GMT+0, то это не значит, что в Америке будут праздновать ваш день рождения 31 декабря. Но если вы решите хранить время события в столбце DATETIME, то тут уже построить работу с пользовательскими временными зонами на уровне СУБД просто не выйдет. </p>
<p>DATETIME 8 байт
TIMESTAMP4 байта</p>
<h2 id="Является-ли-триггер-частью-транзакции"><a class="header" href="#Является-ли-триггер-частью-транзакции">Является ли триггер частью транзакции?</a></h2>
<p>For transactional tables, failure of a statement should cause rollback of all changes performed by the statement. Failure of a trigger causes the statement to fail, so trigger failure also causes rollback. For nontransactional tables, such rollback cannot be done, so although the statement fails, any changes performed prior to the point of the error remain in effect.</p>
<h2 id="null"><a class="header" href="#null">NULL</a></h2>
<p>К <code>NULL</code>-значениям нужно привыкнуть. По идее, <code>NULL</code> обозначает отсутствующее или неизвестное значение и обрабатывается отличным от других значений образом. Проверить значение на равенство <code>NULL</code> с помощью обычных арифметических операторов сравнения (=, &lt; или &lt;&gt;) нельзя. Это отлично иллюстрирует следующий запрос:</p>
<pre><code class="language-sql">mysql&gt; SELECT 1 = NULL, 1 &lt;&gt; NULL, 1 &lt; NULL, 1 &gt; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 &lt;&gt; NULL | 1 &lt; NULL | 1 &gt; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</code></pre>
<p>Очевидно, что от таких сравнений значащих результатов ожидать нечего. Вместо этого нужно пользоваться операторами <code>IS NULL</code> и <code>IS NOT NULL</code>:</p>
<pre><code class="language-sql">mysql&gt; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</code></pre>
<p>Отметим, что два значения <code>NULL</code> считаются равными при выполнении команды <code>GROUP BY</code>.</p>
<p>В MySQL 0 или <code>NULL</code> приравнивается к логическому false, а все остальное - к true. По умолчанию значение &quot;истина&quot; для булевого оператора равно 1.</p>
<p>При выполнении команды <code>ORDER BY</code> значения <code>NULL</code> всегда располагаются в самом начале списка результатов, даже при использовании параметра <code>DESC</code>.</p>
<h3 id="Проблема--limit-100000-10"><a class="header" href="#Проблема--limit-100000-10">Проблема  LIMIT 100000, 10</a></h3>
<p>Основная проблема тут в том, что при «LIMIT 100000, 10» MySQL сначала посмотрит 100000 записей, а только потом вернёт 10.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>https://ruhighload.com/%D0%92%D1%8B%D0%B1%D0%BE%D1%80+%D1%82%D0%B8%D0%BF%D0%BE%D0%B2+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85+%D0%B2+mysql</li>
<li>https://itif.ru/otlichiya-myisam-innodb/</li>
<li>https://valera.ws/2009.09.17~time-formats-in-mysql/</li>
<li>https://habr.com/company/mailru/blog/266811/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-такое-postgresql"><a class="header" href="#Что-такое-postgresql">Что такое PostgreSQL?</a></h1>
<p>PostgreSQL — это объектно-реляционная система управления базами данных (ОРСУБД, ORDBMS), основанная на <a href="http://db.cs.berkeley.edu/postgres.html">POSTGRES, Version 4.2</a> — программе, разработанной на факультете компьютерных наук Калифорнийского университета в Беркли. В POSTGRES появилось множество новшеств, которые были реализованы в некоторых коммерческих СУБД гораздо позднее.</p>
<p>PostgreSQL — СУБД с открытым исходным кодом, основой которого был код, написанный в Беркли. Она поддерживает большую часть стандарта SQL и предлагает множество современных функций:</p>
<ul>
<li>сложные запросы</li>
<li>внешние ключи</li>
<li>триггеры</li>
<li>изменяемые представления</li>
<li>транзакционная целостность</li>
<li>многоверсионность</li>
</ul>
<p>Кроме того, пользователи могут всячески расширять возможности PostgreSQL, например создавая свои</p>
<ul>
<li>типы данных</li>
<li>функции</li>
<li>операторы</li>
<li>агрегатные функции</li>
<li>методы индексирования</li>
<li>процедурные языки</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nosql"><a class="header" href="#nosql">noSql</a></h1>
<p><strong>NoSQL</strong> (от <a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> not only SQL — <em>не только SQL</em>) — термин, обозначающий ряд подходов, направленных на реализацию хранилищ <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">баз данных</a>, имеющих существенные отличия от моделей, используемых в традиционных <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%A1%D0%A3%D0%91%D0%94">реляционных СУБД</a> с доступом к данным средствами языка <a href="https://ru.wikipedia.org/wiki/SQL">SQL</a>. Применяется к базам данных, в которых делается попытка решить проблемы <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D1%8C">масштабируемости</a> и <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8">доступности</a> за счёт <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%82%D0%BE%D0%BC%D0%B0%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C">атомарности</a> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> atomicity) и <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">согласованности данных</a> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> consistency).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redis"><a class="header" href="#redis">Redis</a></h1>
<p><a href="http://redis.io/">Redis</a> (REmote DIctionary Server) — это <em>не</em>реляционная высокопроизводительная СУБД. Быстрое хранилище данных в памяти с открытым исходным кодом для использования в качестве базы данных, кэша, брокера сообщений или очереди. Redis хранит все данные в памяти, доступ к данным осуществляется только по ключу. Опционально копия данных может храниться на диске. Этот подход обеспечивает производительность, в десятки раз превосходящую производительность реляционных СУБД, а также упрощает шардинг данных.</p>
<p>Интересная особенность Redis заключается в том, что это — <strong>однопоточный сервер</strong>. Такое решение сильно упрощает поддержку кода, обеспечивает атомарность операций и позволяет запустить по одному процессу Redis на каждое ядро процессора. Разумеется, каждый процесс будет прослушивать свой порт. Решение нетипичное, но вполне оправданное, так как на выполнение одной операции Redis тратит мало времени - порядка одной стотысячной секунды</p>
<h2 id="Типы-данных"><a class="header" href="#Типы-данных">Типы данных</a></h2>
<h3 id="Строки-strings"><a class="header" href="#Строки-strings">Строки (strings)</a></h3>
<p>Базовый тип данных Redis. Строки в Redis бинарно-безопасны, <em>могут использоваться так же как числа,</em> ограничены размером 512 Мб.  Строки — это основная структура. Это одна их четырех базовых структур, а так же основа всех сложных структур, потому что Список — это список строк, Множество — это множество строк, и так далее.</p>
<p>Строки хороши во всех очевидных сценариях использования, когда вы хотите хранить HTML страницу, но так же они хороши если вы хотите избежать конвертирования уже закодированных данных. Например, если у вас есть JSON или MessagePack, вы можете просто хранить объекты как строки. В Redis 2.6 вы даже можете управлять этим видом структур на стороне сервера, используя скрипты на Lua.</p>
<p>Другое интересное использование строк — это битовые массивы, и вообще, случайный доступ к массивам байтов, так как Redis предоставляет команды доступа к произвольным диапазонам байтов, или даже к отдельным битам. </p>
<h3 id="Списки-lists"><a class="header" href="#Списки-lists">Списки (lists)</a></h3>
<p>Классические списки строк, упорядоченные в порядке вставки, которая возможна как со стороны головы, так и со стороны хвоста списка. Максимальное количество элементов — 2^32 — 1. Списки хороши когда в основном вы работаете с крайними элементами: около хвоста, или около головы. Списки не лучший выбор для деления чего-либо на страницы, из-за медленного случайного доступа, O(N). Хорошим использованием списков будут простые очереди и стеки, или циклическая обработка элементов командой <strong>RPOPLPUSH</strong>, параметрами которой будет один и тот же список. Списки так же хороши, когда нам нужна ограниченная коллекция из N элементов, доступ в которой <em>обычно</em> осуществляется только к верхнему или нижнему элементам, или когда N небольшое.</p>
<h3 id="Множестваsets"><a class="header" href="#Множестваsets">Множества(sets)</a></h3>
<p>Множества строк в математическом понимании: не упорядочены, поддерживают операции вставки, проверки вхождения элемента, пересечения и разницы множеств. Максимальное количество элементов — 2^32 — 1. Множество — это не упорядоченный набор данных, оно эффективно когда у вас есть коллекция элементов, и важно очень быстро проверить присутствие элемента в коллекции, или получить ее размер. Еще одна «фишка» множеств — это возможность получить случайный элемент.</p>
<p>Множества поддерживают сложные операции, такие как пересечение, объединение и так далее, это хороший способ использовать Redis в «вычислительной» манере, когда у вас есть данные, и вы хотите получить некоторый результат, выполняя преобразования над этими данными. Небольшие множества кодируются очень эффективным способом.</p>
<p>Множества используются для хранения уникальных значений и предоставляют набор операций — таких, как объединение. Множества не упорядочены, но предоставляют эффективные операции со значениями. Список друзей является классическим примером использования множеств:</p>
<pre><code>sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia
</code></pre>
<p>Независимо от того, сколько друзей имеет пользователь, мы можем эффективно (<strong>O(1)</strong>) определить, являются ли пользователи userX и userY друзьями, или нет.</p>
<pre><code>sismember friends:leto jessica
sismember friends:leto vladimir
</code></pre>
<p>Более того, мы можем узнать, имеют ли два пользователя общих друзей:</p>
<pre><code>sinter friends:leto friends:duncan
</code></pre>
<p>и даже сохранить результат этой операции под новым ключом:</p>
<pre><code>sinterstore friends:leto_duncan friends:leto friends:duncan
</code></pre>
<p>Множества отлично подходят для теггинга и отслеживания любых других свойств, для которых повторы не имеют смысла (или там, где мы хотим использовать операции над множествами, такие как пересечение и объединение).</p>
<h3 id="Упорядоченные-множестваsorted-sets"><a class="header" href="#Упорядоченные-множестваsorted-sets">Упорядоченные множества(sorted sets)</a></h3>
<p>Упорядоченное множество отличается от обычного тем, что его элементы упорядочены по особому параметру «score». Упорядоченное Множество — это <em>единственная структура данных, кроме списка, поддерживающая работу с упорядоченными элементами</em>. С упорядоченными множествами можно делать много крутых вещей. Например, вы можете реализовать все виды <strong>Топа Чего-либо</strong> в вашем веб-приложении. Топ пользователей по рейтингу, топ постов по числу просмотров, топ чего угодно, и один экземпляр Redis будет обслуживать тонны вставок и запросов в секунду.</p>
<p>Упорядоченные множества, как и обычные множества, могут быть использованы для описания отношений, но они так же позволят делить элементы на страницы, и сохранять порядок. К примеру, если я храню друзей пользователя X как упорядоченное множество, я могу легко хранить их в порядке добавления в друзья.</p>
<p>Упорядоченные множества хороши для очередей с приоритетами.</p>
<p>Упорядоченные множества — это что-то вроде более мощных списков, в которых вставка, удаление или получение элементов из середины списка так же быстро. Но они используют больше памяти, и являются <strong>O(log(N))</strong> структурами.</p>
<p>Упорядоченные множества — симбиоз обычных множеств и списков. Дело в том, что они содержат только уникальные значения, но каждому значению соответствуют число (score). В результате для это типа данных вводится порядок:</p>
<p>A &gt; B, если A.score &gt; B.score
если A.score = B.score, то A и B упорядочиваются в соответствии с лексикографическим порядком значений. Так как они уникальны, равенство двух различных элементов в упорядоченном множестве невозможно.</p>
<h3 id="Хеш-таблицы"><a class="header" href="#Хеш-таблицы">Хеш-таблицы</a></h3>
<p><strong>Хеш-таблицы</strong> (hashes). Классические хеш-таблицы или ассоциативные массивы. Максимальное количество пар «ключ-значение» — 2^32 — 1. Хэши отличная структура для представления объектов, составленных из полей и значений. Поля хэшей могут быть атомарно инкрементированы командой HINCRBY. Если у вас есть объекты, такие как пользователи, записи в блоге, или другие виды <em>элементов</em>, хэши — это то, что вам нужно, если вы не хотите использовать свой собственный формат, такой как JSON или любой другой.</p>
<p>Хеши — хороший пример того, почему называть Redis хранилищем пар ключ-значение не совсем корректно. Хеши во многом похожи на строки. Важным отличием является то, что они предоставляют дополнительный уровень адресации данных — поля (fields). Эквивалентами команд set и get для хешей являются:</p>
<pre><code>hset users:goku powerlevel 9000
hget users:goku powerlevel
</code></pre>
<p>Мы также можем устанавливать значения сразу нескольких полей, получать все поля со значениями, выводить список всех полей и удалять отдельные поля:</p>
<pre><code>hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age
</code></pre>
<p>Как вы видите, хеши дают чуть больше контроля, чем строки. Вместо того чтобы хранить данные о пользователе в виде одного сериализованного значения, мы можем использовать хеш для более точного представления. Преимуществом будет возможность извлечения, изменения и удаления отдельных частей данных без необходимости читать и записывать все значение целиком. Однако, имейте в виду, что небольшие хэши в Redis кодируются очень эффективно, и вы можете использовать атомарные операции GET, SET или атомарно инкрементировать отдельное поле с большой скоростью.</p>
<h3 id="bitmaps"><a class="header" href="#bitmaps">Bitmaps</a></h3>
<p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 232 different bits. Bit operations are divided into two groups: constant-time single bit operations, like setting a bit to 1 or 0, or getting its value, and operations on groups of bits, for example counting the number of set bits in a given range of bits (e.g., population counting).</p>
<p>One of the biggest advantages of bitmaps is that they often provide extreme space savings when storing information. For example in a system where different users are represented by incremental user IDs, it is possible to remember a single bit information (for example, knowing whether a user wants to receive a newsletter) of 4 billion of users using just 512 MB of memory.</p>
<h3 id="hyperloglog"><a class="header" href="#hyperloglog">HyperLogLog</a></h3>
<p>Redis имеет специальное хранилище <strong>HyperLogLog</strong>. Оно позволяет сохранять туда ключи, а затем получать количество уникальных ключей в этом хранилище. Ограничение в том, что список сохраненных ключей достать невозможно. Преимущество в том, что одно такое хранилище занимает всего 12 Кб, способно сохранять 264 элементов и возвращает результат с погрешностью всего <em>0.8%</em>.</p>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<p>Redis Stream — новый абстрактный тип данных, представленный в Redis с выходом версии 5.0
Концептуально Redis Stream — это List, в который вы можете добавлять записи. Каждая запись имеет уникальный идентификатор. По умолчанию идентификатор генерируется автоматически и включает в себя временную метку. Поэтому вы можете запрашивать диапазоны записей по времени или получать новые данные по мере их поступления в поток, как Unix команда «tail -f» читает лог-файл и замирает в ожидании новых данных. Обратите внимание, что поток могут слушать одновременно несколько клиентов, как многие «tail -f» процессы могут одновременно читать файл, не конфликтуя друг с другом. </p>
<ul>
<li>Сообщение доставляется одному клиенту. Первый заблокированный чтением клиент получит данные первым.</li>
<li>Клинт должен сам инициировать операцию чтения каждого сообщения. List ничего не знает о клиентах.</li>
<li>Сообщения хранятся до тех пор, пока их кто-то не считает или не удалит явно. Если вы настроили Redis сервер, чтобы он сбрасывал данные на диск, то надёжность системы резко возрастает.</li>
</ul>
<p><img src="db/specific/noSql/../../../media/redisTypes.jpg" alt=" " /></p>
<h3 id="Псевдо-Многоключевые-Запросы"><a class="header" href="#Псевдо-Многоключевые-Запросы">Псевдо-Многоключевые Запросы</a></h3>
<p>Типичной ситуацией, в которую вы будете попадать, будет необходимость запрашивать одно и то же значение по разным ключам. Например, вы можете хотеть получить данные пользователя по адресу электронной почты (в случае, если пользователь входит на сайт впервые) и по идентификатору (после входа пользователя на сайт). Одним из ужасных решений будет дублирование объекта в двух строковых значениях:</p>
<pre><code>set users:leto@dune.gov &quot;{id: 9001, email: 'leto@dune.gov', ...}&quot;
set users:9001 &quot;{id: 9001, email: 'leto@dune.gov', ...}&quot;
Это неправильно, поскольку такими данными трудно управлять, и они занимают в два раза больше памяти.
</code></pre>
<p>Было бы здорово, если бы Redis позволял создавать связь между двумя ключами, но такой возможности нет (и скорее всего никогда не будет). Главным принципом развития Redis является простота кода и API. Внутренняя реализация связанных ключей (есть много вещей, которые можно делать с ключами, о чем мы еще не говорили) не стоит возможных усилий, если мы увидим, что Redis уже предоставляет решение — хеши.</p>
<p>Используя хеш, мы можем избавиться от необходимости дублирования:</p>
<pre><code>set users:9001 &quot;{id: 9001, email: leto@dune.gov, ...}&quot;
hset users:lookup:email leto@dune.gov 9001
</code></pre>
<p>Мы используем поле как вторичный псевдо-индекс, и получаем ссылку на единственный объект, представляющий пользователя. Чтобы получить пользователя по идентификатору, мы используем обычную команду get:</p>
<pre><code>get users:9001
</code></pre>
<p>Чтобы получить пользователя по адресу электронной почты, мы воспользуемся сначала hget, а затем get (код на Ruby):</p>
<pre><code>id = redis.hget('users:lookup:email', 'leto@dune.gov')
user = redis.get(&quot;users:#{id}&quot;)
</code></pre>
<p>Это то, чем вы, скорее всего, будете пользоваться очень часто. Для меня это как раз тот случай, когда хеши особенно хороши, но это не очевидный способ использования, пока вы не увидите это своими глазами.</p>
<h2 id="Хранение"><a class="header" href="#Хранение">Хранение</a></h2>
<p>Redis хранит данные в оперативной памяти, но периодически сохраняет их на диск, чтобы восстановить при перезапуске. Стандартные настройки сделаны для скорости, а не надежности, поэтому при перезапуске часть данных теряется. Но есть возможность писать данные на диск. Цена — резкая деградация производительности. Есть 4 режима:</p>
<ul>
<li><strong>RDB</strong> (Redis Database): The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li>
<li><strong>AOF</strong> (Append Only File): The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to <a href="https://redis.io/topics/persistence#log-rewriting">rewrite</a> the log in the background when it gets too big.</li>
<li><strong>No persistence</strong>: If you wish, you can disable persistence completely, if you want your data to just exist as long as the server is running.</li>
<li><strong>RDB + AOF</strong>: It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</li>
</ul>
<h3 id="rdb-snapshot"><a class="header" href="#rdb-snapshot">RDB-snapshot</a></h3>
<p>Полный слепок всех данных. Устанавливается с помощью конфигурации SAVE X Y и читается как «Сохранять полный снепшот всех данных каждые X секунд, если изменилось хотя бы Y ключей». Самый простой способ делать резервные копии данных. Благодаря сжатию, которые можно включить в конфиге, занимает гораздо меньше места, чем на диске AOF. Представляет собой единый файл, который обновляется периодически автоматически, если в конфиге указан параметр <code>SAVE</code>, или при необходимости с помощью команд <code>SAVE</code> или <code>BGSAVE</code>. </p>
<p><strong>RDB</strong> — это очень компактное однофайловое представление ваших данных Redis на определенный момент времени. Файлы RDB идеально подходят для резервного копирования. Например, вы можете захотеть архивировать файлы RDB каждый час в течение последних 24 часов и сохранять моментальный снимок RDB каждый день в течение 30 дней. Это позволяет легко восстанавливать разные версии набора данных в случае аварий.</p>
<p>RDB максимизирует производительность Redis, поскольку единственная работа, которую должен выполнить родительский процесс Redis для сохранения, — это разветвление дочернего процесса, который сделает все остальное. Родительский процесс никогда не будет выполнять дисковый ввод-вывод или что-то подобное.</p>
<p><strong>RDB</strong> позволяет быстрее перезапускать большие наборы данных по сравнению с AOF. </p>
<p>На репликах <strong>RDB</strong> поддерживает частичную повторную синхронизацию после перезапуска и отработки отказа.</p>
<p><strong>Минусы</strong></p>
<p><strong>RDB</strong> НЕ подходит, если вам нужно свести к минимуму вероятность потери данных в случае, если Redis перестанет работать (например, после отключения электроэнергии). Вы можете настроить различные точки сохранения, в которых создается RDB (например, после как минимум пяти минут и 100 операций записи в набор данных у вас может быть несколько точек сохранения). Однако вы обычно создаете моментальный снимок RDB каждые пять минут или чаще, поэтому в случае, если Redis перестанет работать без корректного завершения работы по какой-либо причине, вы должны быть готовы потерять последние минуты данных. </p>
<p><strong>RDB</strong> необходимо часто выполнять <code>fork()</code>, чтобы сохраняться на диске с помощью дочернего процесса. fork() может занимать много времени, если набор данных большой, и может привести к тому, что Redis перестанет обслуживать клиентов на несколько миллисекунд или даже на одну секунду, если набор данных очень большой, а производительность процессора невысокая. AOF также нуждается в fork(), но реже, и вы можете настроить, как часто вы хотите переписывать свои журналы без какого-либо компромисса в отношении долговечности.</p>
<h3 id="appendonlyfile"><a class="header" href="#appendonlyfile">AppendOnlyFile</a></h3>
<p>список операций в порядке их выполнения. Добавляет новые пришедшие операции в файл каждые Х секунд или каждые Y операций. Для AOF можно настроить политики <code>fsync</code>: каждую секунду, на каждый запрос или вообще ничего не делать. Благодаря тому, что при использовании AOF Redis по умолчанию пишет данные на диск каждую секунду, максимум, что вы теряете в случае сбоя при использовании этого режима — это 1 секунда. Redis может автоматически перезаписывать AOF-файл, если он становится слишком большим. Но у AOF тоже есть недостатки.</p>
<p>Обычно файлы AOF гораздо больше по размеру, чем аналогичный файл RDB, при том же наборе данных. AOF может быть медленнее, чем RDB на запись, в зависимости от настроек <code>fsync</code>. Кроме того, даже в случае большой нагрузки на запись RDB лучше ведет себя в плане задержек.</p>
<h3 id="rdb-aof"><a class="header" href="#rdb-aof">RDB +<strong>AOF</strong></a></h3>
<p>Комбинация двух предыдущих.</p>
<p>В любом случае Redis — не высоконадежное хранилище данных, а быстрая легкая база для данных, которые нестрашно потерять.</p>
<h2 id="ttl"><a class="header" href="#ttl">TTL</a></h2>
<p>Redis позволяет назначать ключам срок существования. Вы можете использовать абсолютные значения времени в формате Unix (Unix timestamp, количество секунд, прошедших с 1 января 1970 года) или оставшееся время существования в секундах. Эта команда оперирует ключами, поэтому неважно, какая структура данных при этом
используется.</p>
<pre><code>expire pages:about 30
expireat pages:about 1356933600
</code></pre>
<p>Первая команда удалит ключ (и ассоциированное с ним значение) по истечении 30 секунд.
Вторая сделает то же самое в 12:00, 31 декабря 2012 года</p>
<p>По умолчанию все данные хранятся вечно.</p>
<h2 id="Транзакции-1"><a class="header" href="#Транзакции-1">Транзакции</a></h2>
<p>Как и все остальное, реализованы просто и обеспечивают атомарное выполнение набора команд. Изоляции нет, но в Redis она и не нужна, так как Redis — однопоточное приложение, и транзакции не выполняются параллельно.</p>
<h2 id="Репликация"><a class="header" href="#Репликация">Репликация</a></h2>
<p>Реализована как master-slave: на мастер можно писать и читать, слейвы — только чтение. Настраивается легко, работает безотказно. Репликация с несколькими главными серверами не поддерживается. Каждый подчиненный сервер может выступать в роли главного для других. Репликация в Redis не приводит к блокировкам ни на главном сервере, ни на подчиненных. На репликах разрешена операция записи. Когда главный и подчиненный сервер восстанавливают соединение после разрыва, происходит полная синхронизация (resync). </p>
<p>Redis поддерживает репликацию, которая означает, что все данные, которые попадают на один узел Redis (который называется master) будут попадать также и на другие узлы (называются slave). Для конфигурирования slave-узлов можно изменить опцию slaveof или выполнить аналогичную по написанию команду (узлы, запущенные без подобных опций являются master-узлами).</p>
<h2 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h2>
<p>Позволяет клиентам подписываться на обновления ключей. На основе этого можно построить систему обмена сообщениями, например.</p>
<h2 id="redis-cluster"><a class="header" href="#redis-cluster">Redis Cluster</a></h2>
<p>Был добавлен в Redis v.3.0, и является полноценным native решением для создания и управления кластером с сегментацией и репликаций данных. Выполняет задачи управления нодами, репликации, синхронизации данных, обеспечением доступа к ним в случае выхода из строя одного или более мастеров.</p>
<ul>
<li>Несколько мастер-инстансов, у каждого один или более слейвов (до 1000).</li>
<li>Выполняет все задачи по шардингу, репликации, failover, синхронизации данных.</li>
<li>Требует как минимум 6 нод Reedis-а: три для мастеров, и три для слейвов.</li>
<li>Умеет перенаправлять запросы от клиентов на нужный мастер или слейв — но это требует поддержки кластера самими клиентами Redis.</li>
</ul>
<h3 id="Сегментация"><a class="header" href="#Сегментация">Сегментация</a></h3>
<p>Кластер не использует <a href="https://zinvapel.github.io/it/tools/2017/11/27/cache/">консистентное хеширование</a>, вместо этого используется так называемые <em>hash-slots</em>. Весь кластер имеет 16384 слотов, для вычисления хэш-слота для ключа используется формула <code>crc16(key) % 16384</code>. Каждый узел Redis отвечает за конкретное подмножество хэш-слотов, например:</p>
<ul>
<li>Узел A содержит хеш-слоты от 0 до 5500.</li>
<li>Узел B содержит хеш-слоты от 5501 до 11000.</li>
<li>Узел C содержит хеш-слоты от 11001 до 16383.</li>
</ul>
<p>Это позволяет легко добавлять и удалять узлы кластера. Если мы добавляем узел D, то можно просто переместить некоторые хеш-лоты других узлов. Если же удаляем A, то нам необходимо постепенно переместить все хэш-слоты узла А на другие, а когда хэш-слотов не останется, то просто удалить узел из кластера. Всё это выполняется постепенно командами, нам не нужно приостанавливать выполнение операций, не нужно пересчитывать процентное соотношение хеш-слотов к количеству узлов, никаких прочих остановок системы.</p>
<p>Возникает вопрос - Redis имеет сложные структуры данных с составными ключами, ведь хэш-функция посчитает для них разные значения? Имеется и ответ:</p>
<ul>
<li>Составные ключи одной команды, одной транзакции или одного скрипта Lua, гарантировано попадут в один хэш-слот.</li>
<li>Пользователь может принудительно сделать составные ключи частью одного хэш слота с помощью концепта <em>хэш-тегов</em>.</li>
</ul>
<p>Если вкратце, то хэш-теги говорят Redis что именно хешировать, цель хэширования задается в фигурных скобках. Так, хэши этих ключей будут равны - <code>foo.{key}.bar</code> и <code>baz.{key}.biz</code>.</p>
<h3 id="Репликация-1"><a class="header" href="#Репликация-1">Репликация</a></h3>
<p>Каждый хэш-слот имеет от 1 (master) до N (N-1 slave) реплик. Таким образом, если выйдет из строя некоторый слот, то кластер назначит его slave master-ом.</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://habr.com/company/oleg-bunin/blog/316652/">Использование memcached и Redis в высоконагруженных проектах</a></li>
<li><a href="https://habr.com/post/320902/">Как мы Redis Cluster готовили</a></li>
<li><a href="https://habr.com/ru/company/citymobil/blog/515620/">О переезде с Redis на Redis-cluster</a></li>
<li><a href="https://stackoverflow.com/questions/10558465/memcached-vs-redis">Memcached vs Redis</a></li>
<li><a href="https://habr.com/company/mailru/blog/352760/">Сравниваем Tarantool с Redis и Memcached</a></li>
<li><a href="https://zinvapel.github.io/it/tools/2018/03/25/redis-cluster/">Redis Cluster</a></li>
<li><a href="https://redis.io/topics/persistence">Redis Persistence</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memcached"><a class="header" href="#memcached">Memcached</a></h1>
<p><a href="http://code.google.com/p/memcached/">Memcached</a> представляет собой сервер, хранящий в оперативной памяти некоторые данные с заданным временем жизни. Доступ к данным осуществляется по ключу (имени). Вы можете думать о Memcached, как о <a href="https://eax.me/hash-tables/">хэш-таблице</a>, хранящейся на сервере. Применяется он в основном для кэширования кода веб-страниц, результатов запросов к базе данных и тп.</p>
<p>Также ничто не мешает использовать Memcached в качестве «не очень надежного» key-value хранилища. Например, в нем можно хранить сессии пользователей, коды капч или счетчик посетителей, находящихся в данный момент на сайте.</p>
<p>Коротко о главном:</p>
<ul>
<li>Умеет только key =&gt; value in memory</li>
<li>Вытеснение. Когда Memcache доходит до ограничения в памяти, он начинает удалять объекты по принципу <a href="https://ruhighload.com/%d0%9a%d1%8d%d1%88%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5+%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d1%85#lru">LRU</a>(Least Recently Used). Memcache постарается удалить прежде всего те данные, которые запрашивались очень давно (т.е. менее популярные удалит, а более популярные оставит).</li>
<li>Шардинг из коробки(достаточно просто добавлять сервера, вся работа будет инкапсулирована в него)</li>
<li>Максимальная длина ключа по умолчанию составляет 250 байт, а длина значения — 1 Мб;</li>
<li><a href="https://eax.me/memcached/#comment-432394490">Будьте осторожнее со спец-символами</a>;</li>
<li>Ключи можно «расширить», воспользовавшись каким-нибудь MD5 или SHA512 (в этом случае нехэшированный ключ будет разумно продублировать в значении);</li>
<li>Если хочется хранить очень длинные значения, можно сжимать их и/или разбивать на части;</li>
<li>Весь ввод-вывод осуществляется с помощью <a href="https://eax.me/libevent/">libevent</a>;</li>
<li>Для ускорения работы память выделяется при запуске демона и не освобождается до его остановки;</li>
<li>Для борьбы с фрагментацией памяти используется <a href="http://ru.wikipedia.org/wiki/Slab">slab allocator</a>;</li>
<li>Все операции являются атомарными, есть поддержка <a href="http://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC">compare-and-swap</a>;</li>
<li>С Memcached можно работать по UDP;</li>
<li>Помимо текстового протокола <a href="http://code.google.com/p/memcached/wiki/BinaryProtocolRevamped">также существует бинарный</a>;</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://zinvapel.github.io/it/tools/2017/11/27/cache/">Кэширование и Memcached</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarantool"><a class="header" href="#tarantool">Tarantool</a></h1>
<p>Tarantool представляет собой решение, совмещающее неблокирующий сервер приложений на Lua с NoSQL базой данных. Высокой производительности позволяет достичь стек технологий, который использует тарантул:</p>
<ul>
<li>libev, libcoro и libeio для реализации event-loop'а, кооперативной многозадачности (coroutines/fibers) и асинхронной работы с сетью и другими задачами.</li>
<li>LuaJIT — Трассирующий JIT-компилятор для Lua (на стероидах).</li>
</ul>
<h3 id="Особенности-хранилища"><a class="header" href="#Особенности-хранилища">Особенности хранилища</a></h3>
<p>Базовым элементом хранения является кортеж. Кортеж имеет любую размерность, это просто произвольно длинный список полей, ассоциированный с уникальным ключом. Каждый кортеж принадлежит какому-то пространству (space). По полям кортежа можно определять индексы. Если проводить аналогии с реляционными СУБД, то &quot;пространство&quot; соответствует таблице, а &quot;поля&quot; соответствуют столбцам.</p>
<ol>
<li>Несколько движков хранения данных:
<ul>
<li>Memtx — движок хранения данных полностью в памяти, с поддержкой нескольких видов индексов:
<ul>
<li>TREE (B+*-Дерево) — для быстрого поиска значений и возможности интегрирования.</li>
<li>HASH (Хеш-таблица) — для еще более быстрого поиска значений.</li>
<li>BITSET (Битовая маска) — возможность поиска по битовым маскам.</li>
<li>RTREE (многомерное R*-Дерево) — для быстрого поиска ближайших соседей (KNN) и точек в заданных многомерных параллелепипедах с заданными функциями расстояния между двумя точками.</li>
</ul>
</li>
<li>Sophia — двухуровневый движок хранения информации на диске, который был разработан в ответ на &quot;недостатки&quot; в LSM-деревьях, B-Деревьях и других. Он прекрасно подходит для нагрузки типа &quot;много записи данных среднего размера и немного чтений&quot;, но расчёт идёт также на то, что чтение не будет занимать много времени.</li>
</ul>
</li>
<li>Возможность поддерживать &quot;персистентность&quot; с помощью xlog (также известный как Transaction Log), snap (который, в свою очередь, является полным снимком БД) и eventual-consistency (консистетность в конечном счёте) master-master репликации.</li>
<li>Поддержка вторичных ключей и составных ключей.</li>
<li>Аутентификация и привилегии для пользователей и ролей.</li>
<li>MessagePack в качестве протокола для связи клиента с сервером и хранения информации внутри самой базы. MessagePack обеспечивает упаковку некоторых данных, что позволяет снизить трафик, передаваемый по сети, и размер занимаемой памяти в самом хранилище.</li>
<li>Поддержка транзакций и мультиверсионности индексов.</li>
</ol>
<h3 id="Характеристика-сервера-приложений"><a class="header" href="#Характеристика-сервера-приложений">Характеристика сервера приложений</a></h3>
<p>Язык Lua прекрасно подходит для написания бизнес-логики вашего приложения и прост в освоении, а благодаря трассирующей JIT компиляции можно добиться существенной производительности. Также есть возможность писать модули приложения на языке C/C++.</p>
<p>Из встроенных библиотек есть возможность работы с YAML, JSON и CSV; имеется возможность для работы с неблокирующим дисковым/сетевым вводом-выводом, работой с UUID, алгоритмами хешированиями, упаковкой-распаковкой данных с заданной схемой и другое.</p>
<p>Имеется возможность связывать Tarantool'ы в кластера с помощью модуля 'net.box'. В качестве примера можно использовать модуль '<a href="https://github.com/tarantool/shard">sharding</a>', который реализует шардинг на стороне сервера и '<a href="https://github.com/tarantool/connection-pool">connection-pool</a>'.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">MongoDb</a></h1>
<p><strong>MongoDB</strong> — документоориентированная система управления базами данных (СУБД) с открытым исходным кодом, не требующая описания схемы таблиц. Классифицирована как NoSQL, использует JSON-подобные документы и схему базы данных. Написана на языке C++.</p>
<h3 id="Формат-данных-в-mongodb"><a class="header" href="#Формат-данных-в-mongodb">Формат данных в MongoDB</a></h3>
<p>Одним из популярных стандартов обмена данными и их хранения является JSON (JavaScript Object Notation). JSON эффективно описывает сложные по структуре данные. Способ хранения данных в MongoDB в этом плане похож на JSON, хотя формально JSON не используется. Для хранения в MongoDB применяется формат, который называется <strong>BSON</strong> (БиСон) или сокращение от binary JSON.</p>
<p>BSON позволяет работать с данными быстрее: быстрее выполняется поиск и обработка. Хотя надо отметить, что BSON в отличие от хранения данных в формате JSON имеет небольшой недостаток: в целом данные в JSON-формате занимают меньше места, чем в формате BSON, с другой стороны, данный недостаток с лихвой окупается скоростью.</p>
<h3 id="Документы-вместо-строк"><a class="header" href="#Документы-вместо-строк">Документы вместо строк</a></h3>
<p>Если реляционные базы данных хранят строки, то MongoDB хранит документы. В отличие от строк документы могут хранить сложную по структуре информацию. Документ можно представить как хранилище ключей и значений.</p>
<p>Ключ представляет простую метку, с которым ассоциировано определенный кусок данных.</p>
<p>Однако при всех различиях есть одна особенность, которая сближает MongoDB и реляционные базы данных. В реляционных СУБД встречается такое понятие как первичный ключ. Это понятие описывает некий столбец, который имеет уникальные значения. В MongoDB для каждого документа имеется уникальный идентификатор, который называется <code>_id</code>. И если явным образом не указать его значение, то MongoDB автоматически сгенерирует для него значение.</p>
<p>Каждому ключу сопоставляется определенное значение. Но здесь также надо учитывать одну особенность: если в реляционных базах есть четко очерченная структура, где есть поля, и если какое-то поле не имеет значение, ему (в зависимости от настроек конкретной бд) можно присвоить значение <code>NULL</code>. В MongoDB все иначе. Если какому-то ключу не сопоставлено значение, то этот ключ просто опускается в документе и не употребляется.</p>
<h3 id="Коллекции"><a class="header" href="#Коллекции">Коллекции</a></h3>
<p>Если в традиционном мире SQL есть таблицы, то в мире MongoDB есть коллекции. И если в реляционных БД таблицы хранят однотипные жестко структурированные объекты, то в коллекции могут содержать самые разные объекты, имеющие различную структуру и различный набор свойств.</p>
<h3 id="Репликация-2"><a class="header" href="#Репликация-2">Репликация</a></h3>
<p>Система хранения данных в MongoDB представляет набор реплик. В этом наборе есть основной узел, а также может быть набор вторичных узлов. Все вторичные узлы сохраняют целостность и автоматически обновляются вместе с обновлением главного узла. И если основной узел по каким-то причинам выходит из строя, то один из вторичных узлов становится главным.</p>
<h3 id="Простота-в-использовании"><a class="header" href="#Простота-в-использовании">Простота в использовании</a></h3>
<p>Отсутствие жесткой схемы базы данных и в связи с этим потребности при малейшем изменении концепции хранения данных пересоздавать эту схему значительно облегчают работу с базами данных MongoDB и дальнейшим их масштабированием. Кроме того, экономится время разработчиков. Им больше не надо думать о пересоздании базы данных и тратить время на построение сложных запросов.</p>
<h3 id="gridfs"><a class="header" href="#gridfs">GridFS</a></h3>
<p>Одной из проблем при работе с любыми системами баз данных является сохранение данных большого размера. Можно сохранять данные в файлах, используя различные языки программирования. Некоторые СУБД предлагают специальные типы данных для хранения бинарных данных в БД (например, BLOB в MySQL).</p>
<p>В отличие от реляционных СУБД MongoDB позволяет сохранять различные документы с различным набором данных, однако при этом размер документа ограничивается 16 мб. Но MongoDB предлагает решение - специальную технологию <strong>GridFS</strong>, которая позволяет хранить данные по размеру больше, чем 16 мб.</p>
<p>Система GridFS состоит из двух коллекций. В первой коллекции, которая называется <code>files</code>, хранятся имена файлов, а также их метаданные, например, размер. А в другой коллекции, которая называется <code>chunks</code>, в виде небольших сегментов хранятся данные файлов, обычно сегментами по 256 кб.</p>
<p>Для тестирования GridFS можно использовать специальную утилиту <strong>mongofiles</strong>, которая идет в пакете mongodb.</p>
<h1 id="-1"><a class="header" href="#-1"></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<h2 id="Колоночные-БД"><a class="header" href="#Колоночные-БД">Колоночные БД</a></h2>
<p>С выполнением SQL запросов на больших объемах данных стандартные СУБД справляются все хуже, т.к. объемы данных все растут и растут. На таблицах с парой десятков тысяч записей уже нужно создавать <a href="https://ruhighload.com/%d0%98%d0%bd%d0%b4%d0%b5%d0%ba%d1%81%d1%8b+%d0%b2+mysql">индексы</a>, чтобы получить приемлемую производительность. Не говоря уже о том, что добавить или удалить колонку в большую таблицу практически невозможно и это требует специальных техник. </p>
<p>Колоночные базы данных адресуют две проблемы — скорость сложных запросов на больших объемах и изменение структуры таблиц с данными.</p>
<p>Колоночные базы данных позволяют эффективно делать сложные выборки на больших таблицах. Изменение структуры больших таблиц происходит мгновенно, а сжатие данных позволяет сэкономить кучу места. Однако не следует использовать колоночные базы для случаев с обычными выборками по ключу и известными структурами запросов. Для этого лучше подойдут обычные (строчные) СУБД.</p>
<p>Колоночные базы так и называются потому, что хранят данные не в строках, а в колонках. Каждая колонка — это как бы отдельная таблица из одной колонки, которая хранит только свои значения. И значения primary key.</p>
<p>Классические БД - <strong>OLTP</strong> (Online Transaction Processing) — обработка транзакций в реальном времени. Способ организации БД, при котором система работает с небольшими по размерам транзакциями, но идущими большим потоком, и при этом клиенту требуется от системы максимально быстрое время ответа. </p>
<p>А колоночные - <strong>OLAP</strong> (англ. online analytical processing, аналитическая обработка в реальном времени) — технология обработки информации, включающая составление и динамическую публикацию отчётов и документов. Используется аналитиками для быстрой обработки сложных запросов к базе данных. Служит для подготовки бизнес-отчётов по продажам, маркетингу, в целях управления, т. н. data mining — добыча данных (способ анализа информации в базе данных с целью отыскания аномалий и трендов без выяснения смыслового значения записей).</p>
<p>OLAP делает мгновенный снимок реляционной БД и структурирует её в пространственную модель для запросов. Заявленное время обработки запросов в OLAP составляет около 0,1 % от аналогичных запросов в реляционную БД.</p>
<p>OLAP-структура, созданная из рабочих данных, называется OLAP-куб. Куб создаётся из соединения таблиц с применением схемы звезды или схемы снежинки. В центре схемы звезды находится таблица фактов, которая содержит ключевые факты, по которым делаются запросы. Множественные таблицы с измерениями присоединены к таблице фактов. Эти таблицы показывают, как могут анализироваться агрегированные реляционные данные. Количество возможных агрегаций определяется количеством способов, которыми первоначальные данные могут быть иерархически отображены.</p>
<h2 id="Когда-использовать"><a class="header" href="#Когда-использовать">Когда использовать</a></h2>
<p>Адресуемые проблемы колоночных баз данных очень тесно связаны с аналитическими и Big Data системами. Соответственно применять колоночные базы лучше всего на таких таблицах:</p>
<ul>
<li>Событийные таблицы, над которыми выполняются сложные выборки (агрегации, фильтры, сортировки). Например, добавление товаров в корзину в Интернет магазине.</li>
<li>Агрегатные таблицы с большим количеством данных для аналитических выборок. Это часто таблицы, которые строятся из событийных таблицы. Это может быть таблицы со статистикой добавления товаров в корзину по дням, категориям, ценам и другим параметрам.</li>
</ul>
<p>Однако обычные строчные базы данных остаются лучшим решением для продуктовых задач:</p>
<ul>
<li>Таблицы с доступом по ключу (id) — пользователи, товары, комментарии.</li>
<li>Таблицы с заранее известной структурой запросов. Например, мы знаем, что будем делать выборку из таблицы статей, сортируя их по дате.</li>
</ul>
<h2 id="clickhouse-1"><a class="header" href="#clickhouse-1">ClickHouse</a></h2>
<p>Ключевым преимуществом Кликхаус считается <strong>высокая скорость выполнения</strong> <strong>SQL-запросов</strong> на чтение (<strong>OLAP</strong>-сценарий), которая обеспечивается благодаря следующим архитектурным особенностям <strong>[1]</strong>:</p>
<ul>
<li><strong>столбцовое хранение данных</strong>, что позволяет считывать данные только из нужных колонок и эффективно сжимать однотипную информацию;</li>
<li><strong>физическая сортировка данных по первичному ключу</strong> позволяет быстро получать конкретные значения или диапазонов;</li>
<li><strong>векторные вычисления</strong> по кусочкам столбцов снижают издержки на диспетчеризацию и позволяют более эффективно использовать CPU;</li>
<li><strong>Линейно масштабируется</strong>, если шардировать и использовать distributed таблицы.</li>
<li><strong>распараллеливание операций</strong> как в пределах одного сервера на несколько процессорных ядер, так и в рамках распределенных вычислений на кластере за счет механизма шардирования;</li>
<li><strong>поддержка приближенных вычислений</strong> на части выборки, что снижает число обращений к жесткому диску и еще больше повышает скорость обработки данных.</li>
<li>Плохо подходит для <strong>OLTP</strong>, потому что транзакций нет. Key-Value, потому что у нас разреженный индекс. Если вам нужна одна строчка, то вы много чего лишнего прочитаете. И если у вас Key-Value с большими blob, то это вообще будет плохо работать.</li>
<li>Отказоустойчивая, если использовать replicate таблицы.</li>
</ul>
<p>Стоит отметить, что в отличие от других популярных столбцовых СУБД для Big Data, например, SAP HANA и Google PowerDrill, которые работают только в оперативной памяти, ClickHouse работает с жесткими дисками. Это снижает <strong>стоимость эксплуатации системы</strong>, поскольку жесткие диски дешевле RAM.</p>
<p>При работе в кластере данные реплицируются асинхронно в фоновом режиме с поддержкой полной идентичности на разных репликах. Apache <a href="https://www.bigdataschool.ru/wiki/zookeeper">ZooKeeper</a> используется для координации процесса репликации, но не участвует в обработке данных и выполнения запросов. При сбое в большинстве случаев восстановление данных происходит автоматически. По желанию можно включить кворумную запись данных. Кластер Кликхаус масштабируется линейно путем добавления новых узлов. ClickHouse поддерживает диалект SQL c расширениями, такими как массивы и вложенные структуры данных, вероятностные структуры, возможность подключить внешнее key-value хранилище. Еще СУБД содержит множество возможностей интеграции с другими Big Data системами, такими как Apache <a href="https://www.bigdataschool.ru/wiki/kafka">Kafka</a> и <a href="https://www.bigdataschool.ru/wiki/hdfs">HDFS</a>, а также MySQL и прочие внешние источники данных через ODBC или JDBC.</p>
<p>При том, что Кликхаус является реляционной СУБД, он не поддерживает транзакции, а также точечные операции UPDATE и DELETE. Кроме того, в данной системе отсутствуют оконные функции и полноценный оптимизатор запросов.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>
<p><a href="https://habr.com/ru/post/509540/">Что нужно знать об архитектуре ClickHouse, чтобы его эффективно использовать</a></p>
</li>
<li>
<p><a href="https://highload.today/kolonochnye-bazy-dannykh/">Колоночные БД</a></p>
</li>
<li>
<p>https://habr.com/post/95181/</p>
</li>
<li>
<p>https://habr.com/post/413051/</p>
</li>
<li>
<p>https://habr.com/post/322724/</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Брокеры-сообщений"><a class="header" href="#Брокеры-сообщений">Брокеры сообщений</a></h1>
<h2 id="Гарантии-доставки"><a class="header" href="#Гарантии-доставки">Гарантии доставки</a></h2>
<ul>
<li>At-most-once delivery (“как максимум однократная доставка”). Это значит, что сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.</li>
<li>At-least-once delivery (“как минимум однократная доставка”). Это значит, что сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза.</li>
<li>Exactly-once delivery (“строго однократная доставка”). Святой грааль систем сообщений. Все сообщения доставляются строго единожды.</li>
</ul>
<ul>
<li><a href="db/specific/messages/kafka.html">Kafka</a></li>
<li><a href="db/specific/messages/rabbit.html">Rabbit</a></li>
<li><a href="db/specific/messages/nats.html">Nats</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rabbitmq"><a class="header" href="#rabbitmq">RabbitMQ</a></h1>
<img src="db/specific/messages/../../../media/db/specific/messages/rabbit.jpg" width="80%"/>
<p><strong>RabbitMQ</strong> — это распределенная система управления очередью сообщений. Распределенная, поскольку обычно работает как кластер узлов, где очереди распределяются по узлам и, опционально, реплицируются в целях устойчивости к ошибкам и высокой доступности. Штатно, она реализует AMQP 0.9.1 и предлагает другие протоколы, такие как STOMP, MQTT и HTTP через дополнительные модули.</p>
<p>RabbitMQ использует как классический, так и новаторский подходы к обмену сообщениями. Классический в том смысле, что она ориентирована на очередь сообщений, а новаторский — в возможности гибкой маршрутизации. Именно эта возможность маршрутизации является ее уникальным преимуществом. Создание быстрой, масштабируемой и надежной распределенной системы сообщений само по себе является достижением, но функциональность маршрутизации сообщений делает ее действительно выдающейся среди множества технологий обмена сообщениями.</p>
<h3 id="exchangeи-и-очереди"><a class="header" href="#exchangeи-и-очереди">Exchange'и и очереди</a></h3>
<p>Супер-упрощенный обзор:</p>
<ul>
<li>Паблишеры (publishers) отправляют сообщения на exchange’и</li>
<li>Exchange’и отправляют сообщения в очереди и в другие exchange’и</li>
<li>RabbitMQ отправляет подтверждения паблишерам при получении сообщения</li>
<li>Получатели (consumers) поддерживают постоянные TCP-соединения с RabbitMQ и объявляют, какую очередь(-и) они получают</li>
<li>RabbitMQ проталкивает (push) сообщения получателям</li>
<li>Получатели отправляют подтверждения успеха/ошибки</li>
<li>После успешного получения, сообщения удаляются из очередей</li>
</ul>
<h3 id="Гарантии-доставки-1"><a class="header" href="#Гарантии-доставки-1">Гарантии доставки</a></h3>
<p>RabbitMQ предоставляет надёжные, долговременные гарантии обмена сообщениями, но есть много ситуаций, когда они не помогут. Вот список моментов, которые следует запомнить:</p>
<ul>
<li>Следует применять зеркалирование очередей, надёжные очереди, устойчивые сообщения, подтверждения для отправителя, флаг подтверждения и принудительное уведомление от получателя, если требуются надёжные гарантии в стратегии “как минимум однократная доставка”.</li>
<li>Если отправка производится в рамках стратегии “как минимум однократная доставка”, может потребоваться добавить механизм дедубликации или идемпотентности при дублировании отправляемых данных.</li>
<li>Если вопрос потери сообщений не так важен, как вопрос скорости доставки и высокой масштабируемости, то подумайте о системах без резервирования, без устойчивых сообщений и без подтверждений на стороне источника. Я всё же предпочел бы оставить принудительные уведомления от получателя, чтобы контролировать поток принимаемых сообщений путем изменения ограничений предвыборки. При этом вам потребуется отправлять уведомления пакетами и использовать флаг “multiple”.</li>
</ul>
<p><em>Дополнительно:</em></p>
<ol>
<li>https://habr.com/post/149694/</li>
<li>https://habr.com/post/150134/</li>
<li>https://habr.com/post/200870/</li>
<li>https://habr.com/post/201096/</li>
<li>https://habr.com/post/201178/</li>
<li>https://habr.com/post/236221/</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apache-kafka"><a class="header" href="#apache-kafka">Apache Kafka</a></h1>
<img src="db/specific/messages/../../../media/db/specific/messages/kafka.jpg" width="80%"/>
<p>Kafka — это распределенный реплицированный журнал фиксации изменений (commit log). У Kafka’и нет концепции очередей, что сначала может показаться странным, учитывая, что его используют в качестве системы обмена сообщениями. Очереди долгое время были синонимом систем обмена сообщениями. Давайте для начала разберемся, что значит «распределенный, реплицированный журнал фиксации изменений»:</p>
<ul>
<li>Распределенный, поскольку Kafka развертывается как кластер узлов, как для устойчивости к ошибкам, так и для масштабирования</li>
<li>Реплицированный, поскольку сообщения обычно реплицируются на нескольких узлах (серверах).</li>
<li>Журнал фиксации изменений, потому что сообщения хранятся в сегментированных, append-only журналах, которые называются топиками. Эта концепция журналирования является основным уникальным преимуществом Kafka’и.</li>
</ul>
<h2 id="Терминология-1"><a class="header" href="#Терминология-1">Терминология</a></h2>
<ul>
<li>Тема (Topic)</li>
<li>Партиция</li>
<li>Подписчики (consumer)</li>
<li>Издатель (producer)</li>
<li>Группа (group), раздел (partition)</li>
<li>Потоки (streams)</li>
</ul>
<p>Понимание журнала (и топика) и партиций являются ключом к пониманию Kafka’и. Итак, чем партиционированный журнал отличается от набора очередей? Давайте представим, как это выглядит.</p>
<p><img src="db/specific/messages/../../../media/kaffka.png" alt="" /></p>
<p>Вместо того чтобы помещать сообщения в очередь FIFO и отслеживать статус этого сообщения в очереди, как это делает RabbitMQ, Kafka просто добавляет его в журнал, и на этом все.</p>
<p>Сообщение остается, вне зависимости от того, будет ли оно получено один или несколько раз. Удаляется оно в соответствии с политикой удерживания данных (retention policy, также называемый window time period). Каким же образом информация забирается из топика?</p>
<p>Каждый получатель отслеживает, где она находится в журнале: имеется указатель на последнее полученное сообщение и этот указатель называется адресом смещения. Получатели поддерживают этот адрес через клиентские библиотеки, и в зависимости от версии Kafka адрес сохраняется либо в ZooKeeper, либо в самой Kafka’е.</p>
<p>Отличительная особенность модели журналирования в том, что она мгновенно устраняет множество сложностей, касающихся состояния доставки сообщений и, что более важно для получателей, позволяет им перематывать назад, возвращаться и получать сообщения по предыдущему относительному адресу. Например, представьте, что вы разворачиваете сервис, который выставляет счета, учитывающие заказы, размещаемые клиентами. У службы случилась ошибка, и она неправильно рассчитывает все счета за 24 часа. С RabbitMQ в лучшем случае вам нужно будет как-то переопубликовать эти заказы только на сервисе счетов. Но с Kafka вы просто перемещаете относительный адрес для этого получателя на 24 часа назад.</p>
<p>Каждая партиция представляет собой отдельный файл, в котором гарантируется очередность сообщений. Это важно помнить: порядок сообщений гарантируется только в одной партиции. В дальнейшем это может привести к некоторому противоречию между потребностями в очередности сообщений и потребностями в производительности, поскольку производительность в Kafka также масштабируется партициями. Партиция не может поддерживать конкурирующих получателей, блок параллельности Kafka — это сама партиция. Поэтому, если нам нужны три получателя счетов, нам нужно как минимум три партиции(1 воркер на 1 партицию).</p>
<p>В Kafka соблюдается принцип «тупой брокер – умный потребитель». Таким образом, Kafka не отслеживает, какие записи считываются потребителем и после этого удаляются, а просто хранит их в течение заданного периода времени (например, суток), либо до тех пор, пока не будет достигнут некоторый порог. Потребители сами опрашивают Kafka, не появилось ли у него новых сообщений, и указывают, какие записи им нужно прочесть. Таким образом, они могут увеличивать или уменьшать смещение, переходя к нужной записи; при этом события могут переигрываться или повторно обрабатываться.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/company/itsumma/blog/416629/">RabbitMQ против Kafka</a></li>
<li><a href="https://habr.com/ru/company/itsumma/blog/418389/">RabbitMQ против Kafka: применение Kafka в событийно ориентированных приложениях</a></li>
<li><a href="https://habr.com/ru/company/itsumma/blog/437446/">Apache Kafka и RabbitMQ: семантика и гарантия доставки сообщений</a></li>
<li><a href="https://habr.com/post/354486/">Apache Kafka – мой конспект</a></li>
<li><a href="https://habr.com/ru/company/piter/blog/352978/">Apache Kafka: обзор</a></li>
<li>https://stackoverflow.com/questions/38024514/understanding-kafka-topics-and-partitions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nats"><a class="header" href="#nats">Nats</a></h1>
<img src="db/specific/messages/../../../media/db/specific/messages/nats.jpg" width="80%"/>
<p>NATS — относительно молодой проект, созданный Derek Collison, за плечами которого более 20 лет работы над распределенными очередями сообщений.</p>
<p>Нас покорила простота администрирования кластера NATS. Чтобы подключить новый узел, процессу NATS достаточно указать адрес любого другого узла кластера, и он мгновенно скачивает всю топологию и определяет живые/мертвые узлы. Сообщения в NATS группируются по темам, и каждый узел знает, какие узлы имеют живых подписчиков на какие темы. Все сообщения в кластере доставляются напрямую от отправителя получателю, без промежуточных шагов и с минимальной задержкой.</p>
<p>По производительности NATS опережает все очереди с “гарантированной доставкой”. NATS написан на языке Go, но имеет клиентские библиотеки для всех популярных языков. Кроме того, клиенты NATS также знают топологию кластера и способны самостоятельно переподключаться в случае потери связи со своим узлом.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Архитектура-ПО"><a class="header" href="#Архитектура-ПО">Архитектура ПО</a></h1>
<p><strong>Архитектура программного обеспечения</strong> (software architecture) — совокупность важнейших решений об организации программной системы. Также это набор ограничений для достижения определенных целей.</p>
<ul>
<li><a href="architecture/oopBase.html">Основы ООП</a></li>
<li><a href="architecture/gof.html">Паттерны GoF(Банда 4)</a></li>
<li><a href="architecture/principles.html">Принципы хорошей архитектуры</a></li>
<li><a href="architecture/architecturesPatterns.html">Архитектурные паттерны</a></li>
<li><a href="architecture/ddd.html">DDD</a></li>
<li><a href="architecture/microserices/README.html">Микросервисы</a></li>
<li><a href="architecture/uncategorized.html">Разное</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Основы-ООП"><a class="header" href="#Основы-ООП">Основы ООП</a></h2>
<p><strong>Объе́ктно-ориенти́рованное программи́рование (ООП)</strong> — методология программирования, основанная на представлении программы в виде совокупности объектов(структур данных, хранящих рядом сами данные и их поведение, т.е методы для работы с этими данными), каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.</p>
<p><strong>Инкапсуляция</strong> — это фундаментальная объектно-ориентированная концепция, позволяющая упаковывать данные и поведение в единый компонент с разделением его на обособленные части — интерфейс и реализацию. Последнее осуществляется благодаря принципу изоляции решений разработки в ПО, известному как <strong>сокрытие информации (information hiding)</strong>.</p>
<p><strong>Сокрытие информации</strong> – это сокрытие деталей проектирования, которые могут измениться в будущем, для ограничения каскадных изменений в программной системе и для упрощения ее разработки и сопровождения.</p>
<p><strong>Полиморфизм</strong> – это свойство системы использовать разные объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта(является следствием инкапсуляции).</p>
<p><strong>Наследование</strong> – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.</p>
<p><strong>Агрегирование</strong> - В объектно-ориентированном программировании под агрегированием подразумевают методику создания нового класса из уже существующих классов путём включения, называемого также делегированием. Об агрегировании также часто говорят как об «отношении принадлежности» по принципу «у машины есть корпус, колёса и двигатель».</p>
<p>Вложенные объекты нового класса обычно объявляются закрытыми, что делает их недоступными для прикладных программистов, работающих с классом. С другой стороны, создатель класса может изменять эти объекты, не нарушая при этом работы существующего клиентского кода. Кроме того, замена вложенных объектов на стадии выполнения программы позволяет динамически изменять её поведение. Механизм наследования такой гибкостью не обладает, поскольку для производных классов устанавливаются ограничения, проверяемые на стадии компиляции.</p>
<p>На базе агрегирования реализуется методика делегирования, когда поставленная перед внешним объектом задача перепоручается внутреннему объекту, специализирующемуся на решении задач такого рода.</p>
<p><strong>Агрегация (агрегирование по ссылке</strong>) — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.</p>
<p><strong>Композиция (агрегирование по значению)</strong> — более строгий вариант агрегирования, когда включаемый объект может существовать только как часть контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Паттерны-проектированияgof"><a class="header" href="#Паттерны-проектированияgof">Паттерны проектирования(GoF)</a></h1>
<p>Паттерн проектирования — это часто встречаемое решение определённой проблемы при проектировании архитектуры программ. </p>
<p>В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн
представляет собой не какой-то конкретный код, а общую концепцию или пример решения той или иной проблемы, которое нужно будет подстроить под нужды вашей программы.</p>
<p>Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. И если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах. Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж,
на котором нарисовано решение, но не конкретные шаги его получения.</p>
<p>Описания паттернов обычно формальны и чаще всего состоят из таких пунктов: </p>
<ul>
<li>проблемы, которую решает паттерн;</li>
<li>мотивации к решению проблемы способом, который предлагает паттерн;</li>
<li>структуры классов, составляющих решение;</li>
<li>примера на одном из языков программирования;</li>
<li>особенностей реализации в различных контекстах;</li>
<li>связей с другими паттернами.</li>
</ul>
<h3 id="Порождающие-creational"><a class="header" href="#Порождающие-creational">Порождающие (Creational)</a></h3>
<p>Шаблоны проектирования, которые абстрагируют процесс инстанцирования. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. </p>
<ul>
<li><strong>Factory</strong>(Фабрика) Сам по себе не является паттерном. Подход, при котором логика создания объектов выносится в отдельный класс.</li>
<li><strong>Фабричный метод</strong>(Factory Method) — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.</li>
<li><strong>Абстрактная фабрика</strong> (Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.</li>
<li><strong>Прототип</strong> (Prototype) Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип. Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.</li>
<li><strong>Строитель</strong>(Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта. Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.</li>
<li><strong>Одиночка</strong> (Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр класса с глобальной точкой доступа.</li>
</ul>
<h3 id="Структурные-structural"><a class="header" href="#Структурные-structural">Структурные (Structural)</a></h3>
<p>Определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу. Структурные шаблоны проектирования упрощают проектирование путем выявления простого способа реализовать отношения между субъектами.</p>
<ul>
<li><strong>Адаптер (Adapter)</strong> — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.</li>
<li><strong>Мост</strong> (Bridge) — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо». Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.</li>
<li><strong>Компоновщик</strong> (Composite pattern) — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково</li>
<li><strong>Декоратор</strong> (Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.</li>
<li><strong>Фасад</strong> (Facade) — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.</li>
<li><strong>Приспособленец</strong> (Flyweight, &quot;легковесный (элемент)&quot;) — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.</li>
<li><strong>Заместитель</strong> (Proxy) — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).</li>
</ul>
<h3 id="Поведенческие-behavioral"><a class="header" href="#Поведенческие-behavioral">Поведенческие (behavioral)</a></h3>
<p>Шаблоны проектирования, определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов. Поведенческие шаблоны проектирования определяют общие закономерности связей между объектами, реализующими данные паттерны. Следование этим шаблонам уменьшает связность системы и облегчает коммуникацию между объектами, что улучшает гибкость программного продукта.</p>
<ul>
<li><strong>Цепочка обязанностей</strong> (Chain of responsibility) — поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности.</li>
<li><strong>Команда (Command</strong>) — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.</li>
<li><strong>Интерпретатор (Interpreter)</strong> — поведенческий шаблон проектирования, решающий часто встречающуюся, но подверженную изменениям, задачу. Также известен как Little (Small) Language</li>
<li><strong>Итератор (iterator)</strong> — интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним. В различных системах итераторы могут иметь разные общепринятые названия. В терминах систем управления базами данных итераторы называются курсорами.</li>
<li><strong>Посредник (Mediator)</strong> — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга</li>
<li><strong>Хранитель (Memento</strong>) — поведенческий шаблон проектирования, позволяющий, не нарушая инкапсуляцию, зафиксировать и сохранить внутреннее состояние объекта так, чтобы позднее восстановить его в это состояние.</li>
<li><strong>Наблюдатель (Observer</strong>) — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.</li>
<li><strong>Состояние (State)</strong> — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.</li>
<li><strong>Стратегия (Strategy)</strong> — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.</li>
<li><strong>Шаблонный метод (Template method)</strong> — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.</li>
<li><strong>Посетитель (visitor)</strong> — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://refactoring.guru/ru/design-patterns">ПАТТЕРНЫПРОЕКТИРОВАНИЯ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Принципы-хорошей-архитектуры"><a class="header" href="#Принципы-хорошей-архитектуры">Принципы хорошей архитектуры</a></h2>
<h2 id="solid"><a class="header" href="#solid">SOLID</a></h2>
<p><strong>SOLID</strong> - мнемонический акроним, для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного(и не только) программирования и проектирования.</p>
<h3 id="Принцип-единственной-ответственности-single-responsibility"><a class="header" href="#Принцип-единственной-ответственности-single-responsibility">Принцип единственной ответственности (Single responsibility)</a></h3>
<p>Модуль должен иметь одну и только одну причину для изменения. Модуль должен отвечать за одного и только за одного актора (пользователя или заинтересованное лицо).</p>
<h3 id="Принцип-открытостизакрытости-open-closed"><a class="header" href="#Принцип-открытостизакрытости-open-closed">Принцип открытости/закрытости (Open-closed)</a></h3>
<p>Программные сущности должны быть открыты для расширения и закрыты для изменения.</p>
<p>Иными словами - мы должны иметь возможность изменить часть поведения объекта, не изменяя его исходный код. Раньше основным методом соблюдения принципы считалось наследование. Однако теперь, когда все больше разработчиков понимает, что наследование считается антипаттерном, для этой цели лучше использовать делегирование - DI или стратегию, создавая у объекта поля из интерфейсов и заполняя их в конструкторе. Таким образом мы сможем менять особенности поведения объекта предоставляя конструктору объекта разные реализации этих интерфейсов.</p>
<h3 id="Принцип-подстановки-Барбары-Лисков-liskov-substitution"><a class="header" href="#Принцип-подстановки-Барбары-Лисков-liskov-substitution">Принцип подстановки Барбары Лисков (Liskov substitution)</a></h3>
<p>Стремитесь создавать подклассы таким образом, чтобы их объекты можно было бы подставлять вместо объектов базового класса, не ломая при этом функциональности клиентского кода.</p>
<p>Принцип подстановки — это ряд проверок, которые помогают предсказать, останется ли подкласс совместим с
остальным кодом программы, который до этого успешно работал, используя объекты базового класса. Это особенно важно при разработке библиотек и фреймворков, когда ваши классы используются другими людьми, и вы не можете повлиять на чужой клиентский код, даже если бы хотели.</p>
<p>В отличие от других принципов, которые определены очень свободно и имеют массу трактовок, принцип подстановки имеет ряд формальных требований к подклассам, а точнее к переопределённым в них методах:</p>
<ul>
<li>Типы параметров метода подкласса должны совпадать или быть боле абстрактными, чем типы параметров базового метода.</li>
<li>Тип возвращаемого значения метода подкласса должен совпадать или быть подтипом возвращаемого значения базового метода.</li>
<li>Метод не должен выбрасывать исключения, которые не свойственны базовому методу</li>
<li>Метод не должен ужесточать _пред_условия</li>
<li>Метод не должен ослаблять _пост_условия.</li>
<li>Инварианты класса должны остаться без изменений</li>
</ul>
<p>Замена объектов их наследниками не должна нарушать работу программы.(У наследника - типы принимаемых параметров должны быть не уже, возвращаемых не шире + должны сохраняться инварианты).</p>
<h3 id="Принцип-разделения-интерфейса-interface-segregation"><a class="header" href="#Принцип-разделения-интерфейса-interface-segregation">Принцип разделения интерфейса (Interface segregation)</a></h3>
<p>Много специализированных интерфейсов лучше, чем один универсальный - Клиенты не должны зависеть от методов, которые они не используют.</p>
<p>Стремитесь к тому, чтобы интерфейсы были достаточно узкими, чтобы классам не приходилось реализовывать
избыточное поведение. Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.</p>
<h3 id="Принцип-инверсии-зависимостей-dependency-invertion"><a class="header" href="#Принцип-инверсии-зависимостей-dependency-invertion">Принцип инверсии зависимостей (Dependency Invertion)</a></h3>
<p>Компоненты верхних уровней не должны зависеть от компонентов нижних уровней. Оба должны зависеть от
абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций</p>
<h2 id="Предпочитайте-композицию-наследованию-класса"><a class="header" href="#Предпочитайте-композицию-наследованию-класса">Предпочитайте композицию наследованию класса</a></h2>
<p>Для решения проблемы дублирования кода есть два распространенных приема: наследование и композиция. Очевидно(правда, далеко не всем) - наследование классов может нести колоссальные проблемы, связанные с поддержкой и развитием кодовой базы, т.к. неправильное его использование может нарушить инкапсуляции, слишком жестко связав наследника с родителем. В итоге мы получим:</p>
<ul>
<li>хрупкий дизайн (изменяя код родителя, можно сломать код наследников);</li>
<li>сложность понимания работы кода (большая область видимости переменных, много ответственностей, трудность отслеживания всех возможных взаимосвязей);</li>
<li>снижается гибкость (иерархия классов задаётся жестко, поэтому комбинировать поведение различных базовых классов становится невозможно).</li>
</ul>
<p>Композиция лишена этих недостатков, и в 99% случаев будет более верным решением.</p>
<h2 id="Анемичная-модель---антипаттерн"><a class="header" href="#Анемичная-модель---антипаттерн">Анемичная модель - антипаттерн</a></h2>
<p>Предпочитайте нормальную модель бизнес логики(иногда называют Rich Domain Model), а не процедурную, анемичную модель с DTO вместо полноценных сущностей. Анемичная модель не имеет ничего общего с ООП и ее следует рассматривать как неудачный пример процедурного программирования.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://emacsway.github.io/ru/anemic-domain-model/">Про Anemic Domain Model</a> </li>
<li><a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html">AnemicDomainModel</a></li>
</ul>
<h2 id="Иммутабельность"><a class="header" href="#Иммутабельность">Иммутабельность</a></h2>
<p>Иммутабельные данные( объекты например) - те, которые нельзя изменить. Примерно как числа. Число просто есть, его нельзя поменять. Также и иммутабельный массив — он такой, каким его создали, и всегда таким будет. Если нужно добавить элемент — придется создать новый массив.</p>
<p>Преимущества неизменяемых структур:</p>
<ul>
<li>Безопасно разделять ссылку между потоками</li>
<li>Легко тестировать</li>
<li>Легко отследить жизненный цикл (соответствует data flow)</li>
<li>Легче читать и поддерживать код</li>
<li>Лучшая инкапсуляция</li>
</ul>
<p>Иммутабельность полезна в случаях, когда создаётся кусок данных (объект), который используется в нескольких местах и/или в разных потоках. Тогда вероятность того, что такой объект ВНЕЗАПНО поменяется, равна нулю. В частности, иммутабельный объект всегда потокобезопасен и реентерабелен без дополнительных усилий. В отличие от мутабельных объектов.</p>
<h2 id="Закон-Деметры"><a class="header" href="#Закон-Деметры">Закон Деметры</a></h2>
<p>Говоря упрощённо, каждый программный модуль:</p>
<ul>
<li>должен обладать ограниченным знанием о других модулях: знать о модулях, которые имеют «непосредственное» отношение к этому модулю.</li>
<li>должен взаимодействовать только с известными ему модулями «друзьями», не взаимодействовать с незнакомцами.</li>
<li>обращаться только к непосредственным «друзьям».</li>
</ul>
<p>Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать её лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.</p>
<p>Основной идеей является то, что объект должен иметь как можно меньше представления о структуре и свойствах чего угодно (включая собственные подкомпоненты).</p>
<p>Общее описание правила: <em>Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C</em>.</p>
<p>Более формально, Закон Деметры для функций требует, что метод М объекта О должен вызывать методы только следующих типов объектов:</p>
<ul>
<li>собственно самого О</li>
<li>параметров М</li>
<li>других объектов, созданных в рамках М</li>
<li>прямых компонентных объектов О</li>
<li>глобальных переменных, доступных О, в пределах М</li>
</ul>
<p>Практически, объект-клиент должен избегать вызовов методов объектов, внутренних членов, возвращенных методом объекта-сервиса.</p>
<h2 id="grasp"><a class="header" href="#grasp">GRASP</a></h2>
<p><strong>GRASP</strong> (general responsibility assignment software patterns — общие шаблоны распределения обязанностей; также существует английское слово &quot;grasp&quot; — «контроль, хватка») — шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению обязанностей классам и объектам.</p>
<p><strong>1. Информационный эксперт</strong> (Information Expert) Шаблон определяет базовый принцип распределения обязанностей:</p>
<p>Обязанность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения — информационному эксперту.</p>
<p>Этот шаблон — самый очевидный и важный из девяти. Если его не учесть — получится спагетти-код, в котором трудно разобраться.</p>
<p>Локализация же обязанностей, проводимая согласно шаблону:</p>
<ul>
<li>Повышает:</li>
<li>Инкапсуляцию;</li>
<li>Простоту восприятия;</li>
<li>Готовность компонентов к повторному использованию;</li>
<li>Снижает: степень зацеплений.</li>
</ul>
<p><strong>2. Создатель (Creator)</strong></p>
<ul>
<li>Класс должен создавать экземпляры тех классов, которые он может:</li>
<li>Содержать или агрегировать;</li>
<li>Записывать;</li>
<li>Использовать;</li>
<li>Инициализировать, имея нужные данные.</li>
</ul>
<p>Так применяется шаблон «Информационный эксперт» (смотрите пункт №1) в вопросах создания объектов.</p>
<p>Альтернатива — шаблон «Фабрика» (создание объектов концентрируется в отдельном классе).</p>
<p><strong>3. Контроллер (Controller)</strong></p>
<p>Отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление) Не выполняет работу самостоятельно, а делегирует компетентным исполнителям;</p>
<p>Может представлять собой:</p>
<ul>
<li>Систему в целом;</li>
<li>Подсистему;</li>
<li>Корневой объект;</li>
<li>Устройство.</li>
</ul>
<p><strong>4. Слабое зацепление</strong> (Low Coupling)</p>
<p>«Степень зацепления» (сопряжения[2]) — мера неотрывности элемента от других элементов (либо мера данных, имеющихся у него о них).</p>
<p>«Слабое» зацепление — распределение обязанностей и данных, обеспечивающее взаимную независимость классов. Класс со «слабым» зацеплением:</p>
<ul>
<li>Не зависит от внешних изменений;</li>
<li>Прост для повторного использования.</li>
</ul>
<p><strong>5. Высокая степень связности</strong> (High Cohesion)</p>
<p>Предметные области следует разделять по классам.</p>
<p>Связность класса — мера подобия предметных областей его методов:</p>
<p>«Высокая» степень — сфокусированные подсистемы (предметная область определена, управляема и понятна);</p>
<p>«Низкая» степень — абстрактные подсистемы. Затруднены:</p>
<ul>
<li>Восприятие;</li>
<li>Повторное использование;</li>
<li>Поддержка;</li>
<li>Устойчивость к внешним изменениям.</li>
</ul>
<p><strong>6. Полиморфизм</strong> (Polymorphism)</p>
<p>Устройство и поведение системы:</p>
<ul>
<li>Определяется данными;</li>
<li>Задано полиморфными операциями её интерфейса.</li>
</ul>
<p>Пример: Адаптация коммерческой системы к многообразию систем учёта налогов может быть обеспечена через внешний интерфейс объектов-адаптеров (смотрите также: Шаблон «Адаптеры»).</p>
<p><strong>7. Чистая выдумка</strong> (Pure Fabrication)</p>
<p>Не относится к предметной области, но:</p>
<ul>
<li>Уменьшает зацепление;</li>
<li>Повышает связность;</li>
<li>Упрощает повторное использование.</li>
</ul>
<p>«Pure Fabrication» отражает концепцию сервисов в модели проблемно-ориентированного проектирования.</p>
<p>Пример задачи: Не используя средства класса «А», внести его объекты в базу данных.</p>
<p>Решение: Создать класс «Б» для записи объектов класса «А» (смотрите также: «Data Access Object»).</p>
<p><strong>8. Посредник (Indirection)</strong></p>
<p>См. также: Посредник (шаблон проектирования)</p>
<p>Слабое зацепление между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником.</p>
<p>Пример: В архитектуре Model-View-Controller, контроллер (англ. controller) ослабляет зацепление данных (англ. model) за их представление (англ. view).</p>
<p><strong>9. Устойчивость к изменениям (Protected Variations)</strong></p>
<p>Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса.</p>
<h2 id="Признаки-плохого-проекта"><a class="header" href="#Признаки-плохого-проекта">Признаки плохого проекта</a></h2>
<ul>
<li>Закрепощённость: система с трудом поддается изменениям, поскольку любое минимальное изменение вызывает эффект &quot;снежного кома&quot;, затрагивающего другие компоненты системы.</li>
<li>Неустойчивость: в результате осуществляемых изменений система разрушается в тех местах, которые не имеют прямого отношения к непосредственно изменяемому компоненту.</li>
<li>Неподвижность: достаточно трудно разделить систему на компоненты, которые могли бы повторно использоваться в других системах.</li>
<li>Вязкость - сделать что-то правильно намного сложнее, чем выполнить какие-либо некорректные действия.</li>
<li>Неоправданная сложность: проект включает инфраструктуру, применение которой не влечёт непосредственной выгоды.</li>
<li>Неопределенность: исходный код трудно читать и понимать. Недостаточно четко выражено содержимое проекта.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Архитектурные-паттерны"><a class="header" href="#Архитектурные-паттерны">Архитектурные паттерны</a></h1>
<h2 id="onion-architecture--hexagonal-architecture"><a class="header" href="#onion-architecture--hexagonal-architecture">Onion architecture / Hexagonal Architecture</a></h2>
<p>Если мы делим код приложения на слои, то получаем слоистую архитектуру. Если применим к ней инверсию зависимости, то получим луковую. Гексагональная - это то же самое что и луковая, но с акцентом на разделение ответственностей внутри одного слоя.</p>
<p>Ниже пример &quot;классического&quot;(это не значит что он является единственно верным) способа разделения кода приложения на слои:</p>
<h3 id="domain-layer"><a class="header" href="#domain-layer">Domain layer</a></h3>
<p><strong>Domain layer</strong> — модель бизнес-логики приложения. В идеале вся бизнес логика(понятия и операции которым оперирует бизнес) должна находиться в этом слое. Задача остальных слоев, это инкапсуляция бизнес логики от объектов реального мира(бд, сети, файлов, пользователей, и т.д).</p>
<h3 id="application-layer"><a class="header" href="#application-layer">Application layer</a></h3>
<p>Слой ответственный за &quot;связь&quot; доменной модели и инфраструктурными сервисами. Никакие другие классы, кроме классов данного слоя не могут дергать объекты доменного. В терминологии Фаулера, называется service layer.</p>
<h3 id="infrastructure-layer"><a class="header" href="#infrastructure-layer">Infrastructure layer</a></h3>
<p>Инфраструктурный слой, содержащий всё необходимое для общения приложения с внешним миром(пользователями, сторонними сервисами, железом и т.д). быстро может стать очень жирным. Как я уже говорил, обычно, этот код сложен и нестабилен. Инфраструктурный код соединяет ядро нашего драгоценного приложения с:</p>
<ul>
<li>Файловой системой</li>
<li>Сетью</li>
<li>Орм</li>
<li>Фреймворком</li>
<li>Сторонними библиотеками</li>
</ul>
<p>Очень важно понимать что здесь не может быть НИКАКОЙ бизнес логики.</p>
<h3 id="presentation-layer"><a class="header" href="#presentation-layer">Presentation layer</a></h3>
<p>По сути, представляет собой подмножество слоя Infrastructure для работы с пользовательским вводом/выводом. Многие не выделяют этот слой в отдельный. Содержит в себе веб контроллеры, вьюхи, обработчики консольных команд и т.д</p>
<h2 id="command-and-query-responsibility-segregation-cqrs"><a class="header" href="#command-and-query-responsibility-segregation-cqrs">Command and Query Responsibility Segregation (CQRS)</a></h2>
<p><em><strong>CQRS</strong></em> – подход проектирования программного обеспечения, при котором код, изменяющий состояние, отделяется от кода, просто читающего это состояние. Подобное разделение может быть логическим и основываться на разных уровнях. Кроме того, оно может быть физическим и включать разные звенья (tiers), или уровни.</p>
<p>В основе этого подхода лежит принцип <strong>Command-query separation</strong> (CQS). Основная идея CQS в том, что в объекте методы могут быть двух типов:</p>
<ul>
<li><em>Commands</em>: Методы изменяют состояние объекта, не возвращая значение.</li>
<li><em>Queries</em>: Методы возвращают результат, не изменяя состояние объекта. Другими словами, у Query не никаких побочных эффектов.</li>
</ul>
<h2 id="event-driven"><a class="header" href="#event-driven">Event Driven</a></h2>
<p><strong>Архитектура, управляемая событиями</strong> (event-driven architecture, EDA) архитектура, в основе которой лежит создание, определение, потребление и реакции на события. Т.е любое изменение в системы должно выбрасывать событие, на которое могут реагировать другие части системы.</p>
<h2 id="event-sourcing"><a class="header" href="#event-sourcing">Event Sourcing</a></h2>
<p>Идея <code>Event sourcing (ES)</code>заключается в том, что любому изменению модели можно сопоставить какое-то бизнес-событие, и сохранение всех событий является достаточным для того, чтобы каждый раз заново воспроизвести то же состояние модели.</p>
<p>В качестве примера можно привести риплеи игр: любой риплей обязан как минимум хранить в каком-то виде набор событий, которые генерировали сами игроки (отправил персонажа в такую-то точку, выстрелил в такую-то, купил такой-то предмет и т.д.), а уже последствия от этих действий всегда могут быть заново вычислены при условии, что игра детерминирована, т.е. она гарантирует, что игра будет развиваться точно также, как изначально (для псевдослучайных внутриигровых событий сохраняется seed и «случайный» элемент выполняется вполне себе неслучайно). С этой точки зрения всё, что происходит в игре — это заново вычисляемое состояние, включая смерти персонажей от потери здоровья. 
Также примером может служить баланс счета на банковском аккаунте, который формируется из совокупности всех операций зачисления и снятия денег со счёта.</p>
<p>Из-за ряда особенностей данного подхода использовать его повсеместно не получится. Event Sourcing не является серебряной пулей. Его использование оправдано там, где есть вероятность множества изменений, которые надо как-то контролировать.</p>
<h4 id="Поток-событий"><a class="header" href="#Поток-событий">Поток событий</a></h4>
<p>Поток событий - это упорядоченный список событий, которые были применены в рамках агерата. Каждое новое событие увеличивает версию потока на 1.</p>
<h4 id="Проблемы"><a class="header" href="#Проблемы">Проблемы</a></h4>
<p>Существует несколько проблем данного подхода. Во-первых, это избыточность данных. Мы храним огромное кол-во ненормализованных данных (событий). Во-вторых, необходимо затратить ресурсы на конвертацию потока событий в агрегат. В-третьих, у нас нет возможности искать по каким-либо полям (ведь полей у нас нет, есть лишь сериализованное представление события)</p>
<h4 id="Снимки-snapshot"><a class="header" href="#Снимки-snapshot">Снимки (Snapshot)</a></h4>
<p>Для решения проблемы, связанной с необходимостью накладывать множество событий на агрегат используются снимки. Снимок - сериализованное представление агрегата какой-либо версии (например, 10) Когда в следующий раз мы захотим получить текущее состояние агрегата для версии 20, нам необязательно накладывать все предшествующие 20 событий. Достаточно получить снимок 10-ой версии и применить к нему недостающие события (т.е. ещё 10)</p>
<h4 id="Представления-projections"><a class="header" href="#Представления-projections">Представления (Projections)</a></h4>
<p>Эффективная работа с Event Sourcing предполагает разделение на 2 интерфейса: write model (наш агрегат) и read model (представление). Представление - это то, с чем будут работать клиенты (например, через API). Оно формируется на основании изменений и в том виде, в котором необходимо. По сути представление - это просто ключ и набор данных, которые были собраны специально под тип запроса. Данный подход позволяет полностью исключить из работы все запросы с соединениями, группировками и т.д., ибо данные уже сохранены в том виде, в котором необходимы для использования.</p>
<h4 id="Индексы-1"><a class="header" href="#Индексы-1">Индексы</a></h4>
<p>Для решения проблемы, связанной с фильтрацией данных, можно взять любое key\value хранилище для реализации маппинга. Например, нам необходимо обеспечить уникальность email пользователя. В классической Event Sourcing имплементации это если и возможно, то весьма затратно. Но можно поступить иначе: когда мы создаём пользователя, мы записываем его идентификатор и email в специальное хранилище. Когда мы будем создавать другого пользователя, мы можем проверить, используется ли у кого-либо данный email, или нет</p>
<h2 id="saga"><a class="header" href="#saga">Saga</a></h2>
<p>Шаблон “Saga” используется для моделирования long-running (Как это будет по-русски? Долгосрочные? Долгоиграющие?) бизнес-процессов. Фактически, мы можем сказать, что Saga представляет собой Workflow для какого-то определённого сценария.</p>
<p>Long-running не следует понимать в терминах секундной стрелки и задаваться вопросом: 200 миллисекунд – это long-running или нет? В системах с архитектурой, построенной на событиях и сообщениях подобные вопросы вряд ли имеют смысл.</p>
<p>Идея, которую реализует шаблон “Saga” проста: после каждого успешно выполненного шага мы имеем некоторое состояние, с которого можно будет продолжить исполнение процесса. Шагом является выполнение какого-то действия, реакция на какое-то событие и т.д. 
То есть, если мы не смогли подтвердить транзакцию в базу данных, или если вызов второго веб-сервиса завершился неудачей, у нас имеется состояние, валидное на момент до его вызова. 
Наш бизнес-процесс остановлен – это да, но он и не потерян. Мы можем предпринять какие-то действия и <em>продолжить</em> процесс. Как результат – процесс просто выполнялся дольше.</p>
<p>Кроме того, имея такое состояние, мы можем легко моделировать процессы, “управляемые” событиями!</p>
<h2 id="inversion-of-control-dependency-inversion-dependency-injection"><a class="header" href="#inversion-of-control-dependency-inversion-dependency-injection">Inversion of Control, Dependency Inversion, Dependency Injection</a></h2>
<p>Инверсия управления (<strong>IoC, Inversion of Control)</strong> – это достаточно общее понятие, которое отличает библиотеку от фреймворка. Классическая модель подразумевает, что вызывающий код контролирует внешнее окружение и время и порядок вызова библиотечных методов. Однако в случае фреймворка обязанности меняются местами: фреймворк предоставляет некоторые точки расширения, через которые он вызывает определенные методы пользовательского кода. </p>
<p>Инверсия управления в ооп, иначе инверсия зависимостей(<strong>DI, dependency inversion</strong>)— важный принцип объектно-ориентированного программирования, используемый для уменьшения coupling в компьютерных программах. Есть два паттерна реализации DI:</p>
<ul>
<li>Суть паттерна <strong>Service Locator</strong> сводится к тому, что вместо создания конкретных объектов («сервисов») напрямую с помощью ключевого слова <strong>new</strong>, мы будем использовать специальный «фабричный» объект, который будет отвечать за инициализацию и предоставление всех сервисов.</li>
<li><strong>Внедрение зависимости</strong> (Dependency injection, DI) — Внедрение зависимостей (DI, Dependency Injection) – это механизм передачи классу его зависимостей. Существует несколько конкретных видов или паттернов внедрения зависимостей: внедрение зависимости через конструктор (<a href="http://sergeyteplyakov.blogspot.com/2012/12/di-constructor-injection.html">Constructor Injection</a>), через метод (<a href="http://sergeyteplyakov.blogspot.com/2013/02/di-method-injection.html">Method Injection</a>) и через свойство (<a href="http://sergeyteplyakov.blogspot.com/2013/01/di-property-injection.html">Property Injection</a>). В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму, и не дергает никаких контейнеров/фабрик/реестров для получения нужных сервисов самостоятельно(в этом ключевое отличие от <strong>Service Locator</strong>).</li>
</ul>
<p><strong>Dependency Inversion Principe(DIP)</strong></p>
<p>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ddd"><a class="header" href="#ddd">DDD</a></h1>
<p><strong>Domain-driven design</strong> (Предметно-ориентированное проектирование, реже проблемно-ориентированное) — это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C">предметных областей</a>. В эти модели входит <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0">бизнес-логика</a>, устанавливающая связь между реальными условиями области применения продукта и кодом.</p>
<p>Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области.</p>
<h2 id="Стратегическое-проектирование"><a class="header" href="#Стратегическое-проектирование">Стратегическое проектирование</a></h2>
<p>Проектирование на высоком уровне абстракции, без технических нюансов, осуществляемое всей командой - как менеджерами/заказчиками, так и техническими специалистами.</p>
<p>Основной целью применения DDD является получение высококачественной модели программного обеспечения, которая будет максимально точно отражать поставленные бизнес-цели. Для реализации этого требуется объединение усилий как разработчиков, так и экспертов в предметной области. Создание дружной и сплоченной команды позволяет получить большое количество преимуществ для бизнеса. Обмен знаниями между членами команды снижает шансы появления «тайного знания» о модели, достигается консенсус между экспертами предметной области в отношении различных понятий и терминологии, разрабатывается более точное определение и описание самого бизнеса.</p>
<h3 id="ubiquitous-language-Единый-язык"><a class="header" href="#ubiquitous-language-Единый-язык">Ubiquitous Language (Единый язык)</a></h3>
<p>Для того чтобы уравнять разработчиков и экспертов предметной области, чтобы было гораздо проще обмениваться полезными знаниями о предметной области, подход DDD предлагает применять общий набор терминов, понятий и фраз, который будет использоваться в общении между членами команды, и который позже отразится в исходном коде результирующей программы.</p>
<p>Этот коллективный язык терминов называется - единый язык. (Ubiquitous Language). Это один из основных и самых важных шаблонов предметного-ориентированного проектирования. Это не бизнес жаргон, навязанный разработчикам, а настоящий язык, созданный целостной командой – экспертами в предметной области, разработчиками, бизнес-аналитиками и всеми, кто вовлечен в создание системы. Роль в команде не столь существенна, поскольку каждый член команды использует для описания проекта единый язык. </p>
<h3 id="bounded-context-Ограниченный-контекст"><a class="header" href="#bounded-context-Ограниченный-контекст">Bounded Context (Ограниченный контекст)</a></h3>
<p>Очень важно понимать, что в рамках предметной области смысл определенного термина или фразы может сильно отличаться. Существует некая граница, в пределах которой понятия единого языка имеют вполне конкретное контекстное значение - ограниченный контекст (Bounded context). Это второе по значимости свойство DDD после единого языка. Оба эти понятия взаимосвязаны и не могут существовать друг без друга.</p>
<p>Итак, ограниченный контекст – это явная граница, внутри которой существует модель предметной области, которая отображает единый язык в модель программного обеспечения. </p>
<ul>
<li>В каждом ограниченном контексте существует только один <code>единый язык</code>.</li>
<li>Ограниченные контексты являются относительно небольшими, меньше чем может показаться на первый взгляд. <code>ограниченный контекст</code> достаточно велик только для единого языка изолированной предметной области, но не больше.</li>
<li>Единый значит «вездесущий» или «повсеместный», т. е. язык, на котором говорят члены команды и на котором выражается отдельная модель предметной области, которую разрабатывает команда.</li>
<li>Язык является единым только в рамках команды, работающей над проектом в едином ограниченном контексте.</li>
<li>Попытка применить <code>единый язык</code> в рамках всего предприятия или что хуже, среди нескольких предприятий, закончится провалом.</li>
</ul>
<h3 id="Предметная-область-domain"><a class="header" href="#Предметная-область-domain">Предметная область (Domain)</a></h3>
<p>Это то, что делает организация, и среда, в которой она это делает. Разработчик программного обеспечения для организации обязательно работает в ее <code>предметной области</code>. Следует понимать, что при разработке модели предметной области необходимо сосредоточиться в определенной <code>подобласти</code>, так как практически невозможно создать единственную, всеобъемлющую модель бизнеса даже умеренно сложной организации. Очень важно разделять модели на логические разделенные <code>предметные подобласти</code> (Subdomain) всей <code>предметной области</code>, согласно их фактической функциональности. <code>Подобласти</code> позволяют быстрее определить разные части <code>предметной области</code>, необходимые для решения конкретной задачи</p>
<h3 id="Смысловое-ядро-core-domain"><a class="header" href="#Смысловое-ядро-core-domain">Смысловое ядро (Core domain)</a></h3>
<p>Очень важный аспект подхода DDD. <code>Смысловое ядро</code> – это <code>подобласть</code>, имеющая первостепенное значение для организации. Со стратегической точки зрения бизнес должен выделяться своим <code>смысловым ядром</code>. Большинство DDD проектов сосредоточены именно на <code>смысловом ядре</code>. Лучшие разработчики и эксперты должны быть задействованы именно в этой <code>подобласти</code>. Большинство инвестиций должны быть направлены именно сюда для достижения преимущества для бизнеса и получения наибольшей прибыли.</p>
<h3 id="Пространство-задач-и-пространство-решений"><a class="header" href="#Пространство-задач-и-пространство-решений">Пространство задач и пространство решений</a></h3>
<p><code>Предметные области</code> из пространства задач и пространства решений. Пространство задач позволяет думать о стратегической бизнес проблеме, которая должна быть решена, а пространство решений, сосредоточится на том, как реализуется программное обеспечение, чтобы решить бизнес проблему.</p>
<ul>
<li>Пространство задач – части <code>предметной области</code>, которые необходимы, чтобы создать <code>смысловое ядро</code>. Это комбинация <code>смыслового ядра</code> и <code>подобластей</code>, которое это ядро должно использовать.</li>
<li>Пространство решений – один или несколько <code>ограниченных контекстов</code>, набор конкретных моделей программного обеспечения. Разработанный <code>ограниченный контекст</code> – это конкретное решение, представление реализации.</li>
</ul>
<p>Идеальным вариантом является обеспечение однозначного соответствия между подобластями и ограниченными контекстами. Таким образом, объединяются пространство задач и пространство решений, выделяются модели предметной области в четко определенные области в зависимости от поставленных целей. Если система не разрабатывается с нуля, она часто представляет собой большой комок грязи, где подобласти пересекаются с ограниченными контекстами.</p>
<h2 id="Тактическое-проектирование"><a class="header" href="#Тактическое-проектирование">Тактическое проектирование</a></h2>
<p>Использование технических, структурных паттернов в вашем коде, для отражения результатов стратегического проектирования непосредственно в коде приложения.</p>
<h3 id="entity"><a class="header" href="#entity">Entity</a></h3>
<p>Если какое-то понятие предметной области является уникальным и отличным от всех других объектов в системе, то для его моделирования используется <code>сущность</code>. Такие <code>объекты-сущности</code> могут сильно отличаться своей формой за весь цикл существования, тем не менее их всегда можно однозначно идентифицировать и найти по запросу. Для этого используются уникальные идентификаторы, создание которых необходимо продумать в первую очередь при проектировании <code>сущности</code>.</p>
<h3 id="value-object"><a class="header" href="#value-object">Value Object</a></h3>
<blockquote>
<p>A small simple object, like money or a date range, whose equality isn't based on identity</p>
</blockquote>
<p>Если для объекта не важна индивидуальность, если он полностью определяется своими атрибутами, его следует считать <code>объектом-значением</code>. Чтобы выяснить, является ли какое-то понятие <code>значением</code>, необходимо выяснить, обладает ли оно большинством из следующих характеристик:</p>
<ul>
<li>Оно измеряет, оценивает или описывает объект предметной области;</li>
<li>Должен быть неизменяем (immutable): при попытке обновления значения свойств мы должны создать и вернуть новый экземпляр VO</li>
<li>Оно моделирует нечто концептуально целостное, объединяя связанные атрибуты в одно целое;</li>
<li>При изменении способа измерения или описания его можно полностью заменить;</li>
<li>Его можно сравнивать с другими объектами с помощью отношения равенства <code>значений</code>. Два VO считаются одинаковыми тогда и только тогда, когда все поля VO равны</li>
<li>Оно предоставляет связанным с ним объектам <code>функцию без побочных эффектов</code>.</li>
<li>Состоит только из других VO и примитивов(не может содержать сущность или сервис)</li>
<li>Должен содержать в себе логику самовалидации: нельзя невалидный VO, исключение должно выкидываться прямо из метода VO(конструктор или клон).</li>
</ul>
<h3 id="domain-service"><a class="header" href="#domain-service">Domain Service</a></h3>
<p>Используя единый язык, существительные этого языка отражаются в объекты, а глаголы отражаются в поведения этих объектов. Очень часто существуют глаголы или какие-то действия, которые нельзя отнести к какой-то сущности или к какому-то объекту-значению. Если существует такого рода операция в предметной области, ее объявляют как Domain Service (она отличается от прикладной службы, которая является клиентом). Есть три характеристики служб:</p>
<ul>
<li>
<p>Операция, выполняемая службой, относится к концепции предметной области, которая не принадлежит ни одной из существующих сущностей;</p>
</li>
<li>
<p>Операция выполняется над различными объектами модели предметной области;</p>
</li>
<li>
<p>Операция не имеет состояния.</p>
</li>
</ul>
<h3 id="domain-event"><a class="header" href="#domain-event"><strong>Domain Event</strong></a></h3>
<p>Событие — это то, что произошло в прошлом. Логически, событие предметной области — это то, что произошло в конкретной предметной области, и то, о чем должны быть в курсе и на что должны реагировать другие части той же предметной области. Должны быть иммутабельными(так как нельзя менять прошлое). Название должно описывать случившиеся в прошлом событие.</p>
<h3 id="moduleМодуль"><a class="header" href="#moduleМодуль">Module(Модуль)</a></h3>
<p><code>Модули</code> внутри модели являются именованными контейнерами для некоторой группы объектов предметной области, тесно связанных друг с другом. Их цель – ослабление связей между классами, которые находятся в различных  <code>модулях</code>. Так как <code>модули</code> в подходе DDD – это неформальные или обобщенные разделы, их следует правильно называть. Выбор их имен является функцией  <code>единого языка</code>.</p>
<h3 id="factory"><a class="header" href="#factory">Factory</a></h3>
<p>Некоторые <code>агрегаты</code> или <code>сущности</code> могут быть достаточно сложными. Сложный объект не может создавать сам себя посредством конструктора. (В книге Эрика Эванса был приведен пример: двигатель автомобиля, который собирается либо механиком, либо роботом, но он никак не должен собираться сам по себе.) Еще хуже, когда передают создание сложного объекта на клиент. Так, клиент должен знать о внутренней структуре и взаимосвязях внутри объекта. Это нарушает инкапсуляцию и привязывает клиента к определенной реализации (таким образом, при изменении объекта придется менять и реализацию клиента). </p>
<p>Лучше выполнять создание сложных <code>агрегатов</code> или других объектов отдельно. Для этого используются <code>фабрики</code>. <code>Фабрики</code> – элементы программы, обязанности которого создавать другие объекты.</p>
<h3 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h3>
<p><code>Агрегатом</code> называется кластер из объектов <code>сущностей</code> или <code>значений</code>. То есть эти объекты рассматриваются как единое целое с точки зрения изменения данных. У каждого <code>агрегата</code> есть корень <code>Aggregate Root</code> и граница, внутри которой всегда должны быть удовлетворены инварианты.</p>
<p>Все обращения к <code>агрегату</code> должны осуществляться через его <code>корень</code>, который представляет собой <code>сущность</code> с глобально уникальным идентификатором. Все внутренние объекты <code>агрегата</code> имеют только локальную идентичность, они могут ссылаться друг на друга как угодно. Внешние объекты могут хранить только ссылку на <code>корень</code>, а не на внутренние объекты.</p>
<h3 id="repositoryРепозиторий"><a class="header" href="#repositoryРепозиторий">Repository(Репозиторий)</a></h3>
<p>Репозиторий - область памяти, которая предназначена для безопасного хранения помещенных в нее элементов. Именно этим является Репозиторий в DDD. Репозиторий используется для <code>агрегатов</code>. Помещая <code>агрегат</code> в соответствующий Репозиторий, а затем извлекая его оттуда, вы получаете целостный объект. Если <code>агрегат</code> будет изменен, то изменения будут сохранены. Если <code>агрегат</code> будет удален, то его уже нельзя будет извлечь.</p>
<p>Каждый <code>агрегат</code>, предполагающий постоянное хранение, имеет свой Репозиторий. Зачастую в Репозитории реализуются методы для выборки полностью сгенерированных агрегатов по каким-то критериям.</p>
<p>Есть два типа Repository:</p>
<ol>
<li>Ориентированные на имитацию коллекций;</li>
<li>Ориентированные на механизм постоянного хранения.</li>
</ol>
<p><strong>Application Layer</strong></p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/post/316438/">DDD: стратегическое проектирование</a></li>
<li><a href="https://habr.com/post/316890/">DDD: тактическое проектирование</a></li>
<li><a href="http://sergeyteplyakov.blogspot.com/2014/02/ddd.html">Ключевые концепции DDD</a></li>
<li><a href="https://habr.com/post/334126/">Domain Driven Design на практике</a></li>
<li><a href="https://habr.com/post/61524/">DDD: Domain Driven Design</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Микросервисная-архитектура"><a class="header" href="#Микросервисная-архитектура">Микросервисная архитектура</a></h1>
<p>Микросервисная архитектура — вариант сервис-ориентированной архитектуры программного обеспечения, ориентированный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов, получивший распространение в середине 2010-х годов в связи с развитием практик гибкой разработки и DevOps.</p>
<p>Если в традиционных вариантах сервис-ориентированной архитектуры модули могут быть сами по себе достаточно сложными программными системами, а взаимодействие между ними зачастую полагается на стандартизованные тяжеловесные протоколы (такие, как SOAP, XML-RPC), в микросервисной архитектуре системы выстраиваются из компонентов, выполняющих относительно элементарные функции, и взаимодействующие с использованием экономичных сетевых коммуникационных протоколов. За счёт повышения гранулярности модулей архитектура нацелена на уменьшение степени зацепления и увеличение связности, что позволяет проще добавлять и изменять функции в системе в любое время.</p>
<h2 id="Преимущества-микросервисов"><a class="header" href="#Преимущества-микросервисов">Преимущества микросервисов</a></h2>
<ul>
<li>
<p><strong>Независимые релизы</strong> - Выдача компонентов по мере готовности благодаря декомпозиции решения и отделения различных процессов. Раздельные команды, циклы разработки, тестирование, деплоя. И конечно разделенные продуктовые команды - это важно, потому что большой командой, работающей над старым монолитом, сложно было управлять. Такая команда вынуждена была работать по строгому процессу, а хотелось больше творчества и независимости. Это могли позволить себе только небольшие команды.</p>
</li>
<li>
<p><strong>Гибкость развертывания и масштабирования</strong> - Хотелось бы комбинировать сервисы так, как это необходимо нам, а не так, как заставляет код. Можно гораздо гибче масштабировать приложение, точечно балансируя число интсансов сервисов, которые не вывозят нагрузку.</p>
</li>
<li>
<p><strong>Технологическая независимость</strong> - Можно выбирать инструмент под задачу. Тут заюзаем Go с хранением в памяти тут оставим java с полноценной субд. Гораздо легче внедрить новый инструмент.</p>
</li>
</ul>
<h2 id="Недостатки-микросервисов"><a class="header" href="#Недостатки-микросервисов">Недостатки микросервисов</a></h2>
<ul>
<li>Издержки на межсетевое взаимодействие</li>
<li>Трудности с распределенными транзакциями</li>
<li>Сложность эксплуатации</li>
<li>Риски получения зоопарка технологий</li>
<li>При неверном применении подхода, получим распределенный монолит.</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/company/raiffeisenbank/blog/346380/">Просто о микросервисах</a></li>
<li><a href="https://habr.com/ru/company/flant/blog/347518/">Смерть микросервисного безумия в 2018 году</a></li>
<li><a href="https://habr.com/ru/company/raiffeisenbank/blog/458404/">Переход от монолита к микросервисам: история и практика</a></li>
<li><a href="http://devopsru.com/news/2016-05-10-microservice-trade-offs.html">Микросервисы — за и против</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Протоколы-межсервисного-взаимодействия"><a class="header" href="#Протоколы-межсервисного-взаимодействия">Протоколы межсервисного взаимодействия</a></h1>
<h3 id="mq-vs-http"><a class="header" href="#mq-vs-http">MQ vs. HTTP</a></h3>
<p>I was going through my old files and came across my notes on MQ and thought I’d share some reasons to use MQ vs. HTTP:</p>
<ul>
<li>If your consumer processes at a fixed rate (i.e. can’t handle floods to the HTTP server [bursts]) then using <strong>MQ provides the flexibility</strong> for the service to buffer the other requests vs. bogging it down.</li>
<li><strong>Time independent processing</strong> and <strong>messaging exchange patterns</strong> — if the thread is performing a fire-and-forget, then MQ is better suited for that pattern vs. HTTP.</li>
<li><strong>Long-lived processes are better suited for MQ</strong> as you can send a request and have a seperate thread listening for responses (note WS-Addressing allows HTTP to process in this manner but requires both endpoints to support that capability).</li>
<li><strong>Loose coupling</strong> where one process can continue to do work even if the other process is not available vs. HTTP having to retry.</li>
<li><strong>Request prioritization</strong> where more important messages can jump to the front of the queue.</li>
<li><strong>XA transactions</strong> – MQ is fully XA compliant – HTTP is not.</li>
<li><strong>Fault tolerance</strong> – MQ messages survive server or network failures – HTTP does not.</li>
<li>MQ provides for <strong>‘assured’ delivery</strong> of messages once and only once, http does not.</li>
<li>MQ provides the ability to do <strong>message segmentation</strong> and message grouping for large messages – HTTP does not have that ability as it treats each transaction seperately.</li>
<li>MQ provides a <strong>pub/sub interface</strong> where-as HTTP is point-to-point.</li>
</ul>
<p>https://solace.com/blog/products-tech/experience-awesomeness-event-driven-microservices</p>
<h2 id="Синхронные"><a class="header" href="#Синхронные">Синхронные</a></h2>
<p>RPC</p>
<p>REST</p>
<h2 id="Асинхронные"><a class="header" href="#Асинхронные">Асинхронные</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Методы-распиливания-монолита"><a class="header" href="#Методы-распиливания-монолита">Методы распиливания монолита</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Разные-паттерны"><a class="header" href="#Разные-паттерны">Разные паттерны</a></h1>
<h2 id="Шаблоны-взаимодействия-с-клиентом"><a class="header" href="#Шаблоны-взаимодействия-с-клиентом">Шаблоны взаимодействия с клиентом</a></h2>
<ul>
<li><strong>Model-view-controller (MVC, «модель-представление-контроллер», «модель-вид-контроллер»)</strong> — схема использования нескольких шаблонов проектирования, с помощью которых модель приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента таким образом, чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные. Данная схема проектирования часто используется для построения архитектурного каркаса, когда переходят от теории к реализации в конкретной предметной области.</li>
<li><strong>HMVC (<em>Hierarchical model–view–controller</em>)</strong> — Иерархические Модель-Вид-Контроллер, одно из расширений архитектурного <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"><em>паттерна</em></a> <a href="https://ru.wikipedia.org/wiki/Model-View-Controller"><em>MVC</em></a>, позволяющее решить некоторые проблемы масштабируемости приложений, имеющих классическую MVC-архитектуру. Согласно парадигме HMVC, каждая отдельная MVC триада используется в качестве слоя в иерархической структуре. При этом, каждая триада в этой иерархии независима от других, и может обратиться к контроллеру другой триады. Такой подход существенно облегчает и ускоряет разработку сложных приложений, облегчает их дальнейшую поддержку и масштабирование, способствует повторному использованию кода.</li>
<li><strong>Model Model-View-Presenter (MVP</strong>) — шаблон проектирования, производный от MVC, который используется в основном для построения пользовательского интерфейса. Элемент Presenter в данном шаблоне берёт на себя функциональность посредника (аналогично контроллеру в MVC) и отвечает за управление событиями пользовательского интерфейса (например, использование мыши) так же, как в других шаблонах обычно отвечает представление.</li>
<li><strong>Model-View-ViewModel (MVVM)</strong> — применяется при проектировании архитектуры приложения. используется для разделения модели и её представления, что необходимо для изменения их отдельно друг от друга. Например, разработчик задает логику работы с данными, а дизайнер соответственно работает с пользовательским интерфейсом. MVVM удобно использовать вместо классического MVC и ему подобных в тех случаях, когда в платформе, на которой ведётся разработка, присутствует «связывание данных». В шаблонах проектирования MVC/MVP изменения в пользовательском интерфейсе не влияют непосредственно на Модель, а предварительно идут через Контроллер (англ. Controller) или Presenter. В таких технологиях как WPF и Silverlight есть концепция «связывания данных», позволяющая связывать данные с визуальными элементами в обе стороны. Следовательно, при использовании этого приема применение модели MVC становится крайне неудобным из-за того, что привязка данных к представлению напрямую не укладывается в концепцию MVC/MVP.</li>
<li><strong>PageController</strong> - В основе контроллера страниц лежит идея создания компонентов, которые будут выполнять роль контроллеров для каждой страницы Web-сайта.(много физических точек(файлов) входа)</li>
<li><strong>FrontController</strong> - Один контроллер обрабатывает все запросы к веб-сайту(одна физическая точка входа)</li>
</ul>
<h2 id="Шаблоны-для-работы-с-базами-данных"><a class="header" href="#Шаблоны-для-работы-с-базами-данных">Шаблоны для работы с базами данных</a></h2>
<ul>
<li><strong>ActiveRecord</strong> - реализует популярный подход объектно-реляционного проецирования (ORM). Каждый класс AR отражает таблицу (или представление) базы данных, экземпляр AR — строку в этой таблице, а общие операции CRUD реализованы как методы AR. В результате мы можем использовать более объектно-ориентированный подход доступа к данным</li>
<li><strong>Data Mapper</strong> — это программная прослойка, разделяющая объект и БД. Его обязанность — пересылать данные между ними и изолировать их друг от друга. При использовании Data Mapper'а объекты не нуждаются в знании о существовании БД. Они не нуждаются в SQL-коде, и (естественно) в информации о структуре БД. Так как Data Mapper - это разновидность паттерна Mapper, сам объект-Mapper неизвестен объекту.</li>
</ul>
<h2 id="Совсем-разное"><a class="header" href="#Совсем-разное">Совсем разное</a></h2>
<ul>
<li><strong>Делегирование (Delegation)</strong> — основной шаблон проектирования, в котором объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту. Шаблон делегирования является фундаментальной абстракцией, на основе которой реализованы другие шаблоны - композиция (также называемая агрегацией), примеси (mixins) и аспекты (aspects).</li>
<li><strong>Lazy Load (Ленивая Загрузка)</strong> подразумевает отказ от загрузки дополнительных данных, когда в этом нет необходимости. Вместо этого ставится маркер о том, что данные не загружены и их надо загрузить в случае, если они понадобятся. Как известно, если Вы ленивы, то вы выигрываете в том случае, если дело, которое вы не делали на самом деле и не надо было делать.</li>
<li><strong>Registry</strong>(реестр) — это ООП замена глобальным переменным, предназначена для хранения данных и передачи их между модулями системы. Соответственно, его наделяют стандартными свойствами — запись, чтение, удаление. Вот типовая реализация.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php"><a class="header" href="#php">PHP</a></h1>
<p><strong>PHP</strong> (PHP: Hypertext Preprocessor; первоначально Personal Home Page Tools) — скриптовый язык общего назначения, интенсивно применяемый для разработки веб-приложений. Является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов.</p>
<ul>
<li><a href="php/innovations.html">Фичи новых версий</a></li>
<li><a href="php/internals.html">PHP Internals</a></li>
<li><a href="php/frameworks/README.html">Фреймворки</a></li>
<li><a href="php/uncategorized.html">Разное</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Основные-нововведения-php"><a class="header" href="#Основные-нововведения-php">Основные нововведения php</a></h2>
<h3 id="70"><a class="header" href="#70"><a href="http://www.php.net/ChangeLog-7.php#7.0.0">7.0</a></a></h3>
<ol>
<li>возможность обработки исключения, вместо фатальной ошибки</li>
<li>новые операторы сравнения ( &lt;=&gt;, ?? и другие)</li>
<li>анонимные классы</li>
<li>указание типа возвращаемого значения (return type declaration)</li>
<li>группировка для оператора use</li>
<li>работа с замыканиями (closure)</li>
<li>скалярные типы аргументов функции (scalar type hints)</li>
<li>опционально доступный &quot;строгий режим&quot; работы с типами (strict mode)</li>
<li>изменена трактовка переменных и выражений</li>
<li>улучшена работа с генераторами (ключевое слово yield from и другие изменения)</li>
<li>конструктор класса в стиле php4 (когда имя класса совпадает с именем метод) теперь генерирует E_DEPRECATED и будет удален в php8</li>
<li>изменено поведение побитовых операторов &lt;&lt;, &gt;&gt;  и других</li>
<li>изменено поведение функций func_get_args и func_get_arg</li>
<li>функция языка unserialize принимает дополнительный аргумент</li>
<li>функция языка list изменила поведение</li>
<li>изменено поведение цикла foreach (например в работе с внутренним итератором)</li>
<li>новый синтаксис unicode последовательностей</li>
</ol>
<h2 id="71"><a class="header" href="#71"><a href="http://php.net/ChangeLog-7.php#7.1.0">7.1</a></a></h2>
<ol>
<li>возвращаемый тип void</li>
<li>псевдотип iterable</li>
<li>null в типизированных и возвращаемых параметрах</li>
<li>возможность использовать отрицательное значение для смещения в строках</li>
<li>разрешено использовать строковые ключи в конструкци</li>
<li>конвертация callable выражений в замыкание</li>
<li>Поддержка модификаторов видимости для констант класса</li>
<li>Ловить исключения можно объединяя несколько типов исключений в один блок </li>
</ol>
<h2 id="72"><a class="header" href="#72"><a href="http://php.net/ChangeLog-7.php#7.2.0">7.2</a></a></h2>
<ol>
<li>Добавлена возможность загружать расширения по имени</li>
<li>Добавлена возможность перегружать абстрактные функции(Liskov)</li>
<li>Запрещено number_format() возвращать -0</li>
<li>Добавлена возможность конвертировать нумерованные ключи при приведении типов object/array</li>
<li>Запрещено передавать null в качестве параметра для get_class()</li>
<li>Вызов Count с параметром, который нельзя посчитать</li>
<li>Возможность расширения типа параметра</li>
<li>Добавлена возможность указывать запятую в конце группированных неймспейсов</li>
<li>Реализовано семейство функций socket_getaddrinfo</li>
<li>Улучшены TLS-константы</li>
<li>Object typehint</li>
<li>LDAP EXOP</li>
<li>В ядро PHP добавлена Libsodium</li>
<li>Добавлен алгоритм Argon2 в хешировании пароля</li>
<li>HashContext as Object</li>
<li>Добавлен отладчик PDO Prepared statements</li>
<li>Добавлен отладчик PDO Prepared statements v2</li>
<li>Расширенные типы строк для PDO</li>
<li>Добавлены опции JSON_INVALID_UTF8_IGNORE и JSON_INVALID_UTF8_SUBSTITUTE</li>
</ol>
<h3 id="73"><a class="header" href="#73"><a href="http://www.php.net/ChangeLog-7.php#7.3.0">7.3</a></a></h3>
<ol>
<li>Смягчение требований к синтаксису Heredoc и Nowdoc</li>
<li>Поддержка конечных запятых в вызовах функций и методов</li>
<li>Ссылки в <code>list()</code></li>
<li>Функция <code>image2wbmp()</code> объявлена устаревшей</li>
<li>Флаги <code>FILTER_FLAG_SCHEME_REQUIRED</code> и <code>FILTER_FLAG_HOST_REQUIRED</code> при использовании <code>FILTER_VALIDATE_URL</code> объявлены устаревшими</li>
<li>Регистро-независимые константы объявлены устаревшими</li>
<li>Опциональный выброс исключений при ошибках в функциях <code>json_encode</code> и <code>json_decode</code></li>
<li>Добавление функции <code>is_countable()</code></li>
<li>Добавление функций <code>array_key_first()</code> и <code>array_key_last()</code></li>
</ol>
<h3 id="74"><a class="header" href="#74">7.4</a></h3>
<ul>
<li>Типизированные свойства классов</li>
<li>Предзагрузка для улучшения производительности</li>
<li>Стрелочные функции для короткой записи анонимных функций</li>
<li>Присваивающий оператор объединения с null (??=)</li>
<li>Ковариантность/контравариантность в сигнатурах унаследованных методов</li>
<li>Интерфейс внешних функций, открывающий новые возможности для разработки расширений на PHP</li>
<li>Оператор распаковки в массивах</li>
</ul>
<h3 id="8"><a class="header" href="#8"><a href="https://www.php.net/releases/8.0">8</a></a></h3>
<ol>
<li>Именованные аргументы</li>
<li>Атрибуты</li>
<li>Объявление свойств в конструкторе</li>
<li>Union types</li>
<li>Выражение Match</li>
<li>Оператор Nullsafe</li>
<li>Улучшенное сравнение строк и чисел</li>
<li>Ошибки согласованности типов для встроенных функций</li>
</ol>
<h3 id="81"><a class="header" href="#81">8.1</a></h3>
<ul>
<li><a href="https://php.watch/versions/8.1/intersection-types">Intersection Types</a></li>
<li><a href="https://php.watch/versions/8.1/enums">Enums</a></li>
<li><a href="https://php.watch/versions/8.1/never-return-type"><code>never</code> return type</a></li>
<li><a href="https://php.watch/versions/8.1/readonly">Readonly Properties</a></li>
<li><a href="https://php.watch/versions/8.1/fibers">Fibers</a></li>
<li><a href="https://php.watch/versions/8.1/final-class-const"><code>final</code> class constants</a></li>
<li><a href="https://php.watch/versions/8.1/fsync-fdatasync">New <code>fsync</code> and <code>fdatasync</code> functions</a></li>
<li><a href="https://php.watch/versions/8.1/array_is_list">New <code>array_is_list</code> function</a></li>
<li><a href="https://php.watch/versions/8.1/Sodium-XChaCha20-functions">New Sodium <code>XChaCha20</code> functions</a></li>
<li><a href="https://php.watch/versions/8.1/$_FILES-full-path"><code>$_FILES</code>: New <code>full_path</code> value for directory-uploads</a></li>
<li><a href="https://php.watch/versions/8.1/IntlDatePatternGenerator">Intl: New <code>IntlDatePatternGenerator</code> class</a></li>
<li><a href="https://php.watch/versions/8.1/first-class-callable-syntax">First-class Callable Syntax</a></li>
<li><a href="https://php.watch/versions/8.1/gd-avif">GD: AVIF image support</a></li>
<li><a href="https://php.watch/versions/8.1/phar-openssl-256-openssl-512">Phar: Added OpenSSL-256 and OpenSSL-512 signature algorithms</a></li>
<li><a href="https://php.watch/versions/8.1/gd-webp-lossless">GD: Lossless WebP encoding support</a></li>
<li><a href="https://php.watch/versions/8.1/ReturnTypeWillChange">New <code>#[ReturnTypeWillChange\]</code> attribute</a></li>
<li><a href="https://php.watch/versions/8.1/spread-operator-string-array-keys">Array unpacking support for string-keyed arrays</a></li>
<li><a href="https://php.watch/versions/8.1/explicit-octal-notation">Explicit Octal numeral notation</a></li>
<li><a href="https://php.watch/versions/8.1/hash-options">Hash functions accept algorithm-specific <code>$options</code></a></li>
<li><a href="https://php.watch/versions/8.1/MurmurHash3">MurmurHash3 hash algorithm support</a></li>
<li><a href="https://php.watch/versions/8.1/xxHash">xxHash hash algorithms support</a></li>
<li><a href="https://php.watch/versions/8.1/fpm-pm-max_spawn_rate">FPM: Configurable child-process spawn rate</a></li>
<li><a href="https://php.watch/versions/8.1/Curl-CURLOPT_DOH_URL">Curl: DNS-over-HTTPS support</a></li>
<li><a href="https://php.watch/versions/8.1/CURLStringFile">Curl: File uploads from strings with <code>CURLStringFile</code></a></li>
<li><a href="https://php.watch/versions/8.1/MYSQLI_REFRESH_REPLICA">MySQLi: New <code>MYSQLI_REFRESH_REPLICA</code> constant</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="php-internals"><a class="header" href="#php-internals">PHP Internals</a></h1>
<h2 id="zval"><a class="header" href="#zval">Zval</a></h2>
<p>Структура данных <strong>zval</strong>(Zend value) используется для представления любых значений PHP. Zval хранит в себе само значение и тип этого значения. Это необходимо потому что PHP — это язык с динамической типизацией и поэтому тип переменных известен только во время выполнения программы (run-time), а не во время компиляции (compile-time). Кроме того, тип переменной может быть изменен в течение жизни zval, то есть zval ранее хранимый как целое число (integer) позднее может содержать строку (string).</p>
<p>Структура zval в PHP5 выглядит так:</p>
<pre><code class="language-C">typedef struct _zval_struct {
    zvalue_value value;
    zend_uint refcount__gc;
    zend_uchar type;
    zend_uchar is_ref__gc;
} zval;
</code></pre>
<p>Тип переменной хранится как целочисленная метка (type tag, unsigned char). Метка может принимать одно из 8 значений, которое соответствует 8 типам данных доступных в PHP. Эти значения должны присваиваться с использованием констант вида <code>IS_TYPE</code>. Например, <code>IS_NULL</code>соответствует типу данных null, а <code>IS_STRING</code> — строке.</p>
<p><strong>zvalue_value</strong> — это union. Union — в языке С – это структура, в которой можно объявить несколько членов разных типов, но лишь один компонент может быть доступен для использования в данный момент времени, размер union равен размеру самого большого компонента. Все компоненты объединения хранятся в памяти в одном месте и могут интерпретироваться по-разному, в зависимости от того, к кому из них вы обращаетесь. Если считать lval, то его значение будет интерпретировано как знаковое целочисленное. Значение dval будет представлено в виде числа двойной точности с плавающей запятой. И так далее. Чтобы узнать, какой компонент объединения используется в данный момент, можно посмотреть текущее значение свойства type.</p>
<pre><code class="language-c">typedef union _zvalue_value {
    long lval;                 // Для булевых, целочисленных и ресурсов
    double dval;               // Для чисел с плавающей запятой
    struct {                   // Для строковых
        char *val;
        int len;
    } str;
    HashTable *ht;             // Для массивов
    zend_object_value obj;     // Для объектов
    zend_ast *ast;             // Для констант
} zvalue_value;
</code></pre>
<p><strong>refcount__gc</strong> - когда вы присваиваете переменной значение другой переменной, то они обе ссылаются на один zval, а refcount инкрементируется. Теперь, если вы захотите изменить значение одной из этих переменных, то PHP, увидя refcount больше 1, скопирует этот zval, сделает изменения там, и ваша переменная будет указывать уже на новый zval. Эта техника называется <strong>copy on write</strong>, и она позволяет неплохо снизить потребление памяти. </p>
<p>У подсчёта ссылок есть один серьёзный недостаток: этот механизм не способен определять циклические ссылки. Для этого в PHP используется дополнительный инструмент — <a href="http://php.net/manual/en/features.gc.collecting-cycles.php">циклический сборщик мусора</a>. Каждый раз, когда значение refcount уменьшается и возникает вероятность, что <code>zval</code>стал частью цикла, он записывается в root buffer. Когда этот буфер заполняется, потенциальные циклы помечаются и зачищаются сборщиком мусора. </p>
<p>А что происходит со ссылками(пхпшными)? Все очень просто: если вы создаете ссылку от переменной, то флаг <strong>is_ref</strong> становится равным 1, и больше вышеописанная оптимизация для этого zval-а применяться не будет. </p>
<p>Вот список основных проблем, связанных с реализацией  <code>zval</code>  в PHP 5:</p>
<ul>
<li><code>Zval</code> (почти) всегда требуется размещать в куче.</li>
<li><code>Zval</code> всегда требуют использования подсчёта ссылок и сбора информации о циклах. Даже в тех случаях, когда расшаривание значений не стоит потраченных ресурсов (целочисленные) или циклы не могут возникнуть в принципе.</li>
<li>Прямой подсчёт ссылок приводит к двойному выполнению этой процедуры в случае с объектами и ресурсами. </li>
<li>В некоторых случаях приходится прибегать к большому количеству обходных манёвров. Например, чтобы получить доступ к объекту, хранящемуся в переменной, необходимо суммарно разыменовать четыре указателя, со всеми сопутствующими цепочками. Об этом я тоже поговорю во второй части.</li>
<li>Прямой подсчёт ссылок также означает, что значения можно расшаривать только между <code>zval</code>’ами. Например, строку невозможно совместно использовать в <code>zval</code> и ключе хэш-таблицы (без хранения этого ключа также в виде zval).</li>
</ul>
<h3 id="zvalы-в-php-7"><a class="header" href="#zvalы-в-php-7">Zval’ы в PHP 7</a></h3>
<p>In PHP 7 a zval can be reference counted or not. There is a flag in the zval structure which determined this.</p>
<p>There are some types which are never refcounted. These types are null, bool, int and double.</p>
<p>There are other types which are always refcounted. These are objects, resources and references.</p>
<p>And then there are types, which are <em>sometimes</em> refcounted. Those are strings and arrays.</p>
<p>For strings the not-refcounted variant is called an &quot;interned string&quot;. If you're using an NTS (not thread-safe) PHP 7 build, which you typically are, all string literals in your code will be interned. These interned strings are deduplicated (i.e. there is only one interned string with a certain content) and are guaranteed to exist for the full duration of the request, so there is no need to use reference counting for them. If you use opcache, these strings will live in shared memory, in which case you <em>can't</em> use reference counting for them (as our refcounting mechanism is non-atomic). Interned strings have a dummy refcount of 1, which is what you're seeing here.</p>
<p>For arrays the not-refcounted variant is called an &quot;immutable array&quot;. If you use opcache, then constant array literals in your code will be converted into immutable arrays. Once again, these live in shared memory and as such must not use refcounting. Immutable arrays have a dummy refcount of 2, as it allows us to optimize certain separation paths.</p>
<p>В седьмой версии языка мы получили новую реализацию zval. Одним из главных нововведений стало то, что zval больше не нужно отдельно размещать в куче. Также refcount теперь хранится не в самом zval, а в любом из комплексных значений, на которые он указывает — в строках, массивах или объектах. Это даёт следующие преимущества:</p>
<ul>
<li><strong>Простые значения не требуют размещения в куче и не используют подсчёт ссылок. А хранятся или в стеке, или в составе комплексных структур.</strong></li>
<li>Больше нет никакого двойного подсчёта. В случае с объектами используется счётчик только внутри самого объекта.</li>
<li>Поскольку refcount теперь хранится в самом значении, то оно может быть использовано независимо от самого zval. Например, строка может использоваться и в zval, и быть ключом в хэш-таблице.</li>
<li>Теперь стало гораздо меньше указателей, которые нужно перебрать, чтобы получить значение.</li>
</ul>
<p>Вот как выглядит структура нового zval:</p>
<pre><code class="language-c">    zend_value value;
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar type,
                zend_uchar type_flags,
                zend_uchar const_flags,
                zend_uchar reserved)
        } v;
        uint32_t type_info;
    } u1;
    union {
        uint32_t var_flags;
        uint32_t next;                 // hash collision chain
        uint32_t cache_slot;           // literal cache slot
        uint32_t lineno;               // line number (for ast nodes)
        uint32_t num_args;             // arguments number for EX(This)
        uint32_t fe_pos;               // foreach position
        uint32_t fe_iter_idx;          // foreach iterator index
    } u2;
};`
</code></pre>
<p>Первый компонент остался практически таким же, это объединение value. Второй компонент — целочисленный, хранящий информацию о типе, который с помощью объединения разбит на отдельные байты (можно игнорировать макрос ZEND_ENDIAN_LOHI_4, он нужен лишь для обеспечения консистентной структуры между платформами с разными порядками следования байтов). Важными частями этой вложенной конструкции являются type и type_flags, о них я расскажу ниже.</p>
<p>Также здесь есть одна небольшая проблема. Value занимает 8 байт, и благодаря своей структуре добавление даже одного байта повлечёт за собой увеличение размера zval на 16 байт. Но ведь нам не нужно целых 8 байт для хранения типа. Поэтому в zval есть дополнительное объединение u2, которое по умолчанию не используется, но может применяться для хранения 4 байт данных. Разные компоненты объединения предназначены для разных видов использования этого дополнительного хранилища.</p>
<p>В PHP 7 объединение <code>value</code>  несколько отличается от пятой версии:</p>
<pre><code class="language-c">typedef union _zend_value {
    zend_long         lval;
    double            dval;
    zend_refcounted  *counted;
    zend_string      *str;
    zend_array       *arr;
    zend_object      *obj;
    zend_resource    *res;
    zend_reference   *ref;
    zend_ast_ref     *ast;

    // Эти пока можно игнорировать, они специальные
    zval             *zv;
    void             *ptr;
    zend_class_entry *ce;
    zend_function    *func;
    struct {
        ZEND_ENDIAN_LOHI(
            uint32_t w1,
            uint32_t w2)
    } ww;
} zend_value;
</code></pre>
<p>Обратите внимание, что <code>value</code>  теперь занимает 8 байт вместо 16. Оно хранит только целочисленные (<code>lval</code>) и числа с плавающей запятой (<code>dval</code>). Всё остальное — это указатель. Все типы указателей (за исключением специальных, отмеченных выше) используют подсчёт ссылок и содержат заголовок, определяемый zend_refcounted:</p>
<pre><code class="language-c">struct _zend_refcounted {
    uint32_t refcount;
    union {
        struct {
            ZEND_ENDIAN_LOHI_3(
                zend_uchar    type,
                zend_uchar    flags,
                uint16_t      gc_info)
        } v;
        uint32_t type_info;
    } u;
};
</code></pre>
<p>Я уже упоминал, что <code>zval</code> больше не нужно отдельно размещать в куче. Но их же нужно где-то хранить. Они всё ещё являются частью структур, размещаемых в кучах. Например, хэш-таблица будет содержать собственный <code>zval</code> вместо указателя на отдельный <code>zval</code>. Скомпилированная таблица переменных функции и таблица свойств объекта будут представлять собой <code>zval</code>-массивы. В качестве таких <code>zval</code> теперь обычно хранятся те, у которых косвенность на один уровень ниже. То есть <code>zval</code>’ом теперь называется то, что раньше было <code>zval</code>*.</p>
<p>Когда-то нужно было копировать <code>zval</code>* и инкрементить его refcount, чтобы использовать <code>zval</code> в новом месте. Теперь для этого достаточно скопировать содержимое <code>zval</code> (игнорируя <code>u2</code>) и, <strong>может быть</strong>, инкрементить refcount того значения, на которое он указывает, если значение использует подсчёт ссылок.</p>
<p>Откуда PHP знает, что используется подсчёт? Это нельзя определить по одному лишь типу, поскольку некоторые типы не используют refcount — например, строки и массивы. Для этого используется один бит компонента <code>type_info</code>.</p>
<h2 id="Внутренние-типы"><a class="header" href="#Внутренние-типы">Внутренние типы</a></h2>
<p>Какие типы поддерживаются в PHP 7:</p>
<pre><code class="language-c">// обычные типы данных
#define IS_UNDEF                    0
#define IS_NULL                     1
#define IS_FALSE                    2
#define IS_TRUE                     3
#define IS_LONG                     4
#define IS_DOUBLE                   5
#define IS_STRING                   6
#define IS_ARRAY                    7
#define IS_OBJECT                   8
#define IS_RESOURCE                 9
#define IS_REFERENCE                10

// константные выражения
#define IS_CONSTANT                 11
#define IS_CONSTANT_AST             12

// внутренние типы
#define IS_INDIRECT                 15
#define IS_PTR                      17
</code></pre>
<p>В чём отличия от PHP 5:</p>
<ul>
<li>Тип <code>IS_UNDEF</code> используется вместо указателя на <strong>zval</strong> <code>NULL</code> (не путайте с <code>IS_NULL zval</code>). Например, в приведённых выше примерах переменным назначается тип <code>IS_UNDEF</code>.</li>
<li>Тип <code>IS_BOOL</code> разделён на <code>IS_FALSE</code> и <code>IS_TRUE</code>. Поскольку такое булево значение теперь встроено в тип, это позволяет оптимизировать ряд проверок на основе типа. Данное изменение незаметно для пользователей, которые по-прежнему оперируют единственным «булевым» типом.</li>
<li><strong>PHP</strong>-ссылки больше не используют в <strong>zval</strong> флаг <code>is_ref</code>. Вместо него введён новый тип <code>IS_REFERENCE</code>. Ниже я расскажу, как это работает.</li>
<li><code>IS_INDIRECT</code> и <code>IS_PTR</code> являются специальными внутренними типами.</li>
</ul>
<p>Тип  <code>IS_LONG</code>  вместо обычного <code>long</code> из языка С теперь использует значение <code>zend_long</code>. Причина в том, что в 64-битных Windows <code>long</code> имеет разрядность только 32 бита. Поэтому PHP 5 больше не использует в Windows в обязательном порядке 32-битные числа. А в PHP 7 вы можете использовать 64-битные значения, если система также 64-битная. </p>
<h2 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h2>
<p>На уровне PHP, массив — это упорядоченный список скрещенный с мэпом. Грубо говоря, PHP смешивает эти два понятия, в итоге получается, с одной стороны, очень гибкая структура данных, с другой стороны, далеко не самая оптимальная.  На самом деле, для реализации массивов в PHP, используется вполне себе стандартная структура данных <a href="http://ru.wikipedia.org/wiki/Hash_table">Hash Table</a>. Hash Table хранит в себе указатель на самое первое и последнее значения (нужно для упорядочивания массивов), указатель на текущее значение (используется для итерации по массиву, это то, что возвращает <code>current()</code>), кол-во элементов, представленных в массиве, массив указателей на Bucket-ы (о них далее), и еще кое-что.</p>
<p>В Hash Table есть две главные сущности, первая — это собственно сам Hash Table, и вторая — это Bucket(ведол). В ведрах хранятся сами значения, то есть на каждое значение — свое ведро. Но помимо этого в ведре хранится оригинал ключа, указатели на следующее и предыдущее ведра (они нужны для упорядочивания массива, ведь в PHP ключи могут идти в любом порядке, в каком вы захотите), и, опять же, еще кое-что.</p>
<p>Таким образом, когда вы добавляете новый элемент в массив, если такого ключа там еще нет, то под него создается новое ведро и добавляется в Hash Table. Как было сказано выше, у HT есть некий массив указателей на ведра, при этом ведра доступны в этом массиве по некоему индексу, а этот индекс можно вычислить зная ключ ведра. </p>
<pre><code class="language-c">struct _zend_array {
    zend_refcounted_h gc;
    union {
        struct {
            ZEND_ENDIAN_LOHI_4(
                zend_uchar    flags,
                zend_uchar    nApplyCount,
                zend_uchar    nIteratorsCount,
                zend_uchar    reserve)
        } v;
        uint32_t flags;           /* доступно 32 флага */
    } u;
    uint32_t     nTableMask;       /* маска — nTableSize */
    Bucket      *arData;           /* полезное хранилище данных */
    uint32_t     nNumUsed;         /* следующая доступная ячейка в arData */
    uint32_t     nNumOfElements;   /* общее количество занятых элементов в arData */
    uint32_t     nTableSize;       /* размер таблицы, всегда равен двойке в степени */
    uint32_t     nInternalPointer; /* используется для итерации */
    zend_long    nNextFreeElement; /* следующий доступный целочисленный ключ */
    dtor_func_t  pDestructor;      /* деструктор данных */
};
</code></pre>
<p>Самое интересное поле данных — arData, это своеобразный указатель на область памяти цепочки Bucket. Сама Bucket представляет собой одну ячейку в массиве:</p>
<pre><code class="language-c">typedef struct _Bucket {
    zval              val; /* значение */
    zend_ulong        h;   /* хэш (или числовой индекс)   */
    zend_string      *key; /* строковый ключ или NULL для числовых значений */
} Bucket;
</code></pre>
<p>Как вы могли заметить, в структуре Bucket будет храниться zval. Обратите внимание, что здесь используется не указатель на zval, а именно сама структура. Так сделано потому, что в РНР 7 zval’ы больше не размещаются в куче (в отличие от PHP 5), но при этом в РНР 7 может размещаться целевое значение, хранящееся в zval в виде указателя (например, строка РНР).</p>
<p>Стоит отметить, что в PHP почти все посторено на одной этой структуре HashTable: все переменные, лежащие в каком-либо scope-е, на самом деле лежат в HT, все методы классов, все поля классов, даже сами дефинишины классов лежат в HT, это на самом деле очень гибкая структура. Помимо прочего, HT обеспечивает практически одинаковую скорость выборки/вставки/удаления и сложность всех троих является O(1), <em>но</em> с оговоркой на небольшой оверхед при коллизиях.</p>
<p>Свойства хэш таблицы:</p>
<ul>
<li>Ключ может быть строкой или целочисленным. В первом случае используется структура <code>zend_string</code>, во втором — <code>zend_ulong</code>.</li>
<li>Хэш-таблица всегда должна помнить порядок добавления её элементов.</li>
<li>Размер хэш-таблицы меняется автоматически. В зависимости от обстоятельств она самостоятельно уменьшается или увеличивается.</li>
<li>С точки зрения внутренней реализации размер таблицы всегда равен двойке в степени. Это делается для улучшения производительности и выравнивания размещения данных в памяти.</li>
<li>Все значения в хэш-таблице хранятся в структуре <code>zval</code>, больше нигде. <code>Zval</code>’ы могут содержать данные любых типов.</li>
</ul>
<h3 id="Разрешение-коллизий"><a class="header" href="#Разрешение-коллизий">Разрешение коллизий</a></h3>
<p>Теперь разберёмся, как разрешаются коллизии. Как вы помните, в хэш-таблице несколько ключей при хэшировании и сжатии могут соответствовать одному и тому же индексу преобразования. Так что, получив индекс преобразования, мы с его помощью извлекаем данные обратно из <code>arData</code> и сравниваем хэши и ключи, проверяя, то ли это, что нужно. Если данные неправильные, мы проходим по связному списку с помощью поля <code>zval.u2.next</code>, в котором отражается следующая ячейка для внесения данных.</p>
<p>Обратите внимание, что связный список не рассеян по памяти, как традиционные связные списки. Вместо того чтобы ходить по нескольким размещённым в памяти указателям, полученным от кучи — и наверняка разбросанным по адресному пространству, — мы считываем из памяти полный вектор  <code>arData</code> <strong>И это одна из главных причин увеличения производительности хэш-таблиц в РНР 7, а также всего языка.</strong></p>
<p>В РНР 7 у хэш-таблиц очень высокая локальность данных. В большинстве случаев доступ происходит за 1 наносекунду, поскольку данные обычно находятся в процессорном кэше первого уровня.</p>
<h2 id="Строки"><a class="header" href="#Строки">Строки</a></h2>
<p>В PHP 7 строки представляются с помощью типа  <code>zend_string</code>:</p>
<pre><code class="language-c">struct _zend_string {
    zend_refcounted   gc;
    zend_ulong        h;        /* hash value */
    size_t            len;
    char              val[1];
};
</code></pre>
<p>Помимо содержащегося в заголовке <code>refcounted</code>, здесь также используется кэш хэша h, длина <code>len</code> и значение <code>val</code>. Кэш хэша используется для того, чтобы не пересчитывать хэш строки при каждом обращении к <code>HashTable</code>. При первом использовании он инициализируется как ненулевой хэш. Если вы не слишком хорошо знакомы с разнообразными хаками в языке С, то определение  <code>val</code> может показаться странным: он объявляется как массив символов с одним-единственным элементом. Но мы же наверняка захотим хранить строки длиной больше, чем один символ. Здесь используется метод под названием «структурный хак» (struct hack): массив хоть и объявляется с одним элементом, но при создании <code>zend_string</code> мы определим возможность хранения более длинной строки. Кроме того, можно будет получить доступ к более длинным строкам с помощью <code>val</code>.</p>
<p>Новая реализация строковой переменной имеет ряд преимуществ перед обычными строками в языке С. Во-первых, в неё теперь интегрирована длина, которая больше не «болтается» где-то поблизости. Во-вторых, в заголовке используется подсчёт ссылок, поэтому стало возможным использовать строки в разных местах без применения <code>zval</code>. Это особенно важно для расшаривания ключей хэш-таблицы.</p>
<p>Но есть и большая ложка дёгтя. Получить из <code>zend_string</code> строку языка С легко (с помощью str-&gt;val), а вот из С-строки напрямую получить <code>zend_string</code>  нельзя. Для этого придётся скопировать значение строки в заново созданный zend_string. Особенно досадно, когда дело доходит до работы с текстовыми строками (literal string), то есть постоянными строками (constant string), встречающимися в исходном С-коде.</p>
<p>Изолированные (interned) строки — это такие строки, которые не уничтожаются до завершения запроса и потому не нуждаются в использовании счётчика ссылок. Они дедуплицированы, поэтому при создании новой изолированной строки движок сначала проверяет, нет ли другой с таким же значением. Вообще все строки, имеющиеся в PHP-коде (включая переменные, названия функций и т.д.), обычно являются изолированными. Неизменяемые строки — это изолированные строки, созданные до начала запроса. Они не уничтожаются по окончании запроса, в отличие от изолированных.</p>
<p>Если используется OPCache, то изолированные строки будут храниться в общей памяти (SHM) и использоваться всеми PHP-процессами. В этом случае неизменяемые строки становятся бесполезными, поскольку изолированные и так не будут уничтожены.</p>
<h2 id="Классы-и-объекты"><a class="header" href="#Классы-и-объекты">Классы и объекты</a></h2>
<p>Классы:</p>
<ul>
<li>Классы занимают много памяти.</li>
<li>Внутренние классы гораздо лучше оптимизированы по сравнению с пользовательскими, потому что последние должны быть созданы и уничтожены при каждом запросе. Внутренние классы существуют постоянно.</li>
<li>Классы, интерфейсы и трейты используют одни и те же структуру и процедуры, различия очень малы.</li>
<li>Во время наследования или объявления процесс привязки сильно и долго нагружает процессор, но памяти задействуется немного, поскольку многие вещи не дуплицируются, а используются совместно. Кроме того, лучше запускать привязку классов во время компиляции.</li>
</ul>
<p>Объекты</p>
<p>PHP7 отказались от двойного подсчёта ссылок, уменьшили потребление памяти и количество косвенной адресации. Так выглядит новая структура zend_object:</p>
<pre><code class="language-c">struct _zend_object {
    zend_refcounted   gc;
    uint32_t          handle;
    zend_class_entry *ce;
    const zend_object_handlers *handlers;
    HashTable        *properties;
    zval              properties_table[1];
};
</code></pre>
<p>Эта структура — почти всё, что осталось от объекта. zend_object_value, заменённый прямым указателем на объект и хранилище объектов, хоть и не исключён совсем, но на глаза попадается куда реже.</p>
<h2 id="Улучшение-производительности-php7"><a class="header" href="#Улучшение-производительности-php7">Улучшение производительности PHP7</a></h2>
<ul>
<li>
<p><strong>Упакованные массивы</strong> — Они потребляют меньше памяти и во многих случаях работают гораздо быстрее традиционных массивов. Упакованные массивы должны удовлетворять критериям:</p>
<ul>
<li>Ключи — только целочисленные значения;</li>
<li>Ключи вставляются в массив только по возрастанию.</li>
</ul>
<p>Не забывайте: Если вам нужен список, то не используйте строки в ключах (это не даст применять оптимизацию упакованных массивов); Если ключи в списке только целочисленные, постарайтесь распределить их по возрастанию (в противном случае оптимизация тоже не сработает).</p>
</li>
<li>
<p><strong>Неизменяемые массивы</strong> - они являются частью расширения OPCache. Неизменяемые массивы — это массивы, заполненные неизменяемыми типами (нет переменных, нет вызовов функций, всё решается во время компиляции), которые не дуплицируются в памяти при переносе из одного места в другое в ходе runtime’а PHP. Также эти типы никогда не уничтожаются в памяти (от одного запроса к другому).</p>
</li>
<li>
<p>Оптимизация encapsed-строк</p>
</li>
<li>
<p>Целочисленные и значения с плавающей запятой в PHP 7 бесплатны</p>
<p>В PHP 7 совершенно иной способ размещения переменных в памяти. Вместо кучи они теперь хранятся в пулах стековой памяти. У этого есть побочный эффект: вы можете бесплатно повторно использовать контейнеры переменных (variable containers), память не выделяется. В PHP 5 такое невозможно, там для каждого создания/присвоения переменной нужно выделить немного памяти (что ухудшает производительность). В седьмой версии использование целочисленных и значений с плавающей запятой совершенно бесплатно: память нужного размера уже выделена для самих контейнеров переменных. </p>
</li>
<li>
<p>Reference mismatch</p>
</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li>
<p>http://www.phpinternalsbook.com/</p>
</li>
<li>
<p>https://romka.gitbooks.io/php-internals-book-ru/</p>
</li>
<li>
<p><a href="https://habr.com/post/162713/">Как устроены переменные в PHP</a></p>
</li>
<li>
<p><a href="https://habr.com/post/162685/">Как устроены массивы в PHP</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/257999/">Внутреннее представление значений в PHP7 (часть 1)</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/261131/">Внутреннее представление значений в PHP 7 (часть 2)</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/308240/">Массивы в РНР 7: хэш-таблицы</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/255237/">Подробно об объектах и классах в PHP</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/275497/">Объекты в PHP 7</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/318008/">Улучшение производительности PHP 7</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/310054/">Обзор расширения OPCache для PHP</a></p>
</li>
<li>
<p><a href="https://habr.com/company/mailru/blog/311068/">Трамплин вызова магических функций в PHP 7</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frameworks"><a class="header" href="#frameworks">Frameworks</a></h1>
<p>В этом разделе собрана разная фреймворкоспецифичная информация(Symfony и Laravel).</p>
<ul>
<li><a href="php/frameworks/laravel.html">Laravel</a> </li>
<li><a href="php/frameworks/symfony.html">Symfony</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="laravel"><a class="header" href="#laravel">Laravel</a></h1>
<p>Laravel — бесплатный веб-фреймворк с открытым кодом, предназначенный для <strong>разработки</strong> с использованием архитектурной модели MVC (англ. Model View Controller — модель-представление-контроллер). Laravel выпущен под лицензией MIT.</p>
<p>Ключевые особенности, лежащие в основе архитектуры Laravel:</p>
<ul>
<li><em>Пакеты</em> (packages) — позволяют создавать и подключать модули в формате <a href="https://ru.wikipedia.org/wiki/Composer">Composer</a> к приложению на Laravel. Многие дополнительные возможности уже доступны в виде таких модулей.</li>
<li><em>Eloquent ORM</em> — реализация <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">шаблона проектирования</a> <a href="https://ru.wikipedia.org/wiki/ActiveRecord">ActiveRecord</a> на PHP. Позволяет строго определить отношения между объектами <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">базы данных</a>. Стандартный для Laravel построитель запросов Fluent поддерживается ядром Eloquent.</li>
<li><em>Логика приложения</em> — часть разрабатываемого приложения, объявленная либо при помощи контроллеров, либо маршрутов (<a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">функций-замыканий</a>). Синтаксис объявлений похож на синтаксис, используемый в <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D1%8B%D0%B9_%D0%BA%D0%B0%D1%80%D0%BA%D0%B0%D1%81">каркасе</a> <a href="https://ru.wikipedia.org/wiki/Sinatra">Sinatra</a>.</li>
<li><em>Обратная маршрутизация</em> связывает между собой генерируемые приложением ссылки и маршруты, позволяя изменять последние с автоматическим обновлением связанных ссылок. При создании ссылок с помощью именованных маршрутов Laravel автоматически генерирует конечные URL.</li>
<li><em>REST-контроллеры</em> — дополнительный слой для разделения логики обработки GET- и POST-запросов HTTP.</li>
<li><em>Автозагрузка классов</em> — механизм автоматической загрузки классов <a href="https://ru.wikipedia.org/wiki/PHP">PHP</a> без необходимости подключать файлы их определений в <em>include</em>. Загрузка по требованию предотвращает загрузку ненужных компонентов; загружаются только те из них, которые действительно используются.</li>
<li><em>Составители представлений</em> (view composers) — блоки кода, которые выполняются при генерации представления (шаблона).</li>
<li><em>Инверсия управления</em> (Inversion of Control) — позволяет получать экземпляры объектов по принципу обратного управления. Также может использоваться для создания и получения <a href="https://ru.wikipedia.org/wiki/Singleton">объектов-одиночек</a> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> singleton).</li>
<li><em>Миграции</em> — система управления версиями для баз данных. Позволяет связывать изменения в коде приложения с изменениями, которые требуется внести в структуру БД, что упрощает развёртывание и обновление приложения.</li>
<li><em>Модульное тестирование</em> (<em>юнит-тесты</em>) — играет очень большую роль в Laravel, который сам по себе содержит большое число тестов для предотвращения <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">регрессий</a> (ошибок вследствие обновления кода или исправления других ошибок).</li>
<li><em>Страничный вывод</em> (pagination) — упрощает генерацию страниц, заменяя различные способы решения этой задачи единым механизмом, встроенным в Laravel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symfony"><a class="header" href="#symfony">Symfony</a></h1>
<h2 id="compiler-pass"><a class="header" href="#compiler-pass">Compiler Pass</a></h2>
<p>На этапе компиляции контейнер выполняет серию проходов для приведения своего содержимого в конечное состояние. Проходы являются реализацией интерфейса CompilerPassInterface и бывают 6 видов (в порядке исполнения): </p>
<p>merge, beforeOptimization, optimization, beforeRemoving, removing, afterRemoving  — по умолчанию конфигурация компилятора уже содержит набор проходов.</p>
<ul>
<li><em>before/after</em> — лишь «хуки» для пользовательских «проходов» и не используются стандартными (добавленными по умолчанию);</li>
<li><em>merge</em> — обрабатывает <em>расширения (extensions)</em> контейнера;</li>
<li><em>optimization</em> — оптимизируют контейнер, примерами могут служить: ResolveInterfaceInjectorsPass (преобразует <a href="http://martinfowler.com/articles/injection.html#InterfaceInjection">интерфейсные инъекции</a>), CheckCircularReferencesPass (проверяет циклические ссылки в контейнере)</li>
<li><em>removing</em> — удаляют неиспользуемые сервисы, например, RemoveUnusedDefinitionsPass (удаляет неиспользуемые приватные сервисы)</li>
</ul>
<p>В бандлах CompilerPass чаще всего используется для обработки тегов в контейнере</p>
<p>Пример из стандартного TwigBundle:</p>
<pre><code class="language-php">    $definition = $container-&gt;getDefinition('twig');
    $calls = $definition-&gt;getMethodCalls();
    $definition-&gt;setMethodCalls(array());
    foreach ($container-&gt;findTaggedServiceIds('twig.extension') as $id =&gt; $attributes) {
        $definition-&gt;addMethodCall('addExtension', array(new Reference($id)));
    }
    $definition-&gt;setMethodCalls(array_merge($definition-&gt;getMethodCalls(), $calls));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Разное-о-php"><a class="header" href="#Разное-о-php">Разное о PHP</a></h1>
<h2 id="Магические-методы-php"><a class="header" href="#Магические-методы-php">Магические методы PHP</a></h2>
<ul>
<li><a href="http://php.net/manual/ru/language.oop5.decon.php#object.construct"><strong>__construct()</strong></a> — метод конструктор, если он объявлен в классе то он будет вызываться при каждом создании объекта. Может принимать одно или несколько свойств.</li>
<li><a href="http://php.net/manual/ru/language.oop5.decon.php#object.destruct"><strong>__destruct()</strong></a> — деструктор вызывается при освобождении всех ссылок на объект в котором он находится или по завершению работы скрипта. Не может принимать свойства.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.get"><strong>__get()</strong></a> — будет выполнен при чтении данных из недоступных свойств.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.set"><strong>__set()</strong></a> — будет выполнен при записи данных в недоступные свойства.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.isset"><strong>__isset()</strong></a> будет выполнен при использовании isset() или empty() на недоступных свойствах.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.unset"><strong>__unset()</strong></a> — будет выполнен при вызове unset() на недоступном свойстве.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.call"><strong>__call()</strong></a> — данный метод вызывается при вызове недоступных методов класса.</li>
<li><a href="http://php.net/manual/ru/language.oop5.overloading.php#object.callstatic"><strong>__callStatic()</strong></a> —данный метод вызывается при вызове недоступных методов класса в статическом контексте.</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.tostring"><strong>__toString()</strong></a> — позволяет написать реакцию класса при возведении его в строку.</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.invoke"><strong>__invoke()</strong></a> — вызывается, когда скрипт выполняет объект как функцию.</li>
<li><a href="http://php.net/manual/ru/language.oop5.cloning.php#object.clone"><strong>__clone()</strong></a> — клонирует объект.</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.sleep"><strong>__sleep()</strong></a> — метод вызывается перед выполнением функции serialize().</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.wakeup"><strong>__wakeup()</strong></a> — метод вызывается перед выполнением функции unserialize()</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.set-state"><strong>__set_state()</strong></a> — этот статический метод вызывается для тех классов, которые экспортируются функцией var_export()</li>
<li><a href="http://php.net/manual/ru/language.oop5.magic.php#object.debuginfo"><strong>__debugInfo()</strong></a> — метод вызывается функцией <a href="http://php.net/manual/ru/function.var-dump.php">var_dump()</a>, когда необходимо вывести список свойств объекта. Если этот метод не определен, тогда будут выведены все свойства объекта c модификаторами public, protected и private.</li>
</ul>
<h2 id="psr-0-vs-psr-4"><a class="header" href="#psr-0-vs-psr-4">PSR-0 vs PSR-4</a></h2>
<p>Here are the major differences,</p>
<p><strong>1.</strong> For example if you define that the <code>Acme\Foo\</code> namespace is anchored in <code>src/</code>,</p>
<ul>
<li>
<p>with PSR-0 it means it will look for <code>Acme\Foo\Bar</code> in <code>src/Acme/Foo/Bar.php</code></p>
</li>
<li>
<p>while in PSR-4 it will look for <code>Acme\Foo\Bar</code> in <code>src/Bar.php(where Bar class is)</code>.
<strong>2.</strong> PSR-4 does not convert underscores to directory separators
<strong>3.</strong> You would prefer using PSR-4 with namespaces
<strong>4.</strong> PSR-0 will not work even if the class name is different from file name, like considering above example:</p>
</li>
<li>
<p><code>Acme\Foo\Bar</code> ---&gt; <code>src/Acme/Foo/Bar.php</code> (for Bar class) will work</p>
</li>
<li>
<p><code>Acme\Foo\Bar</code> ---&gt; <code>src/Acme/Foo/Bar2.php</code> (for Bar class) will not work</p>
</li>
</ul>
<h2 id="Замыкания-и-лямда-функции"><a class="header" href="#Замыкания-и-лямда-функции">Замыкания и лямда функции</a></h2>
<p>Анонимные функции, также известные как замыкания (<em>closures</em>), позволяют создавать функции, не имеющие определенных имен. Они наиболее полезны в качестве значений <a href="http://php.net/manual/ru/language.pseudo-types.php#language.types.callback">callback</a>-параметров, но также могут иметь и множество других применений.</p>
<p>Анонимные функции реализуются с использованием класса <a href="http://php.net/manual/ru/class.closure.php">Closure</a>.</p>
<p>В пхп замыканием считает любая анонимная функция, которая может использовать переменные из внешнего(для функции) контекста с помощью конструкции use.</p>
<pre><code class="language-php">$message = 'привет';

$example = function () use ($message) {
    var_dump($message);
};
$example();
</code></pre>
<h3 id="Как-передать-функцию-как-callable"><a class="header" href="#Как-передать-функцию-как-callable">Как передать функцию как callable?</a></h3>
<ul>
<li>Анонимная функция</li>
<li>Имя функции как строку</li>
<li>Переменную, содержащую функцию</li>
<li>Массив вида <code>[(className || objectName), method name]</code></li>
<li>Замыкание в котором дернуть метод объекта</li>
<li>Объект с реализованным методом <code>__invoke()</code></li>
</ul>
<h2 id="composer"><a class="header" href="#composer">Composer</a></h2>
<h3 id="composerjson-vs-composerlock"><a class="header" href="#composerjson-vs-composerlock">composer.json vs composer.lock</a></h3>
<ul>
<li><code>composer.json</code> - содержит допустимые &quot;диапазоны&quot; версий для пакетов</li>
<li><code>composer.lock</code> - точные версии установленных пакетов, с которыми работает данная версия(коммит) приложения. Так же в отличие от <code>composer.json</code> в <code>lock</code> файл пишутся ВСЕ зависимости которые нужны проекту - например вы зависите от пакета Б, а он зависит от пакета В определенной версии. Пакет В в этом случае попадет в ваш lock файл, и так до конца цепочки зависимостей.</li>
</ul>
<h3 id="install-vs-update-vs-require"><a class="header" href="#install-vs-update-vs-require">install vs update vs require</a></h3>
<p><code>composer install</code> делает следующее:</p>
<ul>
<li>Проверяет, существует ли <code>composer.lock</code></li>
<li>если нет, резолвит зависимости и создаёт его</li>
<li>если <code>composer.lock</code> существует, устанавливает версии, указанные в нём</li>
</ul>
<p><code>composer update</code>:</p>
<ul>
<li>Проверяет <code>composer.json</code></li>
<li>Определяет последние версии на основе указанных в этом файле</li>
<li>Устанавливает последние версии</li>
<li>Обновляет <code>composer.lock</code> в соответствии с установленными</li>
</ul>
<p><code>composer require somePackage</code>:</p>
<p>For example if we want to add a dependency with the command line we will simply execute </p>
<ul>
<li>composer.json file will be modified automatically and the new dependency will be added</li>
<li>the dependency will be downloaded to the project</li>
<li>http://php.net/manual/ru/class.splsubject.php</li>
</ul>
<h3 id="Варианты-ограничений-версий-для-composerjson"><a class="header" href="#Варианты-ограничений-версий-для-composerjson">Варианты ограничений версий для composer.json</a></h3>
<pre><code class="language-json">&quot;require&quot;: {
    &quot;vendor/package&quot;: &quot;1.3.2&quot;, // exactly 1.3.2

    // &gt;, &lt;, &gt;=, &lt;= | specify upper / lower bounds
    &quot;vendor/package&quot;: &quot;&gt;=1.3.2&quot;, // anything above or equal to 1.3.2
    &quot;vendor/package&quot;: &quot;&lt;1.3.2&quot;, // anything below 1.3.2

    // * | wildcard
    &quot;vendor/package&quot;: &quot;1.3.*&quot;, // &gt;=1.3.0 &lt;1.4.0

    // ~ | allows last digit specified to go up
    &quot;vendor/package&quot;: &quot;~1.3.2&quot;, // &gt;=1.3.2 &lt;1.4.0
    &quot;vendor/package&quot;: &quot;~1.3&quot;, // &gt;=1.3.0 &lt;2.0.0

    // ^ | doesn't allow breaking changes (major version fixed - following semver)
    &quot;vendor/package&quot;: &quot;^1.3.2&quot;, // &gt;=1.3.2 &lt;2.0.0
    &quot;vendor/package&quot;: &quot;^0.3.2&quot;, // &gt;=0.3.2 &lt;0.4.0 // except if major version is 0
}
</code></pre>
<h2 id="self-vs--static"><a class="header" href="#self-vs--static">Self vs  Static</a></h2>
<p>Позднее статическое связывание сохраняет имя класса указанного в последнем &quot;неперенаправленном вызове&quot;. В случае статических вызовов это явно указанный класс (обычно слева от оператора <a href="http://php.net/manual/ru/language.oop5.paamayim-nekudotayim.php"><em>::</em></a>); в случае не статических вызовов это класс объекта. &quot;Перенаправленный вызов&quot; - это статический вызов, начинающийся с <em>self::</em>, <em>parent::</em>, <em>static::</em>, или, если двигаться вверх по иерархии классов, <a href="http://php.net/manual/ru/function.forward-static-call.php">forward_static_call()</a>. Функция <a href="http://php.net/manual/ru/function.get-called-class.php">get_called_class()</a> может быть использована для получения строки с именем вызванного класса, а <em>static::</em> представляет ее область действия.</p>
<p>Само название &quot;позднее статическое связывание&quot; отражает в себе внутреннюю реализацию этой особенности. &quot;Позднее связывание&quot; отражает тот факт, что обращения через <em>static::</em> не будут вычисляться по отношению к классу, в котором вызываемый метод определен, а будут вычисляться на основе информации в ходе исполнения. Также эта особенность была названа &quot;статическое связывание&quot; потому, что она может быть использована (но не обязательно) в статических методах.</p>
<p>Говоря проще self - обращается непосредственно к классу, в котором описана ф-ция с его использованием, а static - к классу к которому идет обращение из кода.</p>
<h2 id="Можем-ли-мы-гарантировать-выполнения-деструктора"><a class="header" href="#Можем-ли-мы-гарантировать-выполнения-деструктора">Можем ли мы гарантировать выполнения деструктора?</a></h2>
<p>Деструктор не выполнится если:</p>
<ol>
<li>Exit вызван в другом деструкторе.</li>
<li>Если другой деструктор бросает исключение.</li>
<li>Если мы пытаемся обработать исключение в деструкторе.</li>
<li>При получении SIGTERM в случае запуска через CLI.</li>
<li>Fatal Error</li>
</ol>
<h2 id="Сессии"><a class="header" href="#Сессии">Сессии</a></h2>
<p>По умолчанию хранятся в файлах. Но можно переопределить:</p>
<pre><code class="language-ini">session.save_handler = memcached 
session.save_path = «tcp://192.1680.10:11211, tcp://192.168.0.20:11211»
</code></pre>
<p>Основная функция <strong>session_start()</strong>  - создает сессию, либо возобновляет существующую, основываясь на идентификаторе сессии, переданном через GET- или POST-запрос, либо переданный через cookie.</p>
<p>Когда вызвана функция <strong>session_start()</strong> или когда сессия создается автоматически, PHP вызовет открытие и чтение обработчиков записи сессии. Это могут быть как встроенные обработчики, так и предоставляемые расширениями (например, SQLite или Memcached); или вообще определенный пользователем обработчик, заданный функцией <a href="http://php.net/manual/ru/function.session-set-save-handler.php">session_set_save_handler()</a>. Callback-функция чтения извлечет все существующие данные сессии (сохраненные в специальном сериализованном виде), десериализует их и занесет в суперглобальный массив $_SESSION, после чего вернет сохраненные данные обработчику сессий PH</p>
<h2 id="Как-выполнить-код-после-exit"><a class="header" href="#Как-выполнить-код-после-exit">Как выполнить код после exit?</a></h2>
<p>You can use <a href="http://www.php.net/register_shutdown_function">register_shutdown_function()</a> to set a callback function which will be executed when PHP exits.</p>
<h2 id="Отладка-и-профилировка"><a class="header" href="#Отладка-и-профилировка">Отладка и профилировка</a></h2>
<h2 id="Анализаторы-кода"><a class="header" href="#Анализаторы-кода">Анализаторы кода</a></h2>
<ul>
<li><a href="http://www.program-transformation.org/PHP/PhpSat">php-sat</a> - Requires <a href="http://strategoxt.org/">http://strategoxt.org/</a></li>
<li><a href="http://pdepend.org/">PHP_Depend</a></li>
<li><a href="http://pear.php.net/package/PHP_CodeSniffer">PHP_CodeSniffer</a></li>
<li><a href="http://phpmd.org/">PHP Mess Detector</a></li>
<li><a href="https://github.com/phpstan/phpstan">PHPStan</a></li>
<li><a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">PHP-CS-Fixer</a></li>
<li><a href="https://github.com/phan/phan">phan</a></li>
</ul>
<h2 id="Сегфолт-в-пхп-фпм-как-поймать-как-отловить-трейс"><a class="header" href="#Сегфолт-в-пхп-фпм-как-поймать-как-отловить-трейс">Сегфолт в пхп фпм, как поймать, как отловить трейс</a></h2>
<p><strong>Ошибка сегментации</strong> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> Segmentation fault, сокр. segfault, жарг. <em>сегфолт</em>) — ошибка, возникающая при попытке обращения к недоступным для записи участкам <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C">памяти</a> либо при попытке изменить память запрещённым способом</p>
<h2 id="Список-модулей-пхп"><a class="header" href="#Список-модулей-пхп">Список модулей пхп</a></h2>
<p><code>php -m</code></p>
<h2 id="spl"><a class="header" href="#spl">SPL</a></h2>
<p>Стандартная библиотека PHP (SPL) - это набор интерфейсов и классов, предназначенных для решения стандартных задач. Не требуется никаких внешних библиотек для сборки этого расширения, и оно доступно по умолчанию в PHP 5.0.0 и выше.</p>
<p>SPL предоставляет ряд стандартных структур данных, итераторов для оббегания объектов, интерфейсов, стандартных исключений, некоторое количество классов для работы с файлами и предоставляет ряд функций, например <a href="http://php.net/manual/ru/function.spl-autoload-register.php">spl_autoload_register()</a>. </p>
<p>Еще примеры:</p>
<ul>
<li><a href="http://php.net/manual/ru/class.countable.php">Countable</a></li>
<li><a href="http://php.net/manual/ru/class.outeriterator.php">OuterIterator</a></li>
<li><a href="http://php.net/manual/ru/class.recursiveiterator.php">RecursiveIterator</a></li>
<li><a href="http://php.net/manual/ru/class.seekableiterator.php">SeekableIterator</a></li>
<li><a href="http://php.net/manual/ru/class.arrayobject.php">ArrayObject</a></li>
<li><a href="http://php.net/manual/ru/class.splobserver.php">SplObserver</a></li>
</ul>
<h2 id="declarestrict_types1"><a class="header" href="#declarestrict_types1">declare(strict_types=1);</a></h2>
<p>By default, PHP will cast values of the wrong type into the expected scalar type if possible. For example, a function that is given an integer for a parameter that expects a string will get a variable of type string.</p>
<p>В случае включенного строгого режима будут фаталы при несовпадении типов. Строгий режим действует ТОЛЬКО внутри того файла, где он был объявлен.</p>
<h2 id="pecl"><a class="header" href="#pecl">PECL</a></h2>
<p>PECL (англ. PHP Extension Community Library) — это репозиторий модулей для PHP, написанных на C, доступных через систему пакетов PEAR. PECL был создан, когда возникла проблема удаления некоторых модулей из стандартной поставки PHP. Модули PECL разработаны в соответствии со стандартами кодирования, которые приняты командой разработчиков PHP.</p>
<h2 id="opcache"><a class="header" href="#opcache">OpCache</a></h2>
<p>Как работает php-интерпретатор - вначале, написанный нами код разбирается <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7">лексическим анализатором</a>. Далее, полученные лексемы, передаются в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7">синтаксический анализатор</a>. Если синтаксический анализатор дал добро, то лексемы передаются <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B0%D0%BD%D1%81%D0%BB%D1%8F%D1%82%D0%BE%D1%80">транслятору</a>, а он, в свою очередь, генерирует так называемые opcodes (operation codes). И только после этого, в дело вступает виртуальная машина PHP (та самая Zend Engine) которая и выполняет наш алгоритм из получившихся opcodes. Opcodes так же называют эдаким php-шным ассемблером.</p>
<p>Акселератор PHP — расширение для PHP, основное назначение которого — увеличение производительности интерпретатора при обработке сценариев путём кэширования их байт-кода.</p>
<p>PHP — это скриптовый язык, который по умолчанию компилирует те файлы, которые вам нужно запустить. Во время компилирования он извлекает опкоды, исполняет их, а затем немедленно уничтожает. PHP был так разработан: когда он переходит к выполнению запроса R, то «забывает» всё, что было выполнено в ходе запроса R-1.</p>
<p>Очень маловероятно, что на production-серверах PHP-код изменится между выполнением нескольких запросов. Так что можно считать, что при компилированиях всегда считывается один и тот же исходный код, а значит и опкод будет точно таким же. И если извлекать его для каждого скрипта, то получается бесполезная трата времени и ресурсов.</p>
<p><img src="php/../media/phpCache.png" alt="" /></p>
<p>В связи с большой продолжительностью компилирования были разработаны расширения для кэширования опкодов. Их главная задача — <strong>единожды</strong> скомпилировать каждый PHP-скрипт и закэшировать получившиеся опкоды в общую память, чтобы их мог считать и выполнить каждый рабочий процесс PHP. В результате сильно повышается общая производительность языка, а на запуск скрипта уходит намного меньше времени (сильно зависит от самого скрипта). </p>
<p>OPCache — это расширение, внедрённое в исходный код PHP начиная с версии 5.5.0. Его необходимо активировать с помощью обычного процесса активации через php.ini. У OPCache есть две основные функции:</p>
<ul>
<li>Кэширование опкодов.</li>
<li>Оптимизация опкодов.</li>
</ul>
<p>Поскольку OPCache запускает компилятор, чтобы получить и закэшировать окоды, то он может использовать этот этап для их оптимизации. По сути речь идёт разнообразных оптимизациях компилятора. OPCache работает как многопроходный оптимизатор компилятора.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/company/mailru/blog/310054/">Обзор расширения OPCache для PHP</a></li>
<li><a href="https://habr.com/post/233129/">Исследуем результат работы php-транслятора</a></li>
</ul>
<h2 id="Демон-на-php"><a class="header" href="#Демон-на-php">Демон на php</a></h2>
<p>Применимо к PHP, это скрипт, который может работать самостоятельно, без остановок и без участия пользователя. Как получить такой скрипт? На самом деле, очень просто, нужно лишь нарушить одно из первых правил программирования, которому учат в школе, и <strong>создать бесконечный цикл:</strong></p>
<pre><code class="language-php">// Чтобы программа работала постоянно, она просто должна постоянно работать ;)
while(1) {
    // Тут будет располагаться код Демона
    // Время сна Демона между итерациями (зависит от потребностей системы)
    sleep(1); 
}
</code></pre>
<p>Что он должен уметь?</p>
<ul>
<li>Запускаться из консоли и отвязываться от неё</li>
<li>Всю информацию писать в логи, ничего не выводить в консоль</li>
<li>Уметь плодить дочерние процессы и контролировать их</li>
<li>Выполнять поставленную задачу</li>
<li>Корректно завершать работу</li>
</ul>
<h2 id="pcntl-в-php"><a class="header" href="#pcntl-в-php">PCNTL в PHP</a></h2>
<p>Если вы (либо операционная система) прерываете какой-то скрипт (процесс), то никакого &quot;прерывания&quot; не происходит. На самом деле, скрипту (процессу) посылается специальный сигнал &quot;остановиться&quot;. В ответ на этот сигнал скрипт может отправить сообщение &quot;подождать&quot;, тогда ОС подождет. По умолчанию, если никакого ответа от скрипта нет, он останавливается сразу.</p>
<p>Расширение <a href="http://php.net/manual/ru/intro.pcntl.php">pcntl</a> позволяет получать и обрабатывать сигналы от операционной системы в PHP скриптах.</p>
<p>Простой скрипт, который перехватывает сигнал окончания работы SIGTERM:</p>
<pre><code class="language-php">&lt;?

# назначаем обработчик сигнала
declare(ticks = 1);
pcntl_signal(SIGTERM, &quot;sig_handler&quot;);

# обработчик сигнала
function sig_handler($signo)
{
        echo &quot;\n&quot; . 'received signal ' . $signo . &quot;\n&quot;;
}

# бесконечный цикл
while ( true )
{
	for ( $i = 0; $i &lt; 3; $i++ )
	{
		echo '.';
		sleep(1);
	}

	echo &quot;\n&quot;;
}
</code></pre>
<ul>
<li>Инструкция declare(ticks = 1) нужна для инициализации обработки сигналов. Используйте ее в начале каждого скрипта, в котором нужен обработчик.</li>
<li><a href="https://ruhighload.com/doc/php/function.pcntl-signal">pcntl_signal</a> назначает обработчик определенному сигналу.</li>
<li>В функции sig_handler() мы перехватываем сигнал и обрабатываем его. В нашем примере — просто выводим текст, вместо завершения скрипта.</li>
</ul>
<p>Если запустить этот скрипт (php test.php), а в соседнем терминале попытаться его прервать командой pkill -f test.php, увидим такой вывод:</p>
<pre><code class="language-bash">den@den:~# php test.php 
...
received signal 15
...
...
.
received signal 15
...
</code></pre>
<p>Для фоновых скриптов удобно использовать обработчики сигналов, чтобы обеспечить их правильную остановку и перезапуск. Сигналы SIGTERM и SIGNINT используются для прекращения работы скрипта, SIGHUP используется для перезапуска. В PHP обработка сигналов происходит с помощью функции <a href="https://ruhighload.com/doc/php/function.pcntl-signal">pcntl_signal</a>.</p>
<p>Функция <strong>pcntl_fork()</strong> создает дочерний процесс, который отличается от родительского процесса только его PID и PPID. Пожалуйста, обратитесь к вашему системному руководству (man) fork(2) для ознакомления со спецификой работы fork на вашей системе. В случае успеха, PID дочернего процесса будет возвращен в родительском потоке (thread) запуска и 0 будет возвращен в дочернем потоке запуска. В случае сбоя, в родительский контекст будет возвращено -1, дочерний процесс создан не будет и PHP сгенерирует соответствующую ошибку.</p>
<h2 id="Получить-тело-http-запроса-в-php"><a class="header" href="#Получить-тело-http-запроса-в-php">Получить тело HTTP запроса в PHP</a></h2>
<p>To access the entity body of a POST or PUT request (or any other HTTP method):</p>
<pre><code class="language-php">$entityBody = file_get_contents('php://input');
</code></pre>
<p>Also, the <code>STDIN</code> constant is an already-open stream to <code>php://input</code>, so you can alternatively do:</p>
<pre><code class="language-php">$entityBody = stream_get_contents(STDIN);
</code></pre>
<p>From the <a href="http://php.net/manual/en/wrappers.php.php">PHP manual entry on I/O streams<em>docs</em></a>:</p>
<blockquote>
<p><em>php://input</em> is a read-only stream that allows you to read raw data from the request body. In the case of POST requests, it is preferable to use <em>php://input</em> instead of <code>$HTTP_RAW_POST_DATA</code> as it does not depend on special php.ini directives. Moreover, for those cases where<code>$HTTP_RAW_POST_DATA</code> is not populated by default, it is a potentially less memory intensive alternative to activating always_populate_raw_post_data. <em>php://input</em> is not available with enctype=&quot;multipart/form-data&quot;.</p>
</blockquote>
<p>Specifically you'll want to note that the <code>php://input</code> stream, regardless of how you access it in a web SAPI, <em>is not seekable</em>. This means that it can only be read once. If you're working in an environment where large HTTP entity bodies are routinely uploaded you may wish to maintain the input in its stream form (rather than buffering it like the first example above).</p>
<p>To maintain the stream resource something like this can be helpful:</p>
<pre><code class="language-php">&lt;?php

function detectRequestBody() {
    $rawInput = fopen('php://input', 'r');
    $tempStream = fopen('php://temp', 'r+');
    stream_copy_to_stream($rawInput, $tempStream);
    rewind($tempStream);

    return $tempStream;
}
</code></pre>
<p><code>php://temp</code> allows you to manage memory consumption because it will transparently switch to filesystem storage after a certain amount of data is stored (2M by default). This size can be manipulated in the php.ini file or by appending <code>/maxmemory:NN</code>, where <code>NN</code> is the maximum amount of data to keep in memory before using a temporary file, in bytes.</p>
<h2 id="Трейты"><a class="header" href="#Трейты">Трейты</a></h2>
<p>Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного наследования, таких как PHP. Трейт предназначен для уменьшения некоторых ограничений одиночного наследования, позволяя разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и реализованных с использованием разных архитектур построения классов. Семантика комбинации трейтов и классов определена таким образом, чтобы снизить уровень сложности, а также избежать типичных проблем, связанных с множественным наследованием и смешиванием (mixins).</p>
<p>Трейт очень похож на класс, но предназначен для группирования функционала хорошо структурированым и последовательным образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию и позволяет сделать горизонтальную композицию поведения, то есть применение членов класса без необходимости наследования.</p>
<pre><code class="language-php">trait GeneratesDomainEvents
{
    private $events = [];

    protected function raise(DomainEvent $event)
    {
        $this-&gt;events[] = $event;
    }

    public function releaseEvents()
    {
        $pendingEvents = $this-&gt;events;
        $this-&gt;events = [];
        return $pendingEvents;
    }
}
</code></pre>
<p>Мы можем <a href="https://gist.github.com/rosstuck/09804eed5fb9020a1ff0">сделать рефакторинг и превратить этот код в абстракцию</a>, но это все равно будет хорошим примером того, как трейты могут работать с локальным состоянием объекта в отличие от статических методов. Мы не хотим работать с массивом событий вслепую или перемещать его из объекта. Возможно, мы не хотим добавлять еще одну абстракцию внутрь модели, и нам, конечно же, не хочется копипастить этот шаблонный код везде. И тут опять нам помогут трейты. </p>
<p>Другими практическими примерами могут служить настраиваемое логирование функций, дамп нескольких свойств сразу или общая итерационная/поисковая логика. Мы могли бы решить все эти задачи родительским классом, но поговорим об этом чуть позже.</p>
<p>И наконец, следует помнить, что <strong>трейты не предполагают абстракцию и они не являются композицией</strong>, но все равно имеют право занять место среди ваших инструментов. Они полезны для предоставления воздействия по-умолчанию при более мелких реализациях или дублировании кода. Всегда будьте готовы реорганизовать их для лучшей абстракции, как только почувствуете признаки кода «с запашком»</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://habr.com/ru/post/258671/">Как я использую трейты</a></li>
</ul>
<h2 id="Генераторы-и-корутины"><a class="header" href="#Генераторы-и-корутины">Генераторы и корутины</a></h2>
<p>Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов или сложностей, связанных с реализацией класса, реализующего интерфейс Iterator.</p>
<p>Генератор позволяет вам писать код, использующий foreach для перебора набора данных без необходимости создания массива в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания. Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того, что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для генерации значений, позволяющих перебрать исходный набор данных.</p>
<p>Преимущества такого подхода должны быть очевидны. Таким образом вы можете работать с очень большими наборами данных, не загружая их всех в память. Вы даже можете работать с <em>бесконечными</em> потоками данных. Все это также может быть сделано без генераторов, создав класс имплементирующий интерфейс <code>Iterator</code>. Генераторы просто делают это (гораздо) более простым занятием, потому что вам не нужно имплементировать пять разных методов для каждого итератора.</p>
<p>Вся суть генератора заключается в ключевом слове <strong>yield</strong>. В самом простом варианте оператор &quot;yield&quot; можно рассматривать как оператор &quot;return&quot;, за исключением того, что вместо прекращения работы функции, &quot;yield&quot; только приостанавливает ее выполнение и возвращает текущее значение, и при следующем вызове функции она возобновит выполнения с места, на котором прервалась.</p>
<p>Главное преимущество генераторов - это их простота. Гораздо меньше шаблонного кода надо написать, по сравнению с реализацией объекта класса Iterator, и этот код гораздо более простой и понятный. Однако за эту простоту, впрочем, приходится платить: генераторы могут быть только однонаправленными итераторами. Их нельзя перемотать назад после старта итерации. Это также означает, что один и тот же генератор нельзя использовать несколько раз: генератор необходимо пересоздавать каждый раз, снова вызвав функцию генератора.</p>
<p>В PHP 5 генераторы не могут возвращать значений и попытка сделать это приведет к ошибке компиляции. В генераторе может присутствовать только пустой оператор <strong>return</strong>, для обозначения конца генерируемой последовательности. Начиная с PHP 7 генераторы могут возвращать значения, которые можно получить с помощью <a href="http://php.net/manual/ru/generator.getreturn.php">Generator::getReturn()</a>.</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://habr.com/post/164173/">Coroutines в PHP и работа с неблокирующими функциями</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="golang"><a class="header" href="#golang">GoLang</a></h2>
<p><strong>Go</strong> (Golang) — компилируемый многопоточный язык программирования.</p>
<p>Язык Go разрабатывался как язык программирования для создания высокоэффективных программ, работающих на современных распределённых системах и многоядерных процессорах. Он может рассматриваться, как попытка создать замену языкам Си и C++. Компилируемый язык. Предполагается, что программы на Go будут транслироваться компилятором в объектный код целевой аппаратной платформы и в дальнейшем исполняться непосредственно, не требуя виртуальной машины. Архитектура языка изначально проектировалась так, чтобы обеспечить быструю компиляцию в эффективный объектный код. </p>
<ul>
<li>
<p><a href="goLang/types.html">Типы данных</a></p>
</li>
<li>
<p><a href="goLang/concurrency/README.html">Сoncurrency</a></p>
<ul>
<li><a href="goLang/concurrency/chanel.html">Каналы</a></li>
<li><a href="goLang/concurrency/gouritine.html">Горутины</a></li>
<li><a href="goLang/concurrency/sync.html">Sync</a></li>
<li><a href="goLang/concurrency/patterns.html">Паттерны</a></li>
</ul>
</li>
<li>
<p><a href="goLang/scheduler.html">Планировщик</a></p>
</li>
<li>
<p><a href="goLang/memory.html">Управление памятью</a></p>
</li>
<li>
<p><a href="goLang/ecosystem.html">Экосистема</a></p>
</li>
</ul>
<h2 id="Вопросы"><a class="header" href="#Вопросы">Вопросы</a></h2>
<ul>
<li>
<p>Как хранятся переменные в Golang?</p>
</li>
<li>
<p>Что представляет собой тип данных string в Go?</p>
</li>
<li>
<p>Что вернет функция len(), примененная к строке?</p>
</li>
<li>
<p>Что собой представляет тип данных rune?</p>
</li>
<li>
<p>Как устроен слайс и чем он отличается от массива?</p>
</li>
<li>
<p>Как работает функция append? Что происходит с capacity и базовым массивом?</p>
</li>
<li>
<p>Как создать многомерный массив в Golang</p>
</li>
<li>
<p>Нужно ли передавать slice по ссылке в функцию?</p>
</li>
<li>
<p>Что представляет собой map?</p>
</li>
<li>
<p>Чем является функция в Go?</p>
</li>
<li>
<p>Что такое метод структуры? Что такое получатель (receiver) метода? В чем разница между получателем по значению и указателем?*** значения-методы и выражения-методы - в чем отличие?</p>
</li>
<li>
<p>Что такое интерфейсы? Как устроен пустой интерфейс?</p>
</li>
<li>
<p>Как огранить число потоков на системы при запуске Golang программы и возможно ли огранить их до 1 потока?</p>
</li>
<li>
<p>Что такое каналы и каких видов они бывают? Что будет если писать в закрытый канал? Что будет если писать в неинициализированный канал?</p>
</li>
<li>
<p>Как в golang освобождает память и можно ли отключить это поведение и зачем это делать?</p>
</li>
<li>
<p>Что представляют собой каналы? Какой дефолтный размер буфера у канала? Что вернет получение значения из закрытого канала? Что произойдет при записи значения в закрытый канал?</p>
</li>
<li>
<p>В чем отличие буферизированного канала от небуферизированного?</p>
</li>
<li>
<p>Каким способом происходит отмена работы других горутин? Почему важно завершать горутины по окончании / прерывании работы главной программы?</p>
</li>
<li>
<p>Что такое гонка данных (race condition, состояние гонки)? Какие существуют способы избежать состояния гонки в Go?</p>
</li>
<li>
<p>Что такое семафор? Бинарный семафор? Что такое mutex? Какие бывают виды mutex в Go?</p>
</li>
<li>
<p>В чем различия goroutine от потока системы?</p>
</li>
<li>
<p>Расскажите об ООП в Golang</p>
</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://golang.org/src/runtime/chan.go">Исходный код</a></li>
<li><a href="https://golang.org/ref/spec#Channel_types">Каналы в спецификации Go</a></li>
<li><a href="https://docs.google.com/document/d/1yIAYmbvL3JxOKOjuCyon7JhW4cSv1wy5hC0ApeGMV9s/pub">Каналы Go на стероидах</a></li>
<li><a href="https://habr.com/ru/company/ua-hosting/blog/269271/">Планировщик Go</a></li>
<li><a href="https://habr.com/ru/post/333654/">Work-stealing планировщик в Go</a></li>
<li><a href="https://habr.com/ru/post/325468">Как не наступать на грабли в Go</a></li>
<li><a href="https://go-traps.appspot.com/">Go Traps</a></li>
<li><a href="https://habr.com/ru/post/457728">Хэш таблицы в Go. Детали реализации</a></li>
<li><a href="https://yourbasic.org/">Algorithms to Go</a></li>
<li><a href="https://habr.com/ru/post/441842/">Практичный Go: советы по написанию поддерживаемых программ в реальном мире</a></li>
<li><a href="https://habr.com/ru/company/mailru/blog/314804/">50 оттенков Go: ловушки, подводные камни и распространённые ошибки новичков</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-данных-1"><a class="header" href="#Типы-данных-1">Типы данных</a></h1>
<h2 id="Фундаментальные-типы"><a class="header" href="#Фундаментальные-типы">Фундаментальные типы</a></h2>
<h3 id="Целочисленные-типы"><a class="header" href="#Целочисленные-типы">Целочисленные типы</a></h3>
<ul>
<li><strong>int8</strong>, <strong>int16</strong>, <strong>int32</strong>, <strong>int64</strong>, <strong>int</strong></li>
<li><strong>uint8</strong>, <strong>uint16</strong>, <strong>uint32</strong>, <strong>uint64</strong>, <strong>uint</strong></li>
<li><strong>byte</strong>: синоним типа <strong><code>uint8</code></strong></li>
<li><strong>rune</strong>: синоним типа <strong><code>int32</code></strong></li>
</ul>
<p>Стоит отметить типы <strong>int</strong> и <strong>uint</strong>. Они имеют наиболее эффективный размер для определенной платформы (32 или 64 бита). Это наиболее используемый тип для представления целых чисел в программе. Причем различные компиляторы могут предоставлять различный размер для этих типов даже для одной и той же платформы. </p>
<h3 id="Числа-с-плавающей-точкойдробные"><a class="header" href="#Числа-с-плавающей-точкойдробные">Числа с плавающей точкой(дробные)</a></h3>
<ul>
<li><strong>float32</strong>: представляет число с плавающей точкой от 1.4<em>10-45 до 3.4</em>1038(для положительных). Занимает в памяти 4 байта (32 бита)</li>
<li><strong>float64</strong>: представляет число с плавающей точкой от 4.9<em>10-324 до 1.8</em>10308 (для положительных) и занимает 8 байт.</li>
</ul>
<p>Тип <strong>float32</strong> обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом <strong>float64</strong>, составляет около 15 цифр. В качестве разделителя между целой и дробной частью применяется точка.</p>
<h3 id="Комплексные-числа"><a class="header" href="#Комплексные-числа">Комплексные числа</a></h3>
<ul>
<li><strong>complex64</strong>: комплексное число, где вещественная и мнимая части представляют числа float32</li>
<li><strong>complex128</strong>: комплексное число, где вещественная и мнимая части представляют числа float64</li>
</ul>
<h3 id="Тип-bool"><a class="header" href="#Тип-bool">Тип bool</a></h3>
<p>Логический тип или тип bool может иметь одно из двух значений: <strong>true</strong> (истина) или <strong>false</strong> (ложь).</p>
<h3 id="Строки-1"><a class="header" href="#Строки-1">Строки</a></h3>
<p>Строки же представляют собой <strong>неизменяемый</strong> последовательный набор byte <strong>фиксированного размера</strong>. Это означает, что вы не можете изменять строки — только создавать новые. Это важно понимать в контексте производительности программы. В программах, где нужна очень высокая производительность, постоянное создание большого количества строк создаст ощутимую нагрузку на сборщик мусора.</p>
<p>С юникод строками удобнее работать как со слайсами из <strong>rune</strong></p>
<pre><code class="language-go">func main() {
   message := &quot;Строка&quot;

    // тут перебираем строку как массив байт
   for i := 0; i &lt; len(message); i++ {
      fmt.Printf(&quot;Type: %T, Val: %s\n&quot;, message[i], string(message[i])) // Type: uint8, Val: Ð
   }

   // тут как массив рун
   for _, val := range message {
      fmt.Printf(&quot;Type: %T, Val: %s\n&quot;, val, string(val)) // Type: int32, Val: С
   }
}
</code></pre>
<h3 id="Константы"><a class="header" href="#Константы">Константы</a></h3>
<p>Константы вычисляются на тапе компиляции и не меняются в рантайме. Имеют интересную систему типов(чуть отличающуюся от фундаментальных), имеют повышенную точность. Есть генератор констант <strong>iota</strong>.</p>
<h3 id="Значение-по-умолчанию"><a class="header" href="#Значение-по-умолчанию">Значение по умолчанию</a></h3>
<p>Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число 0, для логического типа - false, для строк - &quot;&quot;(пустая строка).</p>
<h2 id="Составные"><a class="header" href="#Составные">Составные</a></h2>
<h3 id="Массив-1"><a class="header" href="#Массив-1">Массив</a></h3>
<p>По определению тип массива состоит из длины и типа его элементов. Например, тип <code>[4]int</code> представляет массив из четырёх целых чисел. Размер массива неизменяем; его <em>длина - это часть его типа</em> (<code>[4]int</code> и <code>[5]int</code> различные, несовместимые типы). Массивы могут быть проиндексированы, поэтому с помощью выражения <code>s[n]</code> мы получаем доступ к n-ному элементу, начиная с нуля. Массивы не нужно инициализировать явно; нулевой массив - это готовый к использованию массив, элементы которого являются нулями:</p>
<pre><code class="language-go">var a [4]int
a[0] = 1
// a[2] == 0, нулевое значение типа int
</code></pre>
<p>Представление [4]int в памяти - это просто четыре целых значения, расположенных последовательно:</p>
<img src="goLang/../media/go/slice-array.png" max-width="100%"/>
<p>Массивы в Go и есть значения. Переменная с именем массива обозначает весь массив; это не указатель на первый элемент (как это было бы в случае С). Это значит, что когда вы присваиваете значение или проходитесь по массиву, вы будете делать копию его содержимого (для избежания копирования, вы могли бы передавать указатель на массив, но тогда это будет указатель на него, а не сам массив). </p>
<p>Литерал массива может быть задан так + можете указать компилятору посчитать количество значений:</p>
<pre><code class="language-go">b := [2]string{&quot;Penn&quot;, &quot;Teller&quot;}
с := [...]string{&quot;Penn&quot;, &quot;Teller&quot;}
</code></pre>
<h3 id="Слайсы"><a class="header" href="#Слайсы">Слайсы</a></h3>
<p>Слайс - это дескриптор сегмента массива. Он состоит из указателя на массив, длины сегмента и его вместимости (максимальной длины сегмента).</p>
<pre><code class="language-go">type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
</code></pre>
<p>Наша переменная <code>s</code>, созданная ранее с помощью <code>make([]byte, 5)</code>, имеет такую структуру:</p>
<img src="goLang/../media/go/slice-1.png" max-width="100%"/>
<p>Длина - это число элементов, на которое ссылается слайс. Вместимость - это число элементов лежащего в основе массива (начиная с элемента, на который ссылается указатель слайса). Разница между длиной и вместимостью станет чётче по ходу знакомства с остальными примерами.</p>
<p>По мере изменения промежутков слайса, можно наблюдать изменения в структуре данных слайса и их отношениях с лежащим в основе массивом:</p>
<pre><code class="language-go">s = s[2:4]
</code></pre>
<img src="goLang/../media/go/slice-2.png" max-width="100%"/>
<p>Слайсниг не производит копирование данных слайса. Создаётся новое значение слайса, указывающее на исходный массив. Это делает операцию слайсинга такой же эффективной, как и манипуляции с индексами массива. Таким образом, изменение элементов (не самого слайса) нового слайса изменяет элементы исходного:</p>
<pre><code class="language-go">d := []byte{'r', 'o', 'a', 'd'}
e := d[2:] 
// e == []byte{'a', 'd'}
e[1] = 'm'
// e == []byte{'a', 'm'}
// d == []byte{'r', 'o', 'a', 'm'}
</code></pre>
<p>Ранее мы слайсили <code>s</code> до длины, меньшей, чем вместимость. Мы можем увеличить <code>s</code> до её вместимости, сделав слайсинг снова. Слайс нельзя сделать большим, чем его вместимость. Если вы попытаетесь, это вызовет панику времени выполнения, как и когда происходит обращение к индексу вне границ слайса или массива.</p>
<h2 id="Увеличение-слайсов-функции-copy-и-append"><a class="header" href="#Увеличение-слайсов-функции-copy-и-append">Увеличение слайсов (функции copy и append)</a></h2>
<p>Для увеличения вместимости слайса необходимо создать новый, более крупный слайс и скопировать элементы исходного слайса в него. Эта техника показывает, как реализуются динамические массивы в других языках. Следующий пример удваивает вместимость <code>s</code>, создавая новый слайс <code>t</code>, копируя содержимое <code>s</code> в <code>t</code>, а затем присваивая <code>s</code> значение слайса <code>t</code>:</p>
<pre><code class="language-go">t := make([]byte, len(s), (cap(s)+1)*2) // +1 в случае cap(s) == 0
for i := range s {
        t[i] = s[i]
}

s = t
</code></pre>
<p>Повторяющаяся часть этой часто используемой операции реализована с помощью простой встроенной функции <code>copy</code>. Как подсказывает её имя, эта функция копирует данные из слайса-источника в слайс-приёмник. Возвращается количество скопированных элементов.</p>
<pre><code class="language-go">func copy(dst, src []T) int
</code></pre>
<p>Функция <code>copy</code> поддерживает копирование между слайсами разной длины (она скопирует только до меньшего числа элементов). К тому же, <code>copy</code> может справиться со слайсами, относящимися к одному массиву в основе этих слайсов, работая правильно с перекрытием слайсов.</p>
<p>Используя <code>copy</code>, можно упростить кусочек кода выше:</p>
<pre><code class="language-go">t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre>
<p>Часто необходимо добавить данные в конец слайса. Эта функция добавляет элементы в байтовый слайс, увеличивая сам слайс по необходимости, и возвращает обновлённый слайс:</p>
<pre><code class="language-go">func AppendByte(slice []byte, data ...byte) []byte {
    m := len(slice)
    n := m + len(data)
    if n &gt; cap(slice) { // если нужно, перераспределить память
        // выделяем в два раза больше нужного, для увеличения в будущем
        newSlice := make([]byte, (n+1)*2)
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:n]
    copy(slice[m:n], data)
    return slice
}
</code></pre>
<p>Можно было бы использовать AppendByte таким образом:</p>
<pre><code class="language-go">p := []byte{2, 3, 5}
p = AppendByte(p, 7, 11, 13)
// p == []byte{2, 3, 5, 7, 11, 13}
</code></pre>
<p>Такие функции, как AppendByte, полезны, потому что они предоставляют полный контроль над способом увеличения слайсов. В зависимости от характеристики программы может понадобиться создание более маленького или большого слайса, или загрузить слайс элементами до предельного размера памяти.</p>
<p>Хотя большинству программ не нужен абсолютный контроль, поэтому Go предоставляет встроенную функцию <code>append</code>, которая хорошо подходит в большинстве случаев. Она имеет такую сигнатуру:</p>
<pre><code class="language-go">func append(s []T, x ...T) []T
</code></pre>
<p>Эта функция добавляет элементы в конец слайса <code>s</code> и увеличивает вместимость, если нужно.</p>
<pre><code class="language-go">a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre>
<p>Чтобы добавить один слайс в другой, используйте <code>…</code> в качестве второго аргумента, чтобы он стал списком аргументов.</p>
<pre><code class="language-go">a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // то же самое, что и &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre>
<p>Так как нулевой слайс работает как слайс нулевой длины, вы можете объявить переменную со слайсом и затем циклично добавлять в неё элементы:</p>
<pre><code class="language-go">// Filter возвращает новый слайс,
// из элементов s, удовлетворяющих условиям функции f()
func Filter(s []int, fn func(int) bool) []int {
    var p []int // == nil
    for _, v := range s {
        if fn(v) {
            p = append(p, v)
        }
    }
    return p
}
</code></pre>
<h2 id="Возможная-ловушка"><a class="header" href="#Возможная-ловушка">Возможная ловушка</a></h2>
<p>Как говорилось ранее, переслайсинг (re-slicing) среза не создаёт копию массива в основании. Массив полностью будет существовать в памяти, пока на него не перестанут ссылаться. Иногда это вызывает хранение всех данных в памяти, когда нужна только их небольшая часть.</p>
<p>Например, функция <code>FindDigits</code> загружает файл в память и ищет в нём первую группу последовательных цифр, возвращая их в новом слайсе.</p>
<pre><code class="language-go">var digitRegexp = regexp.MustCompile(&quot;[0-9]+&quot;)

func FindDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    return digitRegexp.Find(b)
}
</code></pre>
<p>Этот код работает, как и говорилось, однако возвращаемый срез <code>[]byte</code> указывает на массив, содержащий файл целиком. Так как слайс ссылается на исходный массив, пока слайс есть в памяти, сборщик мусора не сможет очистить массив; несколько важных байтов файла держат всё содержимое в памяти.</p>
<p>Чтобы исправить это, можно скопировать интересующие нас данные в новый слайс до того, как вернуть значение.</p>
<pre><code class="language-go">func CopyDigits(filename string) []byte {
    b, _ := ioutil.ReadFile(filename)
    b = digitRegexp.Find(b)
    c := make([]byte, len(b))
    copy(c, b)
    return c
}
</code></pre>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p>Отображение или map представляет ссылку на хеш-таблицу - структуру данных, где каждый элемент представляет пару &quot;ключ-значение&quot;. При этом каждый элемент имеет уникальный ключ, по которому можно получить значение элемента. Отображение определяется как объект типа map[K]V, где К представляет тип ключа, а V - тип значения. Причем тип ключа K должен поддерживать операцию сравнения ==, чтобы отображение могло сопоставить значение с одним из ключей и хеш-таблицы.</p>
<pre><code class="language-go">// A header for a Go map.
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
	// Make sure this stays in sync with the compiler's definition.
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}
</code></pre>
<p>Например, определение отображения, которое в качестве ключей имеет тип string, а в качестве значений - тип int:</p>
<pre><code class="language-go">var people map[string] int   
// Ключи представляют тип string, значения - тип int`
</code></pre>
<p>Для проверки наличия элемента по определенному ключу можно применять выражение if. Если значение по заданному ключу имеется в отображении, то переменная ok будет равна true, а переменная val будет хранить полученное значение. Если переменная ok равна false, то значения по ключу в отображении нет.</p>
<pre><code class="language-go">	var people = map[string]int{&quot;Tom&quot;: 1, &quot;Bob&quot;: 2, &quot;Sam&quot;: 4, &quot;Alice&quot;: 8}

	if val, ok := people[&quot;Tom&quot;]; ok {
		fmt.Println(val)
	}
</code></pre>
<p>Адрес элемента мапы получить невозможно(сделано из-за того что адрес может стать недействителен, после рехеширования)</p>
<pre><code class="language-go">_ = &amp;ages[&quot;bob&quot;] // ТАК НЕЛЬЗЯ!!!
</code></pre>
<h3 id="Структура"><a class="header" href="#Структура">Структура</a></h3>
<p>Структура — составной тип, содержащий именованные поля. Также поддерживается встраивание структур в качестве анонимного поля(как способ реализации композиции). К полям и методам встроенных структур можно обращаться как черзе них, так и через &quot;родительскую&quot;.</p>
<h2 id="Интерфейсы"><a class="header" href="#Интерфейсы">Интерфейсы</a></h2>
<pre><code class="language-go">type iface struct {
	tab  *itab
	data unsafe.Pointer
}

type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32 // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}

type interfacetype struct {
	typ     _type
	pkgpath name
	mhdr    []imethod
} 

//пустой интерфейс interface{}
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
</code></pre>
<p>Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.</p>
<p>Для определения интерфейса применяется ключевое слово interface:</p>
<pre><code class="language-go">type имя_интерфейса interface {определения_функций()}
</code></pre>
<h3 id="nill-interface-vs-nil-pointer-interface"><a class="header" href="#nill-interface-vs-nil-pointer-interface">Nill interface vs nil pointer interface</a></h3>
<img src="goLang/../media/go/nilIface.png" width="100%"><div style="break-before: page; page-break-before: always;"></div><h1 id="Сoncurrency"><a class="header" href="#Сoncurrency">Сoncurrency</a></h1>
<p>В данном разделе будут темы, относящиеся к параллелизму и конкурентной работе.</p>
<ul>
<li><a href="goLang/concurrency/chanel.html">Каналы</a></li>
<li><a href="goLang/concurrency/gouritine.html">Горутины</a></li>
<li><a href="goLang/concurrency/sync.html">Sync</a></li>
<li><a href="goLang/concurrency/patterns.html">Паттерны</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Каналы"><a class="header" href="#Каналы">Каналы</a></h2>
<p>Каналы (channels) - инструмент коммуникации между горутинами. Для определения канала применяется ключевое слово chan <code>var intChannel chan int</code></p>
<pre><code class="language-go">type hchan struct {
   qcount   uint           // количество элементов в буфере
   dataqsiz uint           // размерность буфера для буферизированного канала
   buf      unsafe.Pointer //  ссылка на буфер с данными, записанными в канал, реализованный с помощью структуры данных “кольцевой буфер”
   elemsize uint16 // размер одного элемента в канале
   closed   uint32 // закрыт или открыт канал в данный момент(из за работы с atomic не bool а uint32)
   elemtype *_type // на тип данных в канале
   sendx    uint   // индекс смещения записи - в какой  элемент буфера будет следующая запись
   recvx    uint   // индекс смещения чтения - с какого элемента буфера будет следующее чтение
   recvq    waitq  // очередь заблокированных горутин(sudog), ожидающие чтения
   sendq    waitq  // очердь заблокированных горутин(sudog), ожидающие записи
   lock mutex  // мьютекс, используемый для операций, изменяющих состояние канала
}
</code></pre>
<p>Канал содержит в себе ссылку на ожидающую горутину, представленную структурой <em>sudog.</em> Эта структура помещается в односвязный список <em>waitq</em> а горутина переходит в состояние <code>waiting</code>. И когда буфер становится доступным для заполнения, происходит следующее:</p>
<ul>
<li>очередная структура, представляющая ожидающую горутину <em>sudog</em> извлекается из списка <em>waitq;</em></li>
<li>данные из поля <em>elem</em> добавляются в буфер канала;</li>
<li>горутина из sudog переходит из состояния “waiting” в состояние “runnable” (готова к выполнению).</li>
</ul>
<pre><code class="language-go">// sudog представляет заблокированную горутину, ожидающую чтения или записи
type sudog struct {
    g *g                    // ссылка на горутину
    elem     unsafe.Pointer // данные для записи
    // ...
}
</code></pre>
<p>В общем случае, горутина захватывает мьютекс, когда совершает какое-либо действие с каналом, кроме случаев lock-free проверок при неблокирующих вызовах. Closed — это флаг, который устанавливается в 1, если канал закрыт, и в 0, если не закрыт.</p>
<p>Канал может быть синхронным (небуферизированным) или асинхронным (буферезированным). </p>
<h3 id="Синхронныенебуферизированные-каналы"><a class="header" href="#Синхронныенебуферизированные-каналы">Синхронные(небуферизированные) каналы</a></h3>
<pre><code class="language-go">package main

func main() {
    ch := make(chan bool)
    go func() {
        ch &lt;- true
    }()
    &lt;-ch
}
</code></pre>
<p>Вначале создается новый канал и он выглядит вот так:</p>
<p><img src="https://habrastorage.org/files/725/298/c69/725298c69c2b4319b3cb5cf606712124.png" alt="img" /></p>
<p>Go не выделяет буфер для синхронных каналов, поэтому указатель на буфер равен nil и <code>dataqsiz</code>равен нулю. Допустим, что первым действием будет чтение из канала (обратный пример, когда вначале идёт запись, будет рассмотрен в примере с буферизированным каналами). Вначале, текущая горутина произведёт некоторые проверки, такие как: закрыт ли канал, буферизирован он или нет, содержит ли гоуртины в send-очереди. В нашем примере у канала нет ни буфера, ни ожидающих отправки горутин, поэтому горутина добавит сама себя в <code>recvq</code> и заблокируется. На этом шаге наш канал будет выглядеть следующим образом:</p>
<p><img src="https://habrastorage.org/files/2af/b2c/796/2afb2c79621847e0a28f118f92ed5c10.png" alt="img" /></p>
<p>Теперь у нас осталась только одна работающая горутина, которая пытается записать данные в канал. Все проверки повторяются снова, и когда горутина проверяет <code>recvq</code> очередь, она находит ожидающую чтение горутину, удаляет её из очереди, записывает данные в её стек и снимает блокировку. Это единственное место во всём рантайме Go, когда одна горутина пишет напрямую в стек другой горутины. После этого шага, канал выглядит точно так же, как сразу после инициализации. Обе горутины завершаются и программа завершается.</p>
<h3 id="Буферезированные-каналы"><a class="header" href="#Буферезированные-каналы">Буферезированные каналы</a></h3>
<pre><code class="language-go">package main

func main() {
    ch := make(chan bool, 1)
    ch &lt;- true
    go func() {
        &lt;-ch
    }()
    ch &lt;- true
}
</code></pre>
<p>Допустим, что два значения были записаны в канал, и после этого один из элементов вычитан. И первым шагом идёт создание канала, который будет выглядеть вот так:</p>
<p><img src="https://habrastorage.org/files/6f4/e78/6af/6f4e786af89b47f49e0b52d1869a2180.png" alt="img" /></p>
<p>Разница в сравнении с синхронным каналом в том, что тут Go выделяет буфер и устанавливает значение <code>dataqsiz</code> в единицу.</p>
<p>Следующим шагом будет отправка первого значения в канал. Чтобы сделать это, горутина сначала производит несколько проверок: пуста ли очередь <code>recvq</code>, пуст ли буфер, достаточно ли места в буфере.</p>
<p>В нашем случае в буфере достаточно места и в очереди ожидания чтения нет горутин, поэтому горутина просто записывает элемент в буфер, увеличивает значение <code>qcount</code> и продолжает исполнение далее. Канал в этот момент выглядит так:</p>
<p><img src="https://habrastorage.org/files/40c/f56/e00/40cf56e008e44b21ab2bbf7a5afe8a5e.png" alt="img" /></p>
<p>На следующем шаге, горутина main отправляет следующее значение в канал. Когда буфер полон, буферизированный канал будет вести себя точно так же, как синхронный (небуферизированный) канал, тоесть горутина добавит себя в очередь ожидания и <strong>заблокируется</strong>, в результате чего, канал будет выглядеть следующим образом:</p>
<p><img src="https://habrastorage.org/files/279/503/8c4/2795038c432c4ff38041e67086cb4e56.png" alt="img" /></p>
<p>Сейчас горутина main заблокирована и Go запустил одну анонимную горутину, которая пытается прочесть значение из канала. И вот тут начинается хитрая часть. Go гарантирует, что канал работает по принципу FIFO очереди (<a href="https://golang.org/ref/spec#Channel_types">спецификация</a>), но горутина не может просто взять значение из буфера и продолжить исполнение. В этом случае горутина main заблокируется навсегда. Для решения этой ситуации, текущая горутина читает данные из буфера, затем добавляет значение из заблокированной горутины в буфер, разблокирует ожидающую горутину и удаляет её из очереди ожидания. (В случае же, если нет ожидающих горутину, она просто читает первое значение из буфера)</p>
<h3 id="select"><a class="header" href="#select">Select</a></h3>
<pre><code class="language-go">select {
    case &lt;-ch:
    foo()
    default:
    bar()
}
</code></pre>
<ol>
<li>
<p>Элементы(<em>scase</em>) внутри <em>select</em> сортируются в случайном порядке(перемешиваются):</p>
</li>
<li>
<p>Каждый из каналов блокируется мьютексом.</p>
</li>
<li>
<p>Происходит последовательная попытка взаимодействия (запись или чтение) с каналами, перечисленными внутри оператора <em>select</em>. При наличии секции <em>default</em>, чтение и запись происходят в <em>неблокирующем</em> режиме(об этом далее).</p>
</li>
<li>
<p>В случае, если ни один из каналов недоступен для взаимодействия, и секция <em>default</em> отсутствует, то текущая горутина переходит в состояние <em>waiting</em> до тех пор, пока какой-то из каналов не станет доступен.</p>
</li>
<li>
<p>С каналов снимается блокировка мьютексом.</p>
</li>
</ol>
<p>Go запускает функцию со следующей сигнатурой:</p>
<pre><code class="language-go">func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { ... }
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... }
</code></pre>
<p>Здесь нас интересует параметр <em>block</em>. При наличии секции <em>default</em> в операторе выбора <em>select</em>, функции <em>chansend</em> и <em>chanrecv</em> вызываются с параметром <em>block</em> равным <em>false</em>, в итоге функции осуществляют быстрый возврат в случае, если записать в канал или прочитать из канала без ожидания не удалось</p>
<h3 id="Закрытие-канала"><a class="header" href="#Закрытие-канала">Закрытие канала</a></h3>
<ol>
<li>выполняется проверка, что канал инициализирован(<em>panic</em> в случае, если канал не инициализирован);</li>
<li>захватывается блокировка <em>мьютекса</em>;</li>
<li>выполняется проверка, что канал не закрыт (<em>panic</em> в случае, если канал уже закрыт);</li>
<li>значение поля <em>closed</em> канала (в структуре <em>hchan</em>) выставляется в <em>true</em>;</li>
<li>все горутины, ожидающие чтения, получают default value в зависимости от типа данных в канале;</li>
<li>все горутины, ожидающие записи, получают <em>panic;</em></li>
<li><em>мьютекс</em> канала разблокируется;</li>
<li>заблокированные горутины — разблокируются.</li>
</ol>
<p>При чтении можно проверить закрыт канал или нет двумя способами:</p>
<pre><code class="language-go">val, ok :=&lt;- someChan:
if !ok  {}// канал закрыт
</code></pre>
<pre><code class="language-go">for val := range someChan {
    // получено сообщение
}
// канал закрыт
</code></pre>
<p>При записи, нужно во первых обернуть в recover. Во вторых рекомендуется сначала &quot;убить&quot;, писателей, а потом уже закрывать канал. Также One general principle of using Go channels is <strong>don't close a channel from the receiver side and don't close a channel if the channel has multiple concurrent senders</strong>. In other words, we should only close a channel in a sender goroutine if the sender is the only sender of the channel.</p>
<p><strong>It is worth collecting the channel axioms in one post:</strong></p>
<ul>
<li>a send on a <code>nil</code> channel blocks forever (<a href="https://golang.org/ref/spec#Send_statements">Spec: Send statements</a>)</li>
<li>a receive from a <code>nil</code> channel blocks forever (<a href="https://golang.org/ref/spec#Receive_operator">Spec: Receive operator</a>)</li>
<li>a send to a closed channel panics (<a href="https://golang.org/ref/spec#Send_statements">Spec: Send statements</a>)</li>
<li>a receive from a closed channel returns the zero value immediately (<a href="https://golang.org/ref/spec#Receive_operator">Spec: Receive operator</a>)</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://medium.com/@victor_nerd/%D0%BF%D0%BE%D0%B4-%D0%BA%D0%B0%D0%BF%D0%BE%D1%82%D0%BE%D0%BC-golang-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-%D0%BA%D0%B0%D0%BD%D0%B0%D0%BB%D1%8B-%D1%87%D0%B0%D1%81%D1%82%D1%8C-1-e1da9e3e104d">Как работают каналы. Часть 1</a></li>
<li><a href="https://medium.com/@victor_nerd/golang-channel-internal-part2-b4e37ad9a118">Как работают каналы. Часть 2</a></li>
<li><a href="https://habr.com/ru/post/308070/">Как устроены каналы в Go</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="goroutines"><a class="header" href="#goroutines">Goroutines</a></h2>
<p>Горутина — функция, которая может работать параллельно с другими функциями. Для создания горутины используется ключевое слово <code>go</code>, за которым следует вызов функции. Горутины очень легкие(примерно 4.5кб на горутину против нескольких мегобайт на поток POSIX).</p>
<h2 id="Отличия-горутин-от-потоков"><a class="header" href="#Отличия-горутин-от-потоков">Отличия горутин от потоков</a></h2>
<ul>
<li>Каждый поток операционной системы имеет блок памяти фиксированного размера (зачастую до 2 Мбайт) для стека — рабочей области, в которой он хранит локальные переменные вызовов функций, находящиеся в работе или приостановленные на время вызова другой функции. В противоположность этому go-подпрограмма начинает работу с небольшим стеком, обычно около <strong>2 Кбайт</strong>. Стек go-подпрограммы, подобно стеку потока операционной системы, хранит локальные переменные активных и приостановленных функций, но, в отличие от потоков операционной системы, не является фиксированным; при необходимости он может расти и уменьшаться. Максимальный размер стека
go-подпрограммы может быть около 1 Гбайта, на порядки больше типичного стека с фиксированным размером, хотя, конечно, такой большой стек могут использовать только несколько go-подпрограмм.</li>
<li>Потоки операционной системы планируются в ее ядре, а у go есть собственный <strong>планировщик (m:n) мультиплексирующий(раскидывающий) горутинки(m) по потокам(n)</strong>. Основной плюс = отсуствие оверхеда на переключение контекста.</li>
<li>Планировщик Go использует параметр с именем <strong>GOMAXPROCS</strong> для определения, сколько потоков операционной системы могут одновременно активно выполнять код Go. Его значение по умолчанию равно количеству процессоров компьютера, так что на машине с 8 процессорами планировщик будет планировать код Go для выполнения на 8 потоках одновременно (<strong>GOMAXPROCS</strong> равно значению п в т:п-планировании).
Спящие или заблокированные в процессе коммуникации go-подпрограммы потоков для себя не требуют. Go-подпрограммы, заблокированные в операции ввода-вывода или в других системных вызовах, или при вызове функций, не являющихся функциями Go, нуждаются в потоке операционной системы, но <strong>GOMAXPROCS</strong> их не учитывает.</li>
<li>В большинстве операционных систем и языков программирования, поддерживающих многопоточность, текущий поток имеет идентификацию, которая может быть легко получена как обычное значение (обычно — целое число или указатель). Это облегчает построение абстракции, именуемой локальной памятью потока, которая, по существу, является глобальным отображением, использующим в качестве ключа идентификатор потока, так что каждый поток может сохранять и извлекать значения независимо от других потоков.
<strong>У горутин нет идентификации, доступной программисту.</strong> Так решено во время проектирования языка, поскольку локальной памятью потока программисты злоупотребляют.</li>
</ul>
<h2 id="contextcontext"><a class="header" href="#contextcontext">context.Context</a></h2>
<p>Хорошей практикой, считается &quot;управлять&quot; горутинами через контекст:</p>
<pre><code class="language-go">// Контекст предоставляет механизм дедлайнов, сигнал отмены, и доступ к запросозависимым значениям.
// Эти методы безопасны для одновременного использования в разных go-рутинах.
type Context interface {
    // Done возвращает канал, который закрывается когда Context отменяется
    // или по таймауту.
    Done() &lt;-chan struct{}

    // Err объясняет почему контекст был отменен, после того как закрылся канал Done.
    Err() error

    // Deadline возвращает время когда этот Context будет отменен.
    Deadline() (deadline time.Time, ok bool)

    // Value возвращает значение ассоциированное с ключем или nil.
    Value(key interface{}) interface{}
}
</code></pre>
<h3 id="Лучшие-практики"><a class="header" href="#Лучшие-практики">Лучшие практики</a></h3>
<ol>
<li><strong>context.Background</strong> следует использовать только на самом высоком уровне, как корень всех производных контекстов.</li>
<li><strong>context.TODO</strong> должен использоваться, когда вы не уверены, что использовать, или если текущая функция будет использовать контекст в будущем.</li>
<li>Отмены контекста рекомендуются, но эти функции могут занимать время, чтобы выполнить очистку и выход.</li>
<li><strong>context.Value</strong> следует использовать как можно реже, и его нельзя применять для передачи необязательных параметров. Это делает API непонятным и может привести к ошибкам. Такие значения должны передаваться как аргументы.</li>
<li>Не храните контексты в структуре, передавайте их явно в функциях, предпочтительно в качестве первого аргумента.</li>
<li>Никогда не передавайте nil-контекст в качестве аргумента. Если сомневаетесь, используйте TODO.</li>
<li>Структура <code>Context</code> не имеет метода cancel, потому что только функция, которая порождает контекст, должна его отменять.</li>
</ol>
<p><em>Дополнительно:</em></p>
<ul>
<li>https://habr.com/ru/company/nixys/blog/461723/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sync"><a class="header" href="#sync">Sync</a></h2>
<h3 id="atomic"><a class="header" href="#atomic">Atomic</a></h3>
<p>Пакет Atomic предоставляет низкоуровневые атомарные примитивы памяти, полезные для реализации алгоритмов синхронизации. Пример:</p>
<pre><code class="language-go">var ops uint64 = 0
for i := 0; i &lt; 50; i++ {
    go func() {
        for {
            atomic.AddUint64(&amp;ops, 1)
            runtime.Gosched()
        }
    }()
}
</code></pre>
<h3 id="syncmutex"><a class="header" href="#syncmutex">sync.Mutex</a></h3>
<pre><code class="language-go">// A Mutex is a mutual exclusion lock.
// The zero value for a Mutex is an unlocked mutex.
//
// A Mutex must not be copied after first use.
type Mutex struct {
	state int32
	sema  uint32
}
</code></pre>
<h3 id="syncmutex-1"><a class="header" href="#syncmutex-1">sync.Mutex</a></h3>
<p>На уровне кода мьютекс представляет тип <strong>sync.Mutex</strong>. Для блокирования доступа к общему разделяемому ресурсу у мьютекса вызывается метод <strong>Lock()</strong>, а для разблокировки доступа - метод <strong>Unlock()</strong>.</p>
<h3 id="syncrwmutex"><a class="header" href="#syncrwmutex">sync.RWMutex</a></h3>
<p>Существует блокировка <code>несколько читателей, один писатель</code> и в Go обеспечивается мьютексом <strong>sync. RWMutex</strong> При его использовании чтение может спокойно выполняться параллельно, но операции записи получают, полностью эксклюзивный доступ.</p>
<pre><code class="language-go">// A RWMutex is a reader/writer mutual exclusion lock.
// The lock can be held by an arbitrary number of readers or a single writer.
// The zero value for a RWMutex is an unlocked mutex.
//
// A RWMutex must not be copied after first use.
//
// If a goroutine holds a RWMutex for reading and another goroutine might
// call Lock, no goroutine should expect to be able to acquire a read lock
// until the initial read lock is released. In particular, this prohibits
// recursive read locking. This is to ensure that the lock eventually becomes
// available; a blocked Lock call excludes new readers from acquiring the
// lock.
type RWMutex struct {
	w           Mutex  // held if there are pending writers
	writerSem   uint32 // semaphore for writers to wait for completing readers
	readerSem   uint32 // semaphore for readers to wait for completing writers
	readerCount int32  // number of pending readers
	readerWait  int32  // number of departing readers
}
</code></pre>
<pre><code class="language-go">var mu sync.RWMutex
var balance int

func BalanceQ int { 
	mu.RLockQ // Блокировка читателя
	defer mu.RUnlock()
	return balance
}
</code></pre>
<h3 id="synconce"><a class="header" href="#synconce">sync.Once</a></h3>
<pre><code class="language-go">// Once is an object that will perform exactly one action.
type Once struct {
	// done indicates whether the action has been performed.
	// It is first in the struct because it is used in the hot path.
	// The hot path is inlined at every call site.
	// Placing done first allows more compact instructions on some architectures (amd64/x86),
	// and fewer instructions (to calculate offset) on other architectures.
	done uint32
	m    Mutex
} 

// Do calls the function f if and only if Do is being called for the
// first time for this instance of Once. In other words, given
// 	var once Once
// if once.Do(f) is called multiple times, only the first call will invoke f,
// even if f has a different value in each invocation. A new instance of
// Once is required for each function to execute.
//
// Do is intended for initialization that must be run exactly once. Since f
// is niladic, it may be necessary to use a function literal to capture the
// arguments to a function to be invoked by Do:
// 	config.once.Do(func() { config.init(filename) })
//
// Because no call to Do returns until the one call to f returns, if f causes
// Do to be called, it will deadlock.
//
// If f panics, Do considers it to have returned; future calls of Do return
// without calling f.
//
func (o *Once) Do(f func()) {
	// Note: Here is an incorrect implementation of Do:
	//
	//	if atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {
	//		f()
	//	}
	//
	// Do guarantees that when it returns, f has finished.
	// This implementation would not implement that guarantee:
	// given two simultaneous calls, the winner of the cas would
	// call f, and the second would return immediately, without
	// waiting for the first's call to f to complete.
	// This is why the slow path falls back to a mutex, and why
	// the atomic.StoreUint32 must be delayed until after f returns.

	if atomic.LoadUint32(&amp;o.done) == 0 {
		// Outlined slow-path to allow inlining of the fast-path.
		o.doSlow(f)
	}
}
</code></pre>
<h3 id="syncmap"><a class="header" href="#syncmap">sync.Map</a></h3>
<p><code>Если у вас высоконагруженная (и 100нс решают) система с большим количеством ядер процессора (32+), вы можете захотеть использовать sync.Map вместо стандартного map+sync.RWMutex. В остальных случаях, sync.Map особо не нужен</code></p>
<p>Итак, ещё раз сделаю акцент — sync.Map решает совершенно конкретную проблему cache contention в стандартной библиотеке для таких случаев, когда ключи в map стабильны (не обновляются часто) и происходит намного больше чтений, чем записей.</p>
<p><strong>Если вы совершенно чётко не идентифицировали в своей программе узкое место из-за cache contention в map+RWMutex, то, вероятнее всего, никакой выгоды от sync.Map вы не получите, и возможно даже слегка потеряете в скорости.</strong></p>
<p><strong>Cache contention</strong></p>
<p>Если посмотреть на <a href="https://golang.org/src/sync/rwmutex.go#L94">код sync.RWMutex</a>, то можно увидеть, что при блокировке на чтение, каждая горутина должна обновить поле <code>readerCount</code> — простой счётчик. Это делается атомарно с помощью функции из пакета <a href="https://golang.org/pkg/sync/atomic">sync/atomic</a> <a href="https://golang.org/pkg/sync/atomic/#AddInt32">atomic.AddInt32()</a>. Эти функции оптимизированы под архитектуру конкретного процессора и <a href="https://github.com/golang/go/blob/master/src/sync/atomic/asm_amd64.s#L65">реализованы на ассемблере</a>.</p>
<p>Когда каждое ядро процессора обновляет счётчик, оно сбрасывает кеш для этого адреса в памяти для всех остальных ядер и объявляет, что владеет актуальным значением для этого адреса. Следующее ядро, прежде чем обновить счётчик, должно сначала вычитать это значение из кеша другого ядра.</p>
<p>На современном железе передача между L2 кешем занимает что-то около 40 наносекунд. Это немного, но когда много ядер одновременно пытаются обновить счётчик, каждое из них становится в очередь и ждёт эту инвалидацию и вычитывание из кеша. Операция, которая должна укладываться в константное время внезапно становится O(N) по количеству ядер. Эта проблема называется <em>cache contention</em>.</p>
<h3 id="syncpool"><a class="header" href="#syncpool">sync.Pool</a></h3>
<p>Сборщик мусора (далее GC) не постоянно собирает мусор, а через определённые промежутки времени. В случае если ваш код выделяет память под некоторые структуры данных, а потом освобождает их — и так по кругу — это вызывает определённое давление на GC, в том числе заставляет <code>runtime</code><em>кусок</em><code>[]byte</code><em>кусок<strong>кусок</strong>кусок</em></p>
<ul>
<li>создать пул</li>
<li>сбрасывать состояние <em>куска</em></li>
<li>складывать в пул отработанные <em>куски</em></li>
<li>брать новые <em>куски</em> из пула</li>
</ul>
<p>A Pool is a set of temporary objects that may be individually saved and retrieved.</p>
<p>Any item stored in the Pool may be removed automatically at any time without notification. If the Pool holds the only reference when this happens, the item might be deallocated.</p>
<p>A Pool is safe for use by multiple goroutines simultaneously.</p>
<p>Pool's purpose is to cache allocated but unused items for later reuse, relieving pressure on the garbage collector. That is, it makes it easy to build efficient, thread-safe free lists. However, it is not suitable for all free lists.</p>
<p>An appropriate use of a Pool is to manage a group of temporary items silently shared among and potentially reused by concurrent independent clients of a package. Pool provides a way to amortize allocation overhead across many clients.</p>
<p>An example of good use of a Pool is in the fmt package, which maintains a dynamically-sized store of temporary output buffers. The store scales under load (when many goroutines are actively printing) and shrinks when quiescent.</p>
<p>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</p>
<h3 id="syncwaitgroup"><a class="header" href="#syncwaitgroup">sync.WaitGroup</a></h3>
<p>Этот тип позволяет определить группу горутин, которые должны выполняться вместе как одна группа. И можно установить блокировку, которая приостановит выполнение функции, пока не завершит выполнение вся группа горутин. </p>
<pre><code class="language-go">func main() { 
    var wg sync.WaitGroup 
    wg.Add(2)       // в группе две горутины
    counter := 5
    doubleCounter := func() { 
        defer wg.Done() 
        counter = counter * 2
   } 
  
   // вызываем горутины
   go doubleCounter() 
   go doubleCounter() 
  
   wg.Wait()        // ожидаем завершения обоих горутин
   fmt.Println(&quot;Counter:&quot;, counter) 
}
</code></pre>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concurrency-patterns"><a class="header" href="#concurrency-patterns">Concurrency patterns</a></h2>
<h2 id="pipelineконвейер"><a class="header" href="#pipelineконвейер">Pipeline(конвейер)</a></h2>
<p>Каналы могут использоваться для подключения go-подпрограмм так, чтобы выход одной из них был входом для другой. Это называется конвейером (pipeline).</p>
<pre><code class="language-go">func main() {
	naturals := make(chan int)
	squares := make(chan int)
    // Генерация
    go func() {
        for x := 0; ; x++ {
            naturals &lt;-x
        }
    }()
    // Возведение в квадрат
    go func() {
        for {
            x := &lt;-naturals
            squares &lt;- x * x
        }
    }()
    // Вывод (в главной go-подпрограмме)
    for {
    	fmt.Println(&lt;-squares)
    }
}
</code></pre>
<h2 id="broadcasting"><a class="header" href="#broadcasting">Broadcasting</a></h2>
<p>В go нет возможности полноценной широковещательной рассылки нескольким получателям, однако есть лайфхак: при закрытии канала, все консюммеры, могут фиксировать это событие(закрытие канала)</p>
<h2 id="cancelation"><a class="header" href="#cancelation">Cancelation</a></h2>
<p>Чтобы отменить выполнение горутины в определенный момент, можем использовать канал отмены:</p>
<pre><code class="language-go">func main() {
	var cancelChan chan bool
	cancelChan  = make(chan bool)

	go func() {
		for {
			select {
			case &lt;-cancelChan:
				fmt.Println(&quot;Получили сигнал, отмены, вышли&quot;)
				return
			default:
				fmt.Println(&quot;Делаем полезную работу&quot;)
			}
			time.Sleep(3)

		}
	}()

	time.Sleep(10)
	cancelChan &lt;- true
}
</code></pre>
<h2 id="promises"><a class="header" href="#promises">Promises</a></h2>
<p>В информатике конструкции future, promise и delay в некоторых языках программирования формируют стратегию вычисления, применяемую для параллельных вычислений. С их помощью описывается объект, к которому можно обратиться за результатом, вычисление которого может быть не завершено на данный момент. Использование future может быть неявным (при любом обращении к future возвращается ссылка на значение) и явным (пользователь должен вызвать функцию, чтобы получить значение). Получение значения из явного future называют stinging или forcing. Явные future могут быть реализованы в качестве библиотеки, в то время, как неявные обычно реализуются как часть языка.</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

type Promise struct {
	wg  sync.WaitGroup
	res string
	err error
}

func NewPromise(f func() (string, error)) *Promise {
	p := &amp;Promise{}
	p.wg.Add(1)
	go func() {
		p.res, p.err = f()
		p.wg.Done()
	}()
	return p
}

func (p *Promise) Then(r func(string), e func(error)) {
	go func() {
		p.wg.Wait()
		if p.err != nil {
			e(p.err)
			return
		}
		r(p.res)
	}()
}

func exampleTicker() (string, error) {
	&lt;-time.Tick(time.Second * 1)
	return &quot;hi&quot;, nil
}

func main() {
	doneChan := make(chan int)
	var p = NewPromise(exampleTicker)
	p.Then(func(result string) { fmt.Println(result); doneChan &lt;- 1 }, func(err error) { fmt.Println(err) })
	&lt;-doneChan
}

</code></pre>
<h3 id="generator-aka-iterator"><a class="header" href="#generator-aka-iterator">Generator aka Iterator</a></h3>
<h3 id="futurespromises"><a class="header" href="#futurespromises">Futures/Promises</a></h3>
<h3 id="fan-in-fan-out"><a class="header" href="#fan-in-fan-out">Fan-in, Fan-out</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Планировщик"><a class="header" href="#Планировщик">Планировщик</a></h1>
<p>Обычно есть 3 моделей для нарезания вычисления на потоки. Первым является N:1, где несколько пользовательских потоков запущено на едином потоке ядра операционной системы. Этот способ имеет то преимущество, что осуществляется очень быстрое переключение контекстов, но нет возможности воспользоваться преимуществами многоядерных систем. Второй способ — это 1:1, где каждый пользовательский поток выполнения совпадает с одним потоком операционной системы. Он использует все ядра автоматически, но переключение контекста происходит медленно, потому что требует прерываний работы операционной системы.</p>
<p>Go пытается взять лучшее из обоих миров с помощью М:N планировщика. При этом произвольное число Go-рутин (M) планируется на произвольное количество потоков (N) операционной системы. Этим вы получаете одновременно быстрое переключение контекста, и возможность воспользоваться всеми ядрами в вашей системе. Основным недостатком данного подхода является сложность его включения в планировщик.</p>
<p>Чтобы исполнять задачу планирования, планировщик Go использует 3 основных сущностей:</p>
<p><img src="https://habrastorage.org/getpro/habr/post_images/b7f/950/7f2/b7f9507f25478708df83be3e4243f2a3.jpg" alt="img" /></p>
<p>Треугольник представляет поток операционной системы. Выполнением такого потока управляет операционная система, и работает это во многом подобно вашим стандартным потокам POSIX. В исполнимом коде это называется M машиной.</p>
<p>Круг представляет Go-рутину. Он включает стек, указатель команд и другую важную информацию для планирования Go-рутины, такую как канал, который на ней может быть блокирован. В исполнимом коде это обозначается как G.</p>
<p>Прямоугольник представляет контекст планирования. Вы можете понимать его как локализованная версию планировщика, который выполняет код Go-рутин в единственном потоке ядра. Это важная часть, которая позволяет нам уйти от N:1 планировщика к М:N планировщику. Во время выполнения кода контекст обозначается как P для процессора. В общем это и всё, если коротко.</p>
<p><img src="https://habrastorage.org/getpro/habr/post_images/ed6/195/c49/ed6195c49aad3cfa29b163492bd9cb0f.jpg" alt="img" /></p>
<h2 id="-3"><a class="header" href="#-3"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Управление-памятью"><a class="header" href="#Управление-памятью">Управление памятью</a></h1>
<h2 id="Эскейп-анализ"><a class="header" href="#Эскейп-анализ">Эскейп анализ</a></h2>
<ol>
<li>
<p>Go сам решает, где выделяется память</p>
</li>
<li>
<p>Определяет, выходят ли указатели на значение за функцию или нет</p>
</li>
<li>
<p>Если нет, то данные спокой̆но располагаются на стеке (с исключениями)</p>
</li>
<li>
<p>Данные на стеке удаляются после выхода из функции и освобождения стека все скопом.</p>
</li>
<li>
<p>Нет повода беспокоить сборщик мусора</p>
</li>
</ol>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/company/ruvds/blog/442648/">Механизмы выделения памяти в Go</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Экосистема"><a class="header" href="#Экосистема">Экосистема</a></h2>
<p>Пакетный менеджер, тестирование, линтеры, структура проектов</p>
<ul>
<li>go mod</li>
<li>sqlx, squirel,</li>
<li>errorgroup</li>
<li>go test -bench</li>
<li>go tool pprof</li>
</ul>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://habr.com/ru/company/roistat/blog/413175/">Статический анализ в Go</a></li>
<li><a href="https://habr.com/ru/company/badoo/blog/301990/">Профилирование и оптимизация программ на Go</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<p>Джаваскрипт очень нужен, куда мы без него.</p>
<h2 id="function-declaration-vs--function-expression"><a class="header" href="#function-declaration-vs--function-expression">Function Declaration vs  Function Expression</a></h2>
<p>Давайте разберём ключевые отличия Function Declaration от Function Expression.</p>
<p>Во-первых, синтаксис: как определить, что есть что в коде.</p>
<ul>
<li>
<p>Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.</p>
<pre><code class="language-javascript">// Function Declaration
function sum(a, b) {
  return a + b;
}
</code></pre>
</li>
<li>
<p>Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» <code>=</code>:</p>
<pre><code class="language-javascript">// Function Expression
let sum = function(a, b) {
  return a + b;
};
</code></pre>
</li>
</ul>
<p>Более тонкое отличие состоит, в том, <em>когда</em> создаётся функция движком JavaScript.</p>
<p><strong>Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.</strong></p>
<p>После того, как поток выполнения достигнет правой части выражения присваивания <code>let sum = function…</code> – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).</p>
<p>С Function Declaration всё иначе.</p>
<p><strong>Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).</strong></p>
<p>Другими словами, когда движок JavaScript <em>готовится</em> выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».</p>
<p>И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.</p>
<p>В результате функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.</p>
<h2 id="arrow-functions"><a class="header" href="#arrow-functions">Arrow Functions</a></h2>
<h2 id="this"><a class="header" href="#this">This</a></h2>
<p>Поведение ключевого слова <code>this</code> в JavaScript несколько отличается по сравнению с остальными языками. Имеются также различия при использовании <code>this</code> в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">строгом</a> и нестрогом режиме.</p>
<p>В большинстве случаев значение <code>this</code> определяется тем, каким образом вызвана функция. Значение <code>this</code> не может быть установлено путем присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. В ES5 представлен метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>bind()</code></a>, который используется для <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_bind"><code>привязки значения ключевого слова this независимо от того, как вызвана функция</code></a>. Также в ES2015 представлены <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions"><code>стрелочные функции</code></a>, которые не создают собственные привязки к <code>this</code> (они сохраняют значение <code>this</code> лексического окружения, в котором были созданы).</p>
<h2 id="use-strict"><a class="header" href="#use-strict">Use Strict</a></h2>
<p><strong>Преимущества:</strong></p>
<ul>
<li>Не позволяет случайно создавать глобальные переменные.</li>
<li>Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.</li>
<li>При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).</li>
<li>Требует, чтобы имена параметров функции были уникальными.</li>
<li><code>this</code> в глобальной области видимости равно undefined.</li>
<li>Перехватывает распространенные ошибки, выдавая исключения.</li>
<li>Исключает неочевидные особенности языка.</li>
</ul>
<p><strong>Недостатки:</strong></p>
<ul>
<li>Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.</li>
<li>Нет доступа к <code>function.caller</code> и <code>function.arguments</code>.</li>
<li>Объединение скриптов, написанных в строгом режиме может вызвать проблемы.</li>
</ul>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<ul>
<li>Event Loop</li>
<li>Калбеки</li>
<li>промисы</li>
<li>async await</li>
<li>web workers</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Информационная-безопасность"><a class="header" href="#Информационная-безопасность">Информационная безопасность</a></h1>
<h2 id="sql-инъекция"><a class="header" href="#sql-инъекция">SQL-инъекция</a></h2>
<p>SQL-инъекция — это атака, направленная на веб-приложение, в ходе которой конструируется SQL-выражение из пользовательского ввода путем простой конкантенации, например:
<code>$query=&quot;SELECT * FROM users WHERE id=&quot;.$_REQUEST[&quot;id&quot;]</code>
В случае успеха атакующий может изменить логику выполнения SQL-запроса так, как это ему нужно. Чаще всего он выполняет простой fingerprinting СУБД, а также извлекает таблицы с наиболее «интересными» именами (например «users»). После этого, в зависимости от привилегий, с которыми запущено уязвимое приложение, он может обратиться к защищенным частям бэк-энда веб-приложения (например, прочитать файлы на стороне хоста или выполнить произвольные команды)</p>
<p><strong>Защита:</strong></p>
<ul>
<li>Данные подставляем в запрос только через плейсхолдеры (подготовленные выражения). Также имеются серверные плейсхолдеры. В их случае выполнение подготавливаемого запроса проводится в два этапа: подготовка и исполнение. На этапе подготовки на сервер посылается шаблон запроса. Сервер выполняет синтаксическую проверку этого шаблона, строит план выполнения запроса и выделяет под него ресурсы. За подготовкой идет выполнение. Во время запуска запроса клиент привязывает к псевдопеременным реальные значения и посылает их на сервер. Сервер, в свою очередь, подставляет их в шаблон и запускает уже готовый запрос на выполнение.</li>
<li>идентификаторы и ключевые слова подставляем только из белого списка, прописанного в нашем коде.</li>
</ul>
<p>Экранирование не является надежным способом защиты от SQL. Так как рано или поздно кто-нибудь забудет проэкранировать входящие данные + возможны sql атаки и без кавычек, например мы можем вставить вместо какого-то скалярного значения вложенный запрос.</p>
<p>Дополнительно:</p>
<ul>
<li>https://habr.com/post/148701/</li>
</ul>
<h2 id="xss"><a class="header" href="#xss">XSS</a></h2>
<p><strong>XSS</strong> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> Cross-Site Scripting — «межсайтовый <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D1%80%D0%B8%D0%BF%D1%82">скриптинг</a>») — тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода(который будет выполнен на компьютере пользователя при открытии им этой страницы) и взаимодействии этого кода с веб-сервером злоумышленника. Является разновидностью атаки «<a href="https://ru.wikipedia.org/w/index.php?title=%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%B4%D0%B0&amp;action=edit&amp;redlink=1">внедрение кода</a>[<a href="https://en.wikipedia.org/wiki/Code_injection">en]</a>».</p>
<p>Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя. Вредоносный код может быть вставлен в страницу как через уязвимость в веб-сервере, так и через уязвимость на компьютере пользователя.</p>
<p><strong>Защита:</strong></p>
<p>Экранируем входные и выходные данные. Или санитизируем(тупо удаляем всё лишнее)</p>
<p>Также стоит включать <strong>session.cookie_httponly</strong> - запретить чтение и модификацию кук для JS. Это позволит избежать основной проблемы при XSS - угона пользовательской сессии.</p>
<h2 id="csrf"><a class="header" href="#csrf">CSRF</a></h2>
<p><strong>CSRF</strong> (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> Cross Site Request Forgery — «межсайтовая подделка запроса») — вид <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BA%D0%B5%D1%80%D1%81%D0%BA%D0%B0%D1%8F_%D0%B0%D1%82%D0%B0%D0%BA%D0%B0">атак</a> на посетителей <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D1%81%D0%B0%D0%B9%D1%82">веб-сайтов</a>, использующий недостатки протокола <a href="https://ru.wikipedia.org/wiki/HTTP">HTTP</a>. Если жертва заходит на сайт, созданный злоумышленником, от её лица тайно отправляется запрос на другой <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B5%D1%80_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5)">сервер</a> (например, на сервер платёжной системы), осуществляющий некую вредоносную операцию (например, перевод денег на счёт злоумышленника). Для осуществления данной атаки жертва должна быть <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F">аутентифицирована</a> на том сервере, на который отправляется запрос, и этот запрос не должен требовать какого-либо подтверждения со стороны пользователя, которое не может быть проигнорировано или подделано атакующим скриптом.</p>
<p><strong>Защита:</strong></p>
<p><strong>CSRF token</strong> </p>
<ul>
<li>Для каждой пользовательской сессии генерируется уникальный и <strong>высокоэнтропийный</strong> токен.</li>
<li>Токен вставляется в DOM HTML страницы или отдается пользователю через API.</li>
<li>Пользователь с каждым запросом, связанным с какими-либо изменениями, должен отправить токен в параметре или в HTTP-заголовке запроса.</li>
<li>Так как атакующий не знает токен, то классическая CSRF-атака не работает.</li>
</ul>
<p><strong>Double submit cookie</strong></p>
<ul>
<li>Опять генерируется уникальный и <strong>высокоэнтропийный</strong> токен для каждой пользовательской сессии, но он помещается в куки.</li>
<li>Пользователь должен в запросе передать одинаковые значения в куках и в параметре запроса.</li>
<li>Если эти два значения совпадают в куках и в параметре, то считается, что это легитимный запрос.</li>
<li>Так как атакующий просто так не может изменить куки в браузере пользователя, то классическая CSRF-атака не работает.</li>
</ul>
<p><strong>Content-Type based protection</strong></p>
<ul>
<li>Пользователь должен отправить запрос с определенным заголовком Content-Type, например, application/json.</li>
<li>Так как в браузере через HTML форму или XHR API невозможно отправить произвольный Content-Type cross-origin, то классическая CSRF-атака опять не работает.</li>
</ul>
<p><strong>Referer-based protection</strong></p>
<ul>
<li>Пользователь должен отправить запрос с определенным значением заголовка Referer. Бэкенд его проверяет, если он неверный, то считается, что это CSRF-атака.</li>
<li>Так как браузер не может отправить произвольный Referer через HTML форму или XHR API, то классическая CSRF-атака не работает.</li>
</ul>
<p><strong>Password confirmation / websudo</strong></p>
<ul>
<li>Пользователь должен подтверждать действие с помощью пароля (или секрета).</li>
<li>Так как атакующий его не знает, то классическая CSRF-атака не работает.</li>
</ul>
<p><strong>SameSite Cookies в Chrome, Opera</strong></p>
<p>Это новая технология, которая призвана защитить от CSRF. В данный момент она работает только в двух браузерах (Chrome, Opera).</p>
<ul>
<li>
<p>У куки устанавливается дополнительный атрибут — samesite, который может иметь два значения: lax или strict.</p>
</li>
<li>
<p>Суть технологии в том, что браузер не отправляет куки, если запрос осуществляется с другого домена, например, с сайта атакующего. Таким образом это опять защищает от классической CSRF-атаки.</p>
</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/company/oleg-bunin/blog/412855/">CSRF-уязвимости все еще актуальны</a></li>
<li><a href="https://habr.com/post/318748/">Методы защиты от CSRF-атаки</a></li>
</ul>
<h2 id="owsap"><a class="header" href="#owsap">OWSAP</a></h2>
<ol>
<li>Инъекции, они же “Внедрение кода”.</li>
<li>Некорректная аутентификация</li>
<li>Раскрытие чувствительной информации</li>
<li>Внедрение внешних XML-сущностей (XXE)</li>
<li>Нарушенный контроль доступа</li>
<li>Security Misconfiguration – Ошибки в конфигурировании</li>
<li>Межсайтовый скриптинг (XSS)</li>
<li>Небезопасная десериализация</li>
<li>Использование компонентов с известными уязвимостями</li>
<li>Недостаточное логирование и мониторинг</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p>Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). С его помощью вы можете откатиться на более старую версию вашего проекта, сравнивать, анализировать, сливать изменения и многое другое. Этот процесс называется контролем версий. Существуют различные системы для контроля версий. Вы, возможно, о них слышали: SVN, Mercurial, Perforce, CVS, Bitkeeper и другие.</p>
<p>Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в папках на жестком диске, которые называются репозиторием. Тем не менее обычно хранят копию репозитория онлайн, доставляя свои и получая изменения других участников через неё.</p>
<h2 id="Терминология-git"><a class="header" href="#Терминология-git">Терминология Git</a></h2>
<ul>
<li><strong>Рабочее дерево (Working tree)</strong> — Любая директория в вашей файловой системе, связанная с <em>репозиторием</em> (что можно видеть по наличию в ней поддиректории «.git»). Включает в себя все файлы и поддиректории.</li>
<li><strong>Коммит (Commit)</strong>. В роли существительного: «моментальный снимок» <em>рабочего дерева</em> в какой-то момент времени. В роли глагола: коммитить (закоммитить) — добавлять <em>коммит</em> в <em>репозиторий</em>.</li>
<li><strong>Репозиторий (Repository)</strong> — это набор <em>коммитов</em>, т.е. просто архив прошлых состояний <em>рабочего дерева</em> проекта на вашей или чьей-то машине.</li>
<li><strong>Ветка (Branch)</strong> — просто имя для <em>коммита</em>, также называемое <em>ссылкой</em> (reference). Определяет происхождение — «родословную» <em>коммита</em>, и таким образом, является типичным представлением «ветки разработки»</li>
<li><strong>Checkout</strong> — операция переключения между <em>ветками</em> или восстановления файлов <em>рабочего дерева</em></li>
<li><strong>Метка (Tag)</strong> — также имя для <em>коммита</em>, отличающееся от <em>ветки</em> тем, что оно всегда постоянно указывает на один и тот же <em>коммит</em>, а также может иметь свое текстовое описание</li>
<li><strong>Мастер (Master)</strong>. Условно «главная» или «основная» <em>ветка репозитория</em>, но по сути ничем не отличающаяся от прочих <em>веток</em></li>
<li><strong>Индекс (Index)</strong>. В отличие от других подобных инструментов, Git не передает изменения из <em>рабочего дерева</em> в <em>репозиторий</em> напрямую. Вместо этого изменения сначала регистрируются в <em>индексе</em>, или «области подготовки» (staging area). Это можно рассматривать как способ «подтверждения» ваших изменений перед совершением <em>коммита</em>, который запишет в <em>репозиторий</em> все одобренные изменения.</li>
<li><strong>HEAD</strong> — заголовок. Используется репозиторием для определения того, что выбрано с помощью checkout
<ul>
<li>Если субъект <em>checkout</em> — ветка, то <em>HEAD</em> будет ссылаться на нее, показывая, что имя ветки должно быть обновлено во время следующего <em>коммита</em></li>
<li>Если субъект <em>checkout</em> — коммит, то <em>HEAD</em> будет ссылаться только на него. В этом случае <em>HEAD</em> называется обособленным (detached)</li>
</ul>
</li>
</ul>
<p>Все начинается с того, что Git представляет содержимое ваших файлов в виде так называемых «фрагментов» («blobs»), которые являются узлами-листьями в структуре, очень похожей на директорию и называемой деревом. Так же как i-узел однозначно идентифицируется присвоенным ему системой номером, фрагмент в Git маркируется путем вычисления SHA-1 хэша от его размера и содержания. Для всех мыслимых применений это всего лишь произвольный номер, как и у i-узла, за исключением двух дополнительных свойств: во-первых, он контролирует неизменность содержимого фрагмента, а во вторых гарантирует, что одно и то же содержимое будет всегда представлено одним и тем же фрагментом независимо от того, где оно будет встречаться — в разных коммитах, репозиториях, или даже в разных частях Интернета. Если несколько деревьев ссылаются на тот же фрагмент, то это похоже на хард-линки: фрагмент не исчезнет из вашего репозитория до тех пор, пока на него существует хотя бы одна ссылка. </p>
<p>Разница между файлом в файловой системе и фрагментом в Git состоит в том, что сам фрагмент не хранит метаданных о его содержимом. Вся эта информация хранится в дереве, к которому принадлежит фрагмент. Одно дерево может считать это содержимое файлом «foo», созданным в августе 2004, в то время как другое дерево может знать то же содержимое под именем файла «bar», созданным на пять лет позже. В нормальной файловой системе такие два файла с совпадающим содержимым, но различающимися метаданными, будут всегда представлены как два независимых файла. </p>
<h2 id="Основы-work-area--stage-area--commit"><a class="header" href="#Основы-work-area--stage-area--commit">Основы Work area / stage area / commit</a></h2>
<p>Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем слепке состояния проекта (snapshot); они могут быть неизменёнными, изменёнными или подготовленными к коммиту (staged). Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту. </p>
<p><img src="media/gitLifeCycle.png" alt="" /></p>
<p><img src="https://git-scm.com/book/en/v2/images/reset-workflow.png" alt="reset workflow" /></p>
<h2 id="reset--soft-hard-mixed-vs-checkout"><a class="header" href="#reset--soft-hard-mixed-vs-checkout">reset(--soft –hard –mixed) vs checkout</a></h2>
<p><img src="https://git-scm.com/book/en/v2/images/reset-checkout.png" alt="reset checkout" /></p>
<table><thead><tr><th></th><th>HEAD</th><th>Индекс</th><th>Рабочий Каталог</th><th>Сохранность РК?</th></tr></thead><tbody>
<tr><td><strong>На уровне коммитов (без указания путей)</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td><code>reset --soft [commit]</code></td><td>REF</td><td>NO</td><td>NO</td><td>YES</td></tr>
<tr><td><code>reset [commit]</code></td><td>REF</td><td>YES</td><td>NO</td><td>YES</td></tr>
<tr><td><code>reset --hard [commit]</code></td><td>REF</td><td>YES</td><td>YES</td><td><strong>NO</strong></td></tr>
<tr><td><code>checkout [commit]</code></td><td>HEAD</td><td>YES</td><td>YES</td><td>YES</td></tr>
<tr><td><strong>На уровне файлов (с указанием путей)</strong></td><td></td><td></td><td></td><td></td></tr>
<tr><td><code>reset (commit) [file]</code></td><td>NO</td><td>YES</td><td>NO</td><td>YES</td></tr>
<tr><td><code>checkout (commit) [file]</code></td><td>NO</td><td>YES</td><td>YES</td><td><strong>NO</strong></td></tr>
</tbody></table>
<h2 id="merge-rebase-cherry-pick"><a class="header" href="#merge-rebase-cherry-pick">merge rebase cherry-pick</a></h2>
<p><strong>merge</strong> - слияние двух веток, в новом коммите</p>
<p><strong>rebase</strong> - перебазирование ветки таким образом, чтобы история выглядела так, чтобы ее коммиты выходили из заданного (как правило, последнего). Отребейзенные коммиты меняю свою дату и хеш.</p>
<p><img src="media/gitMergeRebase.jpeg" alt="" /></p>
<p><strong>rebase -i</strong> - интеркативын ребайз, позволяет сквошить(скливать) комммиты, менять их местами, выкидывать нужные, менять описания.</p>
<p><strong>rebase onto</strong> </p>
<p>Вы можете взять изменения из ветки <code>client</code>, которых нет в <code>server</code> (C8 и C9), и применить их на ветке <code>master</code> при помощи опции <code>--onto</code> команды <code>git rebas</code>:</p>
<pre><code>$ git rebase --onto master server client
</code></pre>
<p>По сути, это указание “переключиться на ветку <code>client</code>, взять изменения от общего предка веток <code>client</code> и <code>server</code> и повторить их на <code>master</code>”. </p>
<p><img src="media/gitRebaseOnTo.png" alt="" /></p>
<p><strong>cherry-pick</strong> - просто пытается вставить выбранный коммит в нужную ветку</p>
<h2 id="pull"><a class="header" href="#pull">pull</a></h2>
<p>pull - выборка и интеграция с другим репозиторием или локальной ветвью</p>
<pre><code>git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]]
</code></pre>
<p>Включает изменения из удаленного репозитория в текущую ветку. В режиме по умолчанию <code>git pull</code> является сокращением для <code>git fetch</code> за которым следует <code>git merge FETCH_HEAD</code> .</p>
<p>Точнее, <code>git pull</code> запускает <code>git fetch</code> с заданными параметрами и вызывает <code>git merge</code> чтобы объединить полученные заголовки ветвей в текущую ветвь. С <code>--rebase</code> , он запускает <code>git rebase</code> вместо <code>git merge</code> .</p>
<h2 id="reflog"><a class="header" href="#reflog">reflog</a></h2>
<p>Во время вашей работы Git записывает все изменения HEAD. Каждый раз при переключении веток и коммите, добавляется запись в <strong>reflog</strong> Таким образом reflog поможет найти нам потерянные комиты, однако он не вечен, так как есть сборщик мусора и данные хранятся там не вечно.</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://githowto.com/ru</a></p>
</li>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://git-scm.com/book/ru/v2</a></p>
</li>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://habr.com/company/intel/blog/344962/</a></p>
</li>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://eax.me/git-commands/</a></p>
</li>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://github.com/nicothin/web-development/tree/master/git</a></p>
</li>
<li>
<p><a href="https://github.com/k88hudson/git-flight-rules">https://github.com/k88hudson/git-flight-rules</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Основы-сетей"><a class="header" href="#Основы-сетей">Основы сетей</a></h1>
<p>Базовая информация по сетевому взаимодействию и устройству сетевых протоколов.</p>
<ul>
<li><a href="network/serverIteractions.html">Взаимодействие приложения с веб-сервером</a></li>
<li><a href="network/http.html">HTTP</a></li>
<li><a href="network/dns.html">DNS</a></li>
<li><a href="network/networkModels.html">Сетевые модели</a></li>
<li><a href="network/realTime.html">realTime взаимодействие с сервером</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Взаимодействие-приложения-с-веб-сервером"><a class="header" href="#Взаимодействие-приложения-с-веб-сервером">Взаимодействие приложения с веб-сервером</a></h1>
<h3 id="sapi"><a class="header" href="#sapi">SAPI</a></h3>
<p>SAPI (Server Application Programming Interface) - программный интерфейс позволяющий чему-то либо(интерпретатору PHP например) работать в качестве части web-приложения (а по сути - как часть веб-сервера), в частности - получить конкретные запросы от программы-сервера и отдавать данные (определяемые уже внутренней логикой, которую реализовал программист).</p>
<h3 id="cgi"><a class="header" href="#cgi">CGI</a></h3>
<p><strong>CGI (Common Gateway Interface)</strong> — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом, хотя многие предпочитают названия «скрипт» (сценарий) или «CGI-программа». По сути позволяет использовать консоль ввода и вывода для взаимодействия с клиентом.</p>
<p><img src="network/../media/cgi.jpeg" alt="" /></p>
<p>Алгоритм работы:</p>
<ol>
<li>Клиент запрашивает CGI-приложение по его URI.</li>
<li>Веб-сервер принимает запрос и устанавливает переменные окружения, через них приложению передаются данные и служебная информация.</li>
<li>Веб-сервер перенаправляет запросы через стандартный поток ввода (stdin) на вход вызываемой программы.</li>
<li>CGI-приложение выполняет все необходимые операции и формирует результаты в виде HTML.</li>
<li>Сформированный гипертекст возвращается веб-серверу через стандартный поток вывода (stdout). Сообщения об ошибках передаются через stderr.</li>
<li>Веб-сервер передает результаты запроса клиенту.</li>
</ol>
<p>Недостатки CGI:</p>
<ol>
<li>низкая производительность</li>
<li>каждое обращение к CGI-приложению вызывает порождение нового процесса</li>
<li>взаимодействуют с сервером через STDIN и STDOUT запущенного CGI-процесса</li>
<li>если приложение написано с ошибками, то возможна ситуация, когда оно, например, зациклится; браузер прервет соединение по истечении тайм-аута, но на серверной стороне процесс будет продолжаться, пока администратор не снимет его принудительно.</li>
<li>неправильная настройка прав доступа к серверным ресурсам из CGI-приложения может поставить под угрозу не только работоспособность веб-сервера, но и информационную безопасность</li>
</ol>
<h3 id="fastcgi-sapi"><a class="header" href="#fastcgi-sapi">FastCGI SAPI</a></h3>
<p>Интерфейс FastCGI — клиент-серверный протокол взаимодействия веб-сервера и приложения, дальнейшее развитие технологии CGI. По сравнению с CGI является более производительным и безопасным.</p>
<ol>
<li>PHP интерпретатор запускается как независимый сервер, обрабатывающий входящие запросы на исполнение PHP скриптов по протоколу FastCGI, что позволяет ему работать с любым веб-сервером, поддерживающим этот протокол</li>
<li>более производительный и безопасный</li>
<li>вместо того чтобы создавать новые процессы для каждого нового запроса, использует постоянно запущенные процессы для обработки множества запросов</li>
<li>использует Unix Domain Sockets или TCP/IP для связи с сервером</li>
<li>могут быть запущены не только на этом же сервере, но и где угодно в сети</li>
<li>возможна обработка запросов несколькими FastCGI-процессами, работающими параллельно</li>
<li>в кластере должен находиться только FastCGI-процесс, а не целый веб-сервер</li>
<li>обеспечивает дополнительную безопасность, такую как, например, запуск FastCGI-процесса под учётной записью пользователя, отличного от пользователя веб-сервера, а также может находиться в chroot'е, отличном от chroot'а веб-сервера</li>
<li>может быть использован в любом языке, поддерживающем сокеты.</li>
</ol>
<h3 id="fpm-sapi"><a class="header" href="#fpm-sapi">FPM SAPI</a></h3>
<p><strong>FPM (FastCGI Process Manager), известный как php-fpm</strong> — является альтернативной реализацией PHP FastCGI с несколькими дополнительными возможностями обычно используемыми для высоконагруженных сайтов.</p>
<ul>
<li>продвинутое управление процессами с корректной (graceful) процедурой остановки и запуска;</li>
<li>возможность запуска воркеров с разными uid/gid/chroot/окружением, а также запуска на различных портах с использованием разных php.ini (замещение safe_mode)</li>
<li>логирование стандартных потоков вывода (stdout) и ошибок (stderr)</li>
<li>аварийный перезапуск в случае внезапного разрушения opcode-кеша</li>
<li>поддержка ускоренной загрузки (accelerated upload)</li>
<li>&quot;slowlog&quot; - логирование необычно медленно выполняющихся скриптов (не только их имена, но также и их трассировки. Это достигается с помощью ptrace и других подобных утилит для чтения данных исполнения удаленных процессов)</li>
<li>fastcgi_finish_request() - специальная функция для завершения запроса и сброса всех буферов данных, причем процесс может продолжать выполнение каких-либо длительных действий</li>
<li>динамическое/статическое порождение дочерних процессов</li>
<li>базовая информация о статусе SAPI (аналогично Apache mod_status)</li>
<li>конфигурационный файл, основанный на php.ini.</li>
<li>с версии PHP 5.3.3, php-fpm был включён в PHP как отдельное SAPI</li>
</ul>
<h2 id="cli-sapi"><a class="header" href="#cli-sapi">CLI SAPI</a></h2>
<p><strong>CLI SAPI</strong> — в качестве скрипта командной строки, являющегося исполняемым файлом, который вызывается пользователем из командной строки.</p>
<ul>
<li>в отличие от CGI SAPI, заголовки не пишутся в поток вывода</li>
<li>сообщения об ошибках выдаются в текстовом режиме</li>
<li>PHP CLI не поддерживает GET, POST или загрузку файлов</li>
<li>текущая директория не изменяется на рабочую директорию скрипта</li>
<li>скрипт выполняется в окружении вызвавшего пользователя</li>
<li>в этом случае возможно использование PHP для создания клиентских GUI-приложений</li>
<li>для решения административных задач в операционных системах UNIX, Linux, Microsoft Windows, Mac OS X и AmigaOS.</li>
<li>с версии PHP 5.4.0 в CLI SAPI появилась возможность запуска PHP как отдельного HTTP-сервера (один процесс интерпретатора и выполняет все запросы исключительно последовательно)</li>
</ul>
<h2 id="nginxphp-fpm-vs-apachemodphp"><a class="header" href="#nginxphp-fpm-vs-apachemodphp">NGINX+PHP-FPM vs ApacheModPhp</a></h2>
<p>Апач использует модель prefork(но вообще есть и другие варианты). Каждый процесс обрабатывает единовременно только одно пользовательское соединение. Невыгодно запускать процесс во время установки соединения, поэтому процесс запускается заранее. Апач это старый, тяжеловесный и ресурсоемкий сервер. В стандартную компоновку входит много модулей, которые могут не использоваться непосредственно при обработке запроса, но инициализируются(например даже если запрос идет на статику будет инициализирвоаться ModPhp) тем самым дико замедляя работу.</p>
<p>У nginx есть один главный и несколько рабочих процессов. Основная задача главного процесса — чтение и проверка конфигурации и управление рабочими процессами. Рабочие процессы выполняют фактическую обработку запросов. nginx использует асинхронную модель(процессу не надо ждать пока ответит PHP, в этот момент он может обрабатывать другие запросы), основанную на событиях, и зависящие от операционной системы механизмы для эффективного распределения запросов между рабочими процессами. Отделение основной работы от обработки соединений позволяет каждому воркеру заниматься своей работой и отвлекаться на обработку соединений только тогда когда произошло новое событие. Каждое соединение, обрабатываемое воркером, помещается в event loop вместе с другими соединениями. В этом цикле события обрабатываются асинхронно, позволяя обрабатывать задачи в неблокирующей манере. Когда соединение закрывается - оно удаляется из цикла. Вместо того чтобы выделять на каждый запрос отдельный поток или процесс (как это делают серверы с традиционной архитектурой), NGINX мультиплексирует обработку множества соединений и запросов в одном рабочем процессе. Для этого применяются сокеты в неблокирующем режиме и такие эффективные методы работы с событиями, как <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a> и <a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue">kqueue</a>. Этот подход к обработке соединений позволяет Nginx'у невероятно масштабироваться при ограниченных ресурсах. Поскольку сервер однопоточный и он не создает процессы под каждое соединение, использование памяти и CPU относительно равномерно, даже при высоких нагрузках.</p>
<h3 id="c10k"><a class="header" href="#c10k">C10k</a></h3>
<p>C10k (10k connections — проблема 10 тысяч соединений) — условное название задачи конфигурирования и обслуживания высокопроизводительного сервера, способного обслуживать порядка 10 тыс. соединений одновременно. Формально аппаратное обеспечение современных компьютеров имеет должную производительность для выполнения задачи, однако неэффективные алгоритмы могут приводить к возникновению «заторов».</p>
<p>Ряд известных веб-серверов особо подчёркивают решение задачи C10k, среди таковых Nginx, Lighttpd, Cherokee HTTP Server, Tornado, Node.js, Yaws. Для обхода проблемы используются различные техники: пулирование потоков выполнения (вместо выделения на каждое соединение отдельного потока), применение легковесных процессов, поддержка функций соединений средствами исключительно пользовательского пространства (с минимизацией системных вызовов для обхода ограничений ядра операционной системы).</p>
<p>По состоянию на середину 2010-х годов серверный аппаратный узел среднего уровня способен обрабатывать до 10 млн соединений, и в связи с чем появились требования к программному обеспечению обеспечивать соответствующий уровень производительности по количеству одновременных подключений, обозначаемые как C10M.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li>https://habr.com/post/260065/</li>
<li>https://habr.com/post/260669/</li>
<li>https://habr.com/post/267721/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="http"><a class="header" href="#http">HTTP</a></h2>
<p><strong>HTTP</strong>(HyperText Transfer Protocol) — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). </p>
<p>API многих программных продуктов также подразумевает использование <strong>HTTP</strong> для передачи данных — сами данные при этом могут иметь любой формат, например, <em>XML</em> или <em>JSON</em>.</p>
<h2 id="Структура-http-запроса"><a class="header" href="#Структура-http-запроса">Структура HTTP запроса</a></h2>
<p>HTTP запрос состоит из трех основных частей, которые идут в нем именно в том порядке, который указан ниже. Между заголовками и телом сообщения находится пустая строка (в качестве разделителя), она представляет собой символ перевода строки.</p>
<ul>
<li>
<p><strong>Строка запроса</strong> – указывает метод передачи, URI к которому нужно обратиться и версию протокола HTTP, пример: <code>GET / HTTP/1.1</code></p>
</li>
<li>
<p><strong>Заголовки</strong> – описывают тело сообщений, передают различные параметры и др. сведения и информацию.</p>
</li>
<li>
<p>Пустая строка (разделитель)</p>
</li>
<li>
<p><strong>Тело сообщения</strong> — это сами данные, которые передаются в запросе.  Тело сообщения – это необязательный параметр и может отсутствовать. </p>
</li>
</ul>
<pre><code class="language-http">POST /cgi-bin/process.cgi HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: length
Accept-Language: ru-ru
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

licenseID=string&amp;content=string&amp;/paramsXML=string
</code></pre>
<h2 id="Структура-http-ответа"><a class="header" href="#Структура-http-ответа">Структура HTTP ответа</a></h2>
<p><code>HTTP/Версия Код состояния Пояснение</code></p>
<p><strong>Код состояния</strong> (<em>Status Code</em>) — три цифры (первая из которых указывает на класс состояния), которые определяют результат совершения запроса. Например, в случае, если был использован метод GET, и сервер предоставляет ресурс с указанным идентификатором, то такое состояние задаётся с помощью кода 200. Если сервер сообщает о том, что такого ресурса не существует — 404. Если сервер сообщает о том, что не может предоставить доступ к данному ресурсу по причине отсутствия необходимых привилегий у клиента, то используется код 403. Спецификация HTTP 1.1 определяет 40 различных кодов HTTP, а также допускается расширение протокола и использование дополнительных кодов состояний.</p>
<p><strong>Пояснение</strong> к коду состояния (<em>Reason Phrase</em>) — текстовое (но не включающее символы <em>CR</em> и <em>LF</em>) пояснение к коду ответа, предназначено для упрощения чтения ответа человеком. Пояснение может не учитываться клиентским программным обеспечением, а также может отличаться от стандартного в некоторых реализациях серверного ПО.</p>
<p>После стартовой строки следуют заголовки, а также тело ответа. Например:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Server: nginx/1.2.1
Date: Sat, 08 Mar 2014 22:53:46 GMT
Content-Type: application/octet-stream
Content-Length: 7
Last-Modified: Sat, 08 Mar 2014 22:53:30 GMT
Connection: keep-alive
Accept-Ranges: bytes

Wisdom
</code></pre>
<p>Тело ответа следует через два переноса строки после последнего заголовка. Для определения окончания тела ответа используется значение заголовка <strong>Content-Length</strong> (в данном случае ответ содержит 7 восьмеричных байтов: слово «Wisdom» и символ переноса строки).</p>
<h2 id="http-методы"><a class="header" href="#http-методы">HTTP методы</a></h2>
<p><strong>Http Метод</strong> представляет собой последовательность из любых символов, кроме управляющих и разделителей, и определяет операцию, которую нужно осуществить с указанным ресурсом. </p>
<h4 id="options"><a class="header" href="#options">OPTIONS</a></h4>
<p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок <code>Allow</code> со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях.</p>
<p>Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.</p>
<p>Для того чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «<code>*</code>». Запросы «<code>OPTIONS * HTTP/1.1</code>» могут также применяться для проверки работоспособности сервера (аналогично пингованию) и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.</p>
<p>Результат выполнения этого метода не кэшируется.</p>
<h4 id="get"><a class="header" href="#get">GET</a></h4>
<p>Используется для запроса содержимого указанного ресурса. С помощью метода <code>GET</code> можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.</p>
<p>Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «<code>?</code>»:
<code>GET /path/resource?param1=value1&amp;param2=value2 HTTP/1.1</code></p>
<p>Согласно стандарту HTTP, запросы типа <code>GET</code> считаются идемпотентными</p>
<p>Кроме обычного метода <code>GET</code>, различают ещё</p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/HTTP#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_GET">Условный <code>GET</code></a> — содержит заголовки <code>If-Modified-Since</code>, <code>If-Match</code>, <code>If-Range</code> и подобные;</li>
<li><a href="https://ru.wikipedia.org/wiki/HTTP#%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D1%8B%D0%B5_GET">Частичный <code>GET</code></a> — содержит в запросе <code>Range</code>.</li>
</ul>
<p>Порядок выполнения подобных запросов определён стандартами отдельно.</p>
<h4 id="head"><a class="header" href="#head">HEAD</a></h4>
<p>Аналогичен методу <code>GET</code>, за исключением того, что в ответе сервера отсутствует тело. Запрос <code>HEAD</code> обычно применяется для извлечения <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5">метаданных</a>, проверки наличия ресурса (<a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F">валидация</a> URL) и чтобы узнать, не изменился ли он с момента последнего обращения.</p>
<p>Заголовки ответа могут кэшироваться. При несовпадении <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5">метаданных</a> ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.</p>
<h4 id="post"><a class="header" href="#post">POST</a></h4>
<p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%B3">блогах</a> посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом <a href="https://ru.wikipedia.org/wiki/POST_(HTTP)">POST</a> и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода <code>POST</code> обычно загружаются файлы на сервер.</p>
<p>В отличие от метода <code>GET</code>, метод <code>POST</code> не считается идемпотентным[<a href="https://ru.wikipedia.org/wiki/HTTP#cite_note-http-spec-methods-4">4]</a>, то есть многократное повторение одних и тех же запросов <code>POST</code> может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).</p>
<p>При результате выполнения <code>200</code> (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ <code>201</code> (Created) с указанием <a href="https://ru.wikipedia.org/wiki/URI">URI</a> нового ресурса в заголовке <code>Location</code>.</p>
<p>Сообщение ответа сервера на выполнение метода <code>POST</code> не кэшируется.</p>
<h4 id="put"><a class="header" href="#put">PUT</a></h4>
<p>Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус <code>201</code> (Created). Если же был изменён ресурс, то сервер возвращает <code>200</code> (Ok) или <code>204</code> (No Content). Сервер не должен игнорировать некорректные заголовки <code>Content-*</code>, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки <code>501</code> (Not Implemented).</p>
<p>Фундаментальное различие методов <code>POST</code> и <code>PUT</code> заключается в понимании предназначений URI ресурсов. Метод <code>POST</code> предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя <code>PUT</code>, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.</p>
<p>Сообщения ответов сервера на метод <code>PUT</code> не кэшируются.</p>
<h4 id="patch"><a class="header" href="#patch">PATCH</a></h4>
<p>Аналогично PUT, но применяется только к фрагменту ресурса.</p>
<h4 id="delete"><a class="header" href="#delete">DELETE</a></h4>
<p>Удаляет указанный ресурс.</p>
<h4 id="trace"><a class="header" href="#trace">TRACE</a></h4>
<p>Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</p>
<h4 id="connect"><a class="header" href="#connect">CONNECT</a></h4>
<p>Преобразует соединение запроса в прозрачный <a href="https://ru.wikipedia.org/wiki/TCP/IP">TCP/IP</a>-туннель, обычно, чтобы содействовать установлению защищённого <a href="https://ru.wikipedia.org/wiki/SSL">SSL</a>-соединения через нешифрованный <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BA%D1%81%D0%B8-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80">прокси</a>.</p>
<h2 id="Коды-состояний"><a class="header" href="#Коды-состояний">Коды состояний</a></h2>
<p>Используются для определения состояния запроса, разделены на 5 групп. Каждая группа имеет собственный «общий смысл»:</p>
<ul>
<li>1xx — информационные. Они описывают процесс передачи.</li>
<li>2xx — успешные. Эти говорят нам об успешной передаче.</li>
<li>3xx — перенаправленные. Эти же сигнализируют о перенаправлении запроса.</li>
<li>4xx — ошибка клиента. Ошибки в запросе, синтаксисе, хосте обращения и т.д.</li>
<li>5xx — ошибка сервера. Ошибки в выполнении запроса, связанные с сервером.</li>
</ul>
<p>Примеры:</p>
<ul>
<li><strong>200 ОК</strong> — означает что всё в порядке, запрос обработан и дан ответ.</li>
<li><strong>301 Moved Permanently</strong> — означает что нужный документ перенесён на другой URI. Новый адрес указывается в заголовке Location.</li>
<li><strong>302 Found(v1.1), Moved Temporarily(v1.0)</strong> — указывает на то, что нужный документ временно перенесён на другой URI, который находится в заголовке Location.</li>
<li><strong>400 Bad Request</strong> — означает что в запросе допущена синтаксическая ошибка.</li>
<li><strong>401 Unauthorized</strong> — означает что для доступа нужно пройти аутентификацию.</li>
<li><strong>403 Forbidden</strong> — не хватает прав доступа для выполнения запроса.</li>
<li><strong>404 Not Found</strong> — сервер не может найти запрошенный URI.</li>
<li><strong>500 Internal Server Error</strong> — любая ошибка сервера, если она не подходит под любой другой код ответа.</li>
</ul>
<h2 id="Основные-http-заголовки"><a class="header" href="#Основные-http-заголовки">Основные HTTP заголовки</a></h2>
<h3 id="Общие"><a class="header" href="#Общие">Общие</a></h3>
<ul>
<li><strong>Cache-Control</strong> — параметры управления кэшированием.</li>
<li><strong>Connection</strong> — информация о соединении.</li>
<li><strong>Date</strong> — дата создания сообщения.</li>
<li><strong>Pragma</strong> — специфические опции для выполнения.</li>
<li><strong>Transfer-Encoding</strong> — перечень кодировок, применённых для формирования сообщения.</li>
<li><strong>Upgrade</strong> — перечень протоколов, с которыми может работать клиент. Сервер указывает один.</li>
<li><strong>Via</strong> — история прохождения запроса через прокси сервера, с указанием версии протокола.</li>
</ul>
<p><strong>Запроса</strong></p>
<ul>
<li><strong>Accept</strong> — перечень форматов, с которыми работает ресурс. Остальные игнорируются.</li>
<li><strong>Accept-Charset</strong> — список кодировок с которыми может работать клиент.</li>
<li><strong>Accept-Encoding</strong> — список кодировок, применяемых при кодировании сущности при передаче.</li>
<li><strong>Accept-Language</strong> — перечень языков, с которыми может работать клиент.</li>
<li><strong>Cookie</strong> - передает на сервер все свои куки</li>
<li><strong>Host</strong> — указание доменного имени и порта хоста для запрашиваемого ресурса. Нужно для работы виртуальных хостингов.</li>
<li><strong>Max-Forwards</strong> — указывает предельное кол-во переходов по Proxy серверам.</li>
<li><strong>Referer</strong> — указывает URI ресурса, с которого клиент сделал запрос.</li>
<li><strong>User-Agent</strong> — перечень названий и версий компонентов системы клиента.</li>
</ul>
<p><strong>Ответа</strong></p>
<ul>
<li><strong>Location</strong> — указывает URI ресурса или URI, на который нужно перейти.</li>
<li><strong>Public</strong> — перечисляет доступные методы, подобно Allow, но для всего сервера.</li>
<li><strong>Server</strong> — перечень названий и версий ПО на сервере, для прокси это поле Via.</li>
<li><strong>Set-Cookie</strong> — устанавливает cookie для клиента</li>
</ul>
<p><strong>Сущности</strong></p>
<ul>
<li>
<p><strong>Content-Encoding</strong> — указывает способ кодирования сущности.</p>
</li>
<li>
<p><strong>Content-Language</strong> — язык содержимого.</p>
</li>
<li>
<p><strong>Content-Length</strong> — размер сообщения выраженный в октетах.</p>
</li>
<li>
<p><strong>Content-Location</strong> — резервное расположение сущности.</p>
</li>
<li>
<p><strong>Content-Disposition</strong> — В обычном HTTP-ответе заголовок <code>**Content-Disposition**</code> является индикатором того, что ожидаемый контент ответа будет отображаться в браузере, как вэб-страница или часть вэб-страницы, или же как вложение, которое затем может быть скачано и сохранено локально. </p>
<p>В случае, если тело HTTP-запроса типа <code>multipart/form-data</code>, то общий заголовок <strong>Content-Disposition</strong> используется для каждой из составных частей multipart тела для указания дополнительных сведений по полю, к которому применён заголовок. Каждая часть отделена с помощью <em>границы (boundary)</em>, определённой в заголовке <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a>. <code>Content-Disposition,</code> используемый непосредственно для всего тела HTTP-запроса, ни на что не влияет.</p>
</li>
<li>
<p><strong>Content-MD5</strong> — MD5-хэш для проверки целостности полученных данных.</p>
</li>
<li>
<p><strong>Content-Type</strong> — способ и формат отображения сущности.</p>
</li>
<li>
<p><strong>Link</strong> — ссылка на связанный с сущностью ресурс.</p>
</li>
<li>
<p><strong>Title</strong> — заголовок сущности.</p>
</li>
<li>
<p><strong>Allow</strong> — перечень методов, поддерживаемых именно этим ресурсом(ток для ответа)</p>
</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%BE%D0%B2_HTTP#%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8">Основные_заголовки</a></li>
<li><a href="https://zametkinapolyah.ru/servera-i-protokoly/tema-10-spravochnik-polej-http-zagolovkov-spisok-polej-http-zagolovka-zagolovki-http-soobshhenij-zaprosov-i-otvetov.html">Справочник полей HTTP заголовков</a></li>
</ul>
<h2 id="cookie"><a class="header" href="#cookie">Cookie</a></h2>
<p>Ку́ки — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:</p>
<ul>
<li>аутентификации пользователя;</li>
<li>хранения персональных предпочтений и настроек пользователя;</li>
<li>отслеживания состояния сеанса[en] доступа пользователя;</li>
<li>ведения статистики о пользователях.</li>
</ul>
<h3 id="Установка-куки"><a class="header" href="#Установка-куки">Установка куки</a></h3>
<p>Запрашивая страницу, браузер отправляет веб-серверу короткий текст с HTTP-запросом. Например, для доступа к странице http://www.example.org/index.html, браузер отправляет на сервер www.example.org обычный запрос. На который сервер отвечает, отправляя запрашиваемую страницу вместе с текстом, содержащим HTTP-ответ. Там может содержаться указание браузеру сохранить куки:</p>
<pre><code class="language-http">HTTP/1.1 200 OK
Content-type: text/html
Set-Cookie: name=value
</code></pre>
<p>Строка <code>Set-cookie</code> отправляется лишь тогда, когда сервер желает, чтобы браузер сохранил куки. В этом случае, если куки поддерживаются браузером и их приём включён, браузер запоминает строку <code>name=value</code> (имя = значение) и отправляет её обратно серверу с каждым последующим запросом. Например, при запросе следующей страницы http://www.example.org/spec.html браузер пошлёт серверу www.example.org следующий запрос:</p>
<pre><code class="language-http">GET /spec.html HTTP/1.1
Host: www.example.org
Cookie: name=value
Accept: */*
</code></pre>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p><strong>HTTPS</strong> (HyperText Transfer Protocol Secure) — расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS. В отличие от HTTP, для HTTPS по умолчанию используется TCP-порт 443.</p>
<p>HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от снифферских атак и атак типа man-in-the-middle, при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют.</p>
<h2 id="Новшества-разных-версий-http"><a class="header" href="#Новшества-разных-версий-http">Новшества разных версий HTTP</a></h2>
<h3 id="http-11"><a class="header" href="#http-11">HTTP 1.1</a></h3>
<p>Новым в этой версии был режим «постоянного соединения»(keep-alive): TCP-соединение может оставаться открытым после отправки ответа на запрос, что позволяет посылать несколько запросов за одно соединение. Клиент теперь обязан посылать информацию об имени хоста(<a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Host"><code>Host</code></a> заголовок), к которому он обращается, что сделало возможной более простую организацию виртуального хостинга.</p>
<p>Достоинства:</p>
<ul>
<li>Ниже загрузка <a href="https://ru.wikipedia.org/wiki/%D0%A6%D0%9F%D0%A3">ЦПУ</a> и расход памяти (потому как открывается меньше соединений одновременно).</li>
<li>Можно использовать <a href="https://ru.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining (конвейерную обработку)</a> запросов и ответов.</li>
<li>Снижает вероятность перегрузки сети (меньше <a href="https://ru.wikipedia.org/wiki/TCP">TCP</a> соединений).</li>
<li>Уменьшает <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D0%B3_(%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D1%8B%D0%B9_%D1%81%D0%BB%D0%B5%D0%BD%D0%B3)">лаги</a> для последующих запросов (не нужно заново устанавливать TCP соединение).</li>
<li>Ошибки HTTP возвращаются без закрытия соединения — клиенты могут пробовать новые команды, и, если они не поддерживаются сервером, послать повторный запрос в том же соединении, используя старую семантику.</li>
</ul>
<p>Эти достоинства особенно проявляются для защищённых <a href="https://ru.wikipedia.org/wiki/HTTPS">HTTPS</a> соединений, потому что создание защищённого соединения требует больше процессорного времени и сетевого обмена между клиентом и сервером.</p>
<h3 id="http--2"><a class="header" href="#http--2">HTTP  2</a></h3>
<ul>
<li>бинарный, сжатие заголовков;</li>
<li>мультиплексирование данных;</li>
<li>приоритизация;</li>
<li>возможна отмена загрузки;</li>
<li>server push</li>
</ul>
<p>Вторая крупная версия сетевого протокола HTTP, используемая для доступа к World Wide Web. Протокол основан на SPDY.</p>
<p>В отличие от текстового HTTP 1.1, HTTP/2 — бинарный. Поэтому протокол более эффективен при парсинге, более компактный при передаче, подвержен меньшему количеству ошибок.</p>
<p>В HTTP 1.1 браузеры используют множественные подключения к серверу для загрузки веб-страницы, причем количество таких соединений ограничено. Но это не решает проблему с блокированием канала медленными пакетами. Тогда как в HTTP/2 используется мультиплексирование, которое позволяет браузеру использовать одно соединение TCP для всех запросов. Все файлы подгружаются параллельно. Запросы и ответы разделяются по фреймам с мета-данными, которые ассоциируют запросы и ответы. Так что они не перекрывают друг-друга и не вызывают путаницы. При этом ответы получаются по мере их готовности, следовательно, тяжелые запросы не будут блокировать обработку и выдачу более простых объектов.</p>
<p>HTTP 1.1 offers different workarounds for latency issues, including pipelining and the Keep-Alive header. However, pipelining was never widely implemented and the Keep-Alive header suffered from head-of-line blocking: the current request must complete before the next one can be sent.</p>
<p>In HTTP/2, multiple asset requests can reuse a single TCP connection. Unlike HTTP 1.1 requests that use the Keep-Alive header, the requests and response binary frames in HTTP/2 are interleaved and head-of-line blocking does not happen. The cost of establishing a connection (the well-known “three-way handshake”) has to happen only once per host. Multiplexing is especially beneficial for secure connections because of the performance cost involved with multiple TLS negotiations.</p>
<p>Вместе с мультиплексированием появилась приоритезация трафика. Запросам можно назначить приоритет на основе важности и зависимости. Так что при загрузке веб-страницы браузер будет в первую очередь получать важные данные, CSS-код, к примеру, а все второстепенное обработается в последнюю очередь.</p>
<p>Протокол HTTP построен таким образом, что при отправке запросов также передаются заголовки, которые содержат дополнительную информацию. Сервер, в свою очередь, также прикрепляет заголовки к ответам. А учитывая, что веб-страницы состоят из множества файлов, все заголовки могут занимать приличный объем. Поэтому в HTTP/2 присутствует <strong>сжатие заголовков</strong>, которое позволит существенно сократить объем вспомогательной информации, так что браузер сможет отправить все запросы сразу.</p>
<p>При использовании протокола HTTP 1.1 браузер запрашивает страницу, сервер отправляет в ответ HTML и ждет, пока браузер его обработает и запросит все необходимые файлы: JavaScript, CSS и фото. Поэтому в новый протокол внедрили интересную функцию под названием Server Push. Она позволяет серверу сразу же, не дожидаясь ответа веб-браузера, добавить нужные по его мнению файлы в кэш для быстрой выдачи.</p>
<h3 id="http3"><a class="header" href="#http3">HTTP3</a></h3>
<p>Протокол <strong>QUIC</strong> с 2013 года развивает Google в качестве альтернативы TCP+TLS. Главным преимуществом является снижение задержек при потере пакетов и уменьшение времени установки и согласования соединений. Технически <strong>QUIC</strong> представляет собой надстройку над протоколом UDP. QUIC поддерживает мультиплексирование нескольких соединений, а также методы шифрования, аналогичные TLS/SSL.</p>
<ul>
<li>
<p>уровень безопасности, сравнимый с TLS;</p>
</li>
<li>
<p>контроль целостности потока с помощью прямой коррекции ошибок, предотвращающей потерю пакетов;</p>
</li>
<li>
<p>почти мгновенное установление соединения и возможность сразу после отправки пакета подключения передавать данные, а также минимизация задержки между отправкой запроса и получением ответа;</p>
</li>
<li>
<p>наличие идентификатора соединения UUID позволит сократить время на переподключение к сетям для перемещающихся мобильных клиентов;</p>
</li>
<li>
<p>избавление от таймаутов за счёт отказа от того же номера последовательности при повторной передаче пакетов;</p>
</li>
<li>
<p>разделение на потоки, при котором потеря пакета влияет только на свой поток;</p>
</li>
<li>
<p>новая система коррекции ошибок на основе кодов;</p>
</li>
<li>
<p>выравнивание криптографических границ блоков с границами пакетов QUIC, что снижает влияние потери пакетов на декодирование;</p>
</li>
<li>
<p>отсутствие проблем с блокировкой очереди TCP;</p>
</li>
<li>
<p>система прогнозирования пропускной способности в каждом направлении, что позволяет уменьшить вероятность возникновения перегрузки. Как следствие — рост производительности и пропускной способности, по сравнению с TCP. В частности, для YouTube это позволило снизить повторную буферизацию на 30 %.</p>
<p><img src="network/../media/network/htpp_v.png" alt="" /></p>
</li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/post/215117/">Простым языком об HTTP</a></li>
<li><a href="https://ruseller.com/lessons.php?id=1726&amp;rub=28">HTTP: протокол, который каждый разработчик должен знать (часть 1)</a></li>
<li><a href="https://ruseller.com/lessons.php?rub=28&amp;id=1777">HTTP: протокол, который каждый разработчик должен знать (часть 2)</a></li>
<li>https://developer.mozilla.org/ru/docs/Web/HTTP/Overview</li>
<li><a href="https://www.8host.com/blog/v-chem-raznica-mezhdu-http1-1-i-http2/">http2</a></li>
<li><a href="https://ruhighload.com/%D0%9E%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F+%D0%B2+http%2F2">Оптимизация в HTTP/2</a></li>
<li><a href="https://habr.com/company/nixsolutions/blog/304518/">Как HTTP/2 сделает веб быстрее</a></li>
<li>http://portscan.ru/article-protocol-http.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tls"><a class="header" href="#tls">TLS</a></h2>
<p>SSL и TLS представляют собой развитие одной и той же технологии. Аббревиатура TLS (Transport Layer Security) появилась в качестве замены обозначения SSL (Secure Sockets Layer) после того, как протокол окончательно стал интернет-стандартом. Такая замена вызвана юридическими аспектами, так как спецификация SSL изначально принадлежала компании Netscape. И сейчас нередко названия SSL и TLS продолжают использовать в качестве синонимов, но каноническим именем является TLS, а протоколы семейства SSL окончательно устарели и не должны использоваться.</p>
<p>Конкретное место TLS (SSL) в стеке протоколов Интернета показано на схеме:</p>
<p><img src="network/../media/network/tls-internet.png" alt="img" /></p>
<h5 id="tls-handshake"><a class="header" href="#tls-handshake"><strong>TLS Handshake</strong></a></h5>
<p><img src="network/../media/network/tls-handshake.png" alt="img" /></p>
<p>Основные шаги процедуры создания защищённого сеанса связи:</p>
<ul>
<li>клиент подключается к серверу, поддерживающему TLS, и запрашивает защищённое соединение;</li>
<li>клиент предоставляет список поддерживаемых <a href="https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">алгоритмов шифрования</a> и <a href="https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">хеш-функций</a>;</li>
<li>сервер выбирает из списка, предоставленного клиентом, наиболее надёжные алгоритмы среди тех, которые поддерживаются сервером, и сообщает о своём выборе клиенту;</li>
<li>сервер отправляет клиенту цифровой сертификат для собственной аутентификации. Обычно цифровой сертификат содержит имя сервера, имя удостоверяющего центра сертификации и открытый ключ сервера;</li>
<li>клиент, до начала передачи данных, проверяет валидность (аутентичность) полученного серверного сертификата относительно имеющихся у клиента корневых сертификатов удостоверяющих центров (центров сертификации). Клиент также может проверить, не отозван ли серверный сертификат, связавшись с сервисом доверенного удостоверяющего центра;</li>
<li>для шифрования сессии используется <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B0%D0%BD%D1%81%D0%BE%D0%B2%D1%8B%D0%B9_%D0%BA%D0%BB%D1%8E%D1%87">сеансовый ключ</a>. Получение общего секретного сеансового ключа клиентом и сервером проводится по протоколу Диффи-Хеллмана. Существует исторический метод передачи сгенерированного клиентом секрета на сервер при помощи шифрования асимметричной криптосистемой RSA (используется ключ из сертификата сервера). Данный метод не рекомендован, но иногда продолжает встречаться на практике.</li>
</ul>
<p>На этом заканчивается процедура подтверждения связи. Между клиентом и сервером установлено безопасное соединение, данные, передаваемые по нему, шифруются и расшифровываются с использованием симметричной криптосистемы до тех пор, пока соединение не будет завершено.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/TLS">TLS — Википедия</a></li>
<li><a href="https://habr.com/ru/post/258285/">Что такое TSL</a></li>
<li><a href="https://tls.dxdt.ru/tls.html">Ключи, шифры, сообщения: как работает TLS</a></li>
<li><a href="https://www.opennet.ru/docs/RUS/ldap_apacheds/tech/ssl.html">Руководство по выживанию — TLS/SSL и сертификаты SSL</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-name-system"><a class="header" href="#domain-name-system">Domain Name System</a></h1>
<p>Основной задачей DNS-сервера является трансляция доменных имен в IP адреса и обратно. На заре становления Интернета (когда он еще был ARPANET'ом) это решалось ведением длинных списков, включающих все компьютеры сети, причем копия такого списка должна была присутствовать на каждом компьютере. Некоторые &quot;пережитки&quot; этого метода можно обнаружить и сейчас: существует файл HOSTS (и в UNIX, и в Windows), в котором можно прописывать адреса серверов, с которыми вы регулярно работаете (кстати, именно его использование лежит в основе многих &quot;ускорителей Интернета&quot; — такие программы просто записывают адреса серверов, к которым вы обращаетесь, в файл HOSTS и при следующем обращении берут данные из него, не тратя время на запрос к DNS-серверу).</p>
<p>На смену &quot;однофайловой&quot; схеме пришел DNS — иерархическая структура имен. Существует &quot;корень дерева&quot; с именем &quot;.&quot; (точка). Так как корень един для всех доменов, то точка в конце имени обычно не ставится (но она используется в описаниях DNS). Ниже корня лежат домены первого уровня. Их немного — com, net, info, ru и т.д. Ниже находятся домены второго уровня, например, listsoft.ru. Еще ниже — третьего и т.д.</p>
<p>Иерархичность DNS-серверов — штука довольно интересная, если проследить прохождение запроса. При установке (точнее, при настройке) клиенту указывается как минимум один DNS-сервер (как правило, их два) — его адрес выдается провайдером. Клиент посылает запрос этому серверу. Сервер, получив запрос, либо отвечает (если ответ ему известен), либо пересылает запрос на &quot;вышестоящий&quot; сервер (если он известен) или на корневой (каждому DNS-серверу известны адреса корневых DNS-серверов). Так выглядит &quot;восходящая иерархия&quot;. Затем запрос начинает спускаться вниз — корневой сервер пересылает запрос серверу первого уровня, тот — серверу второго уровня и т.д. Таким образом, каждый DNS-сервер всегда либо знает ответ, либо знает, у кого спросить.</p>
<p>Помимо &quot;вертикальных связей&quot;, у серверов есть еще и &quot;горизонтальные&quot; отношения — &quot;первичный — вторичный&quot;. Действительно, если предположить, что сервер, обслуживающий какой-то домен и работающий &quot;без страховки&quot; вдруг перестанет быть доступным, то все машины, расположенные в этом домене, окажутся недоступны! Именно поэтому при регистрации домена второго уровня выдвигается требование указать минимум два сервера DNS, которые будут этот домен обслуживать.</p>
<p>DNS-сервера бывают рекурсивные и нерекурсивные. Первые всегда возвращают клиенту ответ — они самостоятельно отслеживают отсылки к другим DNS-серверам и опрашивают их. Нерекурсивные сервера возвращают клиенту эти отсылки, так что клиент должен самостоятельно опрашивать указанный сервер. Рекурсивные сервера удобно использовать на низких уровнях, в частности, в локальных сетях. Дело в том, что они кэшируют все промежуточные ответы, и при последующих запросах ответы будут возвращаться намного быстрее. Нерекурсивные сервера обычно стоят на верхних ступенях иерархии — поскольку они получают очень много запросов, то для кэширования ответов никаких ресурсов не хватит.</p>
<p>Полезным свойством DNS является умение использовать &quot;пересыльщиков&quot; (forwarders). &quot;Честный&quot; DNS-сервер самостоятельно опрашивает другие сервера и находит нужный ответ, но если ваша сеть подключена к Интернету по медленной (например, dial-up) линии, то этот процесс может занимать довольно много времени. Вместо этого можно перенаправлять все запросы, скажем, на сервер провайдера, а затем принимать его ответ. Использование &quot;пересыльщиков&quot; может оказаться интересным и для больших компаний с несколькими сетями: в каждой сети можно поставить относительно слабый DNS-сервер, указав в качестве &quot;пересыльщика&quot; более мощную машину, подключенную по быстрой линии. При этом все ответы будут кэшироваться на этом мощном сервере, что ускорит разрешение имен для целой сети.</p>
<p>Для каждого домена администратор ведет базу данных DNS. Эта база данных представляет собой набор простых текстовых файлов, расположенных на основном (первичном) сервере DNS (вторичные сервера периодически копируют к себе эти файлы). В файлах конфигурации сервера указывается, в каком именно файле содержатся описания каких зон, и является ли сервер первичным или вторичным для этой зоны.</p>
<p>Элементы базы DNS часто называют RR (сокращение от Resource Record). Базовый формат записи выглядит так:</p>
<p><code>[имя][время] [класс] тип данные</code></p>
<p><em>Имя</em> может быть относительным или абсолютным (FQDN — Fully Qualified Domain Name). Если имя относительное (не заканчивается точкой — помните про корневой домен?), то к нему автоматически добавляется имя текущего домена. Например, если в домене listsoft.ru я опишу имя «www», то полное имя будет интерпретироваться как &quot;www.listsoft.ru.&quot; Если же это имя указать как &quot;www.listsoft.ru&quot; (без последней точки), то оно будет считаться относительным и будет интерпретировано как &quot;www.listsoft.ru.listsoft.ru.&quot;</p>
<p><em>Время</em> задает интервал времени в секундах, в течение которого данные могут сохраняться в кэше сервера. </p>
<p><em>класс</em> определяет класс сети. Практически всегда это будет IN, обозначающее INternet.</p>
<p><em>Тип</em> может быть одним из следующих: </p>
<ul>
<li>SOA — определяет DNS зону </li>
<li>NS — сервер имен для зоны </li>
<li>A — преобразование имени в IP-адрес </li>
<li>PTR — преобразование IP-адреса в имя </li>
<li>MX — почтовая станция </li>
<li>CNAME — имена машины </li>
<li>HINFO — описание &quot;железа&quot; компьютера </li>
<li>TXT — комментарии или какая-то другая информация </li>
<li>Есть также некоторые другие типы, но они намного менее распространены.</li>
</ul>
<p>В записях можно использовать символы <strong>#</strong> и <strong>;</strong> для комментариев, <strong>@</strong> для обозначения текущего домена, <strong>()</strong> — скобки — для написания данных на нескольких строках. Кроме того, можно использовать метасимвол ***** в имени. Порядок записей не имеет значения за одним исключением: запись SOA должна идти первой. Дальнейшие записи считаются относящимися к той же зоне, пока не встретится новая запись SOA. Как правило, после записи зоны указывают записи DNS-серверов, а остальные записи располагают по алфавиту, но это не обязательно.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="http://hostinfo.ru/articles/57">DNS-сервер — как это работает</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tcpip"><a class="header" href="#tcpip">TCP/IP</a></h1>
<p>Протокол TCP/IP - это набор сетевых протоколов, используемых для обмена данными в компьютерных сетях. Он состоит из
четырех уровней, каждый из которых выполняет определенные функции. Вот краткое описание каждого уровня протокола TCP/IP:</p>
<h3 id="Уровень-доступа-к-сети-network-interface-layer"><a class="header" href="#Уровень-доступа-к-сети-network-interface-layer">Уровень доступа к сети (Network Interface Layer):</a></h3>
<p>Этот уровень отвечает за передачу данных через физическую сеть, такую как Ethernet или Wi-Fi. Он определяет способы
кодирования, физические характеристики кабелей, методы доступа и другие аспекты, связанные с конкретной технологией
передачи данных.</p>
<h3 id="Уровень-интернета-internet-layer"><a class="header" href="#Уровень-интернета-internet-layer">Уровень интернета (Internet Layer):</a></h3>
<p>Этот уровень обеспечивает маршрутизацию пакетов данных через различные сети. Он использует IP-адресацию для определения
и доставки пакетов данных между узлами сети. Протокол IP (Internet Protocol) является ключевым протоколом этого уровня.
Он также обрабатывает фрагментацию и сборку пакетов данных при передаче через сети с различными максимальными размерами
пакетов.</p>
<h3 id="Транспортный-уровень-transport-layer"><a class="header" href="#Транспортный-уровень-transport-layer">Транспортный уровень (Transport Layer):</a></h3>
<p>Этот уровень обеспечивает надежную доставку данных между хостами. Два наиболее распространенных протокола на этом
уровне - это TCP (Transmission Control Protocol) и UDP (User Datagram Protocol). TCP обеспечивает надежную и
упорядоченную доставку данных, контроль потока и обнаружение и восстановление потерянных пакетов. UDP, в отличие от TCP,
предоставляет ненадежную доставку без гарантии порядка и восстановления потерянных пакетов.</p>
<p>Прикладной уровень (Application Layer):
Этот уровень содержит различные протоколы, используемые приложениями для обмена данными. Некоторые из наиболее известных
протоколов этого уровня включают HTTP (HyperText Transfer Protocol) для передачи веб-страниц, SMTP (Simple Mail Transfer
Protocol) для отправки электронной почты, FTP (File Transfer Protocol) для передачи файлов и DNS (Domain Name System)
для разрешения имен хостов в IP-адреса.</p>
<p>Эти уровни взаимодействуют друг с другом, чтобы обеспечить передачу данных через сети, обработку ошибок, контроль потока
и другие функции, необходимые для эффективной коммуникации</p>
<h1 id="tcpudp"><a class="header" href="#tcpudp">TCP/UDP</a></h1>
<p>Основные отличия tcp от udp.</p>
<ul>
<li><code>TCP гарантирует доставку пакетов данных в неизменных виде, последовательности и без потерь, UDP ничего не гарантирует.</code></li>
<li><code>TCP нумерует пакеты при передаче, а UDP нет</code></li>
<li><code>TCP работает в дуплексном режиме, в одном пакете можно отправлять информацию и подтверждать получение предыдущего пакета.</code></li>
<li><code>TCP требует заранее установленного соединения, UDP соединения не требует, у него это просто поток данных.</code></li>
<li><code>UDP обеспечивает более высокую скорость передачи данных.</code></li>
<li><code>TCP надежнее и осуществляет контроль над процессом обмена данными.</code></li>
<li><code>UDP предпочтительнее для программ, воспроизводящих потоковое видео, видеофонии и телефонии, сетевых игр.</code></li>
<li><code>UPD не содержит функций восстановления данных</code></li>
</ul>
<p><img src="network/../media/network/tcp_udp_stack.jpeg" alt="TC{/IP vs UDP/IP}" /></p>
<p>На схеме представлены TCP/IP и UDP/IP стек. Внизу есть Ethernet-пакеты, IP-пакеты, и дальше на уровне ОС есть TCP и UDP.
TCP и UDP в этом стеке не сильно друг от друга отличаются. Они инкапсулируются в IP-пакеты, и приложения могут ими
пользоваться. Чтобы увидеть отличия, нужно посмотреть внутрь TCP- и UDP-пакета.</p>
<p><img src="network/../media/network/tcp_udp_format.jpeg" alt="TCP vs UDP Formats" /></p>
<p>И там, и там есть порты. Но <strong>в UDP есть только контрольная сумма</strong> — длина пакета, этот протокол максимально простой. А
в TCP — очень много данных, которые явно указывают окно, acknowledgement, sequence, пакеты и так далее. Очевидно, <strong>TCP
более сложный</strong>. Если говорить очень грубо, то TCP — это протокол надежной доставки, а UDP — ненадежной.</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://networkguru.ru/protokol-transportnogo-urovnia-tcp-chto-nuzhno-znat/">Протокол TCP</a></li>
<li><a href="https://habr.com/ru/company/oleg-bunin/blog/461829/">TCP против UDP</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Сетевые-моделистеки-протоколов"><a class="header" href="#Сетевые-моделистеки-протоколов">Сетевые модели(стеки протоколов)</a></h2>
<h2 id="osi"><a class="header" href="#osi">OSI</a></h2>
<p><strong>OSI</strong> - формальная, теоретическая сетевая модель</p>
<ol>
<li>Уровень приложений: <strong>данные</strong>; доступ к сетевым службам, (HTTP, FTP, SMTP, RDP, SNMP, DHCP)</li>
<li>Уровень представления данных: <strong>данные</strong>; представление и шифрование данных (ASCII, EBCDIC)</li>
<li>Сеансовый уровень: <strong>данные</strong>; управление сеансом связи (RPC, PAP)</li>
<li>Транспортный уровень: <strong>сегменты / дейтаграммы</strong>; прямая связь между конечными пунктами и надёжность (TCP, UDP, SCTP, PORTS)</li>
<li>Сетевой уровень: <strong>пакеты</strong>; определение маршрута и логическая адресация (IPv4, IPv6, IPsec, AppleTalk)</li>
<li>Канальный уровень: <strong>биты / кадры</strong>; физическая адресация (PPP, IEEE 802.22, Ethernet, DSL, ARP, L2TP, Network Cards)</li>
<li>Физический уровень: <strong>биты</strong>; Работа со средой передачи, сигналами и двоичными данными (USB, кабель (&quot;витая пара&quot;, коаксиальный, оптоволоконный), радиоканал)</li>
</ol>
<h3 id="7--протокол-прикладного-уровня-application-layer"><a class="header" href="#7--протокол-прикладного-уровня-application-layer">7 — протокол прикладного уровня (Application layer)</a></h3>
<ul>
<li>взаимодействие сети и пользователя</li>
<li>уровень разрешает приложениям пользователя иметь доступ к сетевым службам, таким, как обработчик запросов к базам данных, доступ к файлам, пересылке электронной почты</li>
<li>отвечает за передачу служебной информации, предоставляет приложениям информацию об ошибках и формирует запросы к уровню представления</li>
</ul>
<h3 id="6--уровень-представления-presentation-layer"><a class="header" href="#6--уровень-представления-presentation-layer">6 — уровень представления (Presentation layer)</a></h3>
<ul>
<li>передаваемая информация не меняет содержания</li>
<li>преобразование данных</li>
<li>преобразование между различными наборами символов</li>
<li>сжатие данных для увеличения пропускной способности канала</li>
<li>шифрование и расшифрование</li>
</ul>
<h3 id="5--сеансовый-уровень-session-layer"><a class="header" href="#5--сеансовый-уровень-session-layer">5 — сеансовый уровень (Session layer)</a></h3>
<ul>
<li>уровень управляет созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных и поддержанием сеанса в периоды неактивности приложений</li>
<li>синхронизация передачи обеспечивается помещением в поток данных контрольных точек, начиная с которых возобновляется процесс при нарушении взаимодействия</li>
</ul>
<h3 id="4--транспортный-уровень-transport-layer"><a class="header" href="#4--транспортный-уровень-transport-layer">4 — транспортный уровень (Transport layer)</a></h3>
<ul>
<li>предоставляет сам механизм передачи</li>
<li>блоки данных он разделяет на фрагменты, размеры которых зависят от протокола: короткие объединяет в один, а длинные разбивает</li>
<li>протоколы этого уровня предназначены для взаимодействия типа точка-точка</li>
<li>протоколы транспортного уровня часто имеют функцию контроля доставки данных, заставляя принимающую данные систему отправлять подтверждения передающей стороне о приеме данных</li>
<li>отвечает за восстановление порядка данных при использовании <strong>сетевых протоколов без установки соединения</strong></li>
</ul>
<h3 id="3--сетевой-уровень-network-layer"><a class="header" href="#3--сетевой-уровень-network-layer">3 — сетевой уровень (Network layer)</a></h3>
<ul>
<li>предназначается для определения пути передачи данных</li>
<li>трансляцию логических адресов и имён в физические</li>
<li>определение кратчайших маршрутов, коммутацию и маршрутизацию, отслеживание неполадок и заторов в сети</li>
<li>На этом уровне работает такое сетевое устройство, как маршрутизатор.</li>
<li>типы:
<ol>
<li><strong>Протоколы с установкой соединения</strong> начинают передачу данных с вызова или установки маршрута следования пакетов от источника к получателю. После чего начинают последовательную передачу данных и затем по окончании передачи разрывают связь.</li>
<li><strong>Протоколы без установки соединения</strong> посылают данные, содержащие полную адресную информацию в каждом пакете. Каждый пакет содержит адрес отправителя и получателя. Далее каждое промежуточное сетевое устройство считывает адресную информацию и принимает решение о маршрутизации данных. Письмо или пакет данных передается от одного промежуточного устройства к другому до тех пор, пока не будет доставлено получателю. Протоколы без установки соединения не гарантируют поступление информации получателю в том порядке, в котором она была отправлена, так как разные пакеты могут пройти разными маршрутами.</li>
</ol>
</li>
</ul>
<h3 id="2--канальный-уровень-data-link-layer"><a class="header" href="#2--канальный-уровень-data-link-layer">2 — канальный уровень (Data Link layer)</a></h3>
<ul>
<li>получение доступа к среде передачи</li>
<li>выделение границ кадра (резервирование некоторой последовательности, обозначающей начало или конец кадра)</li>
<li>Аппаратная адресация (или адресация канального уровня). Требуется в том случае, когда кадр могут получить сразу несколько адресатов. В локальных сетях аппаратные адреса (MAC-адреса) применяются всегда.</li>
<li>обеспечение достоверности принимаемых данных. Во время передачи кадра есть вероятность, что данные исказятся. Важно это обнаружить и не пытаться обработать кадр, содержащий ошибку. Обычно на канальном уровне используются алгоритмы контрольных сумм, дающие высокую гарантию обнаружения ошибок.</li>
<li>в программировании доступ к этому уровню предоставляет драйвер сетевой платы</li>
<li>на этом уровне работают коммутаторы, мосты</li>
<li>2 подуровня
<ol>
<li><strong>LLC (Logical Link Control)</strong> обеспечивает обслуживание сетевого уровня</li>
<li><strong>MAC (Media Access Control)</strong> регулирует доступ к разделяемой физической среде
<ol>
<li>выступает в качестве интерфейса между подуровнем LLC и физическим (первым) уровнем</li>
<li>обеспечивает адресацию и механизмы управления доступом к каналам, что позволяет нескольким терминалам или точкам доступа общаться между собой в многоточечной сети</li>
<li>эмулирует полнодуплексный логический канал связи в многоточечной сети</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="1--физический-слой-physical-layer"><a class="header" href="#1--физический-слой-physical-layer">1 — физический слой (physical layer)</a></h3>
<ul>
<li>физическая и электрическая среда для передачи данных</li>
<li>способы передачи бит через физические среды линий связи, соединяющие сетевые устройства</li>
<li>описываются параметры сигналов, такие как амплитуда, частота, фаза, используемая модуляция, манипуляция</li>
<li>решаются вопросы связанные с синхронизацией, избавлением от помех, скорости передачи данных</li>
</ul>
<h2 id="tcpip-1"><a class="header" href="#tcpip-1">TCP/IP</a></h2>
<p><strong>TCP/IP</strong> — сетевая модель выведенная из практического использования(в отличии от OSI).</p>
<p><img src="network/../media/network/tcp-vs-udp.png" alt="tcp-vs-udp-01" /></p>
<h3 id="4--Прикладной-уровень"><a class="header" href="#4--Прикладной-уровень">4 — Прикладной уровень</a></h3>
<ul>
<li>протоколы работают поверх <strong>TCP</strong> или UDP и привязаны к определённому порту</li>
<li>порты определены Агентством по выделению имен и уникальных параметров протоколов</li>
<li>протоколы: Echo, Finger, Gopher, HTTP, HTTPS, IMAP, IMAPS, IRC, NNTP, NTP, POP3, POPS, QOTD, RTSP, SNMP, SSH, Telnet, XDMCP.</li>
</ul>
<h3 id="3--Транспортный-уровень"><a class="header" href="#3--Транспортный-уровень">3 — Транспортный уровень</a></h3>
<ul>
<li>в стеке TCP/IP транспортные протоколы определяют, для какого именно приложения предназначены эти данные</li>
<li>протоколы
<ol>
<li><strong>TCP (IP идентификатор 6)</strong> — «гарантированный» транспортный механизм с предварительным установлением соединения, предоставляющий приложению надёжный поток данных, дающий уверенность в безошибочности получаемых данных, перезапрашивающий данные в случае потери и устраняющий дублирование данных. TCP позволяет регулировать нагрузку на сеть, а также уменьшать время ожидания данных при передаче на большие расстояния. Более того, TCP гарантирует, что полученные данные были отправлены точно в такой же последовательности.</li>
<li><strong>UDP (IP идентификатор 17)</strong> — протокол передачи датаграмм без установления соединения. Также его называют протоколом «ненадёжной» передачи, в смысле невозможности удостовериться в доставке сообщения адресату, а также возможного перемешивания пакетов. В приложениях, требующих гарантированной передачи данных, используется протокол TCP. С другой стороны, благодаря такой неизбирательности и бесконтрольности, UDP доставляет пакеты данных (датаграммы) гораздо быстрее, потому для приложений, которые рассчитаны на широкую пропускную способность и быстрый обмен, UDP можно считать оптимальным протоколом. К таковым относятся сетевые и браузерные игры, а также программы просмотра потокового видео и приложения для видеосвязи (или голосовой). Также по udp обычно доставляется статистика в хайлод проектах.</li>
</ol>
</li>
<li>И TCP, и UDP используют для определения протокола верхнего уровня число, называемое портом.</li>
</ul>
<h3 id="2--Сетевой-межсетевой-уровень"><a class="header" href="#2--Сетевой-межсетевой-уровень">2 — Сетевой (межсетевой) уровень</a></h3>
<ul>
<li>изначально разработан для передачи данных из одной сети в другую</li>
<li>на этом уровне работают маршрутизаторы, которые перенаправляют пакеты в нужную сеть путем расчета адреса сети по маске сети</li>
<li>пакеты сетевого протокола IP могут содержать код, указывающий, какой именно протокол следующего уровня нужно использовать, чтобы извлечь данные из пакета. Это число — уникальный IP-номер протокола. ICMP и IGMP имеют номера, соответственно, 1 и 2</li>
<li>протоколы:  DVMRP, ICMP, IGMP, MARS, PIM, RIP, RIP2, RSVP</li>
</ul>
<h3 id="1--Канальный-уровень"><a class="header" href="#1--Канальный-уровень">1 — Канальный уровень</a></h3>
<ul>
<li>описывает способ кодирования данных для передачи пакета данных на физическом уровне</li>
<li>канальный уровень иногда разделяют на 2 подуровня — LLC и MAC</li>
<li>канальный уровень описывает среду передачи данных</li>
<li>на канальном уровне рассматривают помехоустойчивое кодирование — позволяющие обнаруживать и исправлять ошибки в данных вследствие воздействия шумов и помех на канал связи</li>
</ul>
<h2 id="osi-vs-tcpip"><a class="header" href="#osi-vs-tcpip">OSI vs TCP/IP</a></h2>
<p><img src="network/../media/osi-tcp-ip.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comet"><a class="header" href="#comet">COMET</a></h1>
<p>COMET – общий термин, описывающий различные техники получения данных по инициативе сервера. Можно сказать, что AJAX – это «отправил запрос – получил результат», а COMET – это «непрерывный канал, по которому приходят данные».</p>
<p>Примеры COMET-приложений:</p>
<ul>
<li>Чат – человек сидит и смотрит, что пишут другие. При этом новые сообщения приходят «сами по себе», он не должен нажимать на кнопку для обновления окна чата.</li>
<li>Аукцион – человек смотрит на экран и видит, как обновляется текущая ставка за товар.</li>
<li>Интерфейс редактирования – когда один редактор начинает изменять документ, другие видят информацию об этом. Возможно и совместное редактирование, когда редакторы видят изменения друг друга.</li>
</ul>
<p>Ниже рассмотрены разные варианты реализации.</p>
<h2 id="Частые-опросы"><a class="header" href="#Частые-опросы">Частые опросы</a></h2>
<p>Первое решение, которое приходит в голову для непрерывного получения событий с сервера – это «частые опросы» (polling), т.е периодические запросы на сервер: «эй, я тут, изменилось ли что-нибудь?». Например, раз в 10 секунд.</p>
<p>В ответ сервер, во-первых, помечает у себя, что клиент онлайн, а во-вторых посылает сообщение, в котором в специальном формате содержится весь пакет событий, накопившихся к данному моменту.</p>
<p>При этом, однако, возможна задержка между появлением и получением данных, как раз в размере этих 10 секунд между запросами.</p>
<p>Другой минус – лишний входящий трафик на сервер. При каждом запросе браузер передает множество заголовков и в ответ получает, кроме данных, также заголовки. Для некоторых приложений трафик заголовков может в 10 и более раз превосходить трафик реальных данных.</p>
<h2 id="Длинные-опросы"><a class="header" href="#Длинные-опросы">Длинные опросы</a></h2>
<p>Длинные опросы – отличная альтернатива частым опросам. Они также удобны в реализации, и при этом сообщения доставляются без задержек.</p>
<p>Схема:</p>
<ol>
<li>Отправляется запрос на сервер.</li>
<li>Соединение не закрывается сервером, пока не появится сообщение.</li>
<li>Когда сообщение появилось – сервер отвечает на запрос, пересылая данные.</li>
<li>Браузер тут же делает новый запрос.</li>
</ol>
<p>Ситуация, когда браузер отправил запрос и держит соединение с сервером, ожидая ответа, является стандартной и прерывается только доставкой сообщений.</p>
<p>Схема коммуникации:</p>
<p><img src="https://learn.javascript.ru/article/xhr-longpoll/longpoll.png" alt="img" /></p>
<p>При этом если соединение рвётся само, например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.</p>
<h2 id="websocket"><a class="header" href="#websocket">WebSocket</a></h2>
<p>Протокол связи поверх <a href="https://ru.wikipedia.org/wiki/TCP">TCP</a>-соединения, предназначенный для асинхронного обмена сообщениями между браузером и веб-сервером в режиме реального времени.</p>
<p>Протокол <code>WebSocket</code> работает <em>над</em> TCP. Это означает, что при соединении браузер отправляет по HTTP специальные заголовки, спрашивая: «поддерживает ли сервер WebSocket?». Если сервер в ответных заголовках отвечает «да, поддерживаю», то дальше HTTP прекращается и общение идёт на специальном протоколе WebSocket, который уже не имеет с HTTP ничего общего.</p>
<h2 id="server-sent-events"><a class="header" href="#server-sent-events">Server Sent Events</a></h2>
<p>Современный стандарт <a href="https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface">Server-Sent Events</a> позволяет браузеру создавать специальный объект <code>EventSource</code>, который сам обеспечивает соединение с сервером, делает пересоединение в случае обрыва и генерирует события при поступлении данных. </p>
<p>Он, по дизайну, может меньше, чем WebSocket’ы. С другой стороны, Server Side Events проще в реализации, работают по обычному протоколу HTTP и сразу поддерживают ряд возможностей, которые для WebSocket ещё надо реализовать. Поэтому в тех случаях, когда нужна преимущественно односторонняя передача данных от сервера к браузеру, они могут быть удачным выбором.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-happens-when"><a class="header" href="#what-happens-when">What happens when...</a></h2>
<h2 id="1-Нажата-клавиша-g"><a class="header" href="#1-Нажата-клавиша-g">1. Нажата клавиша «g»</a></h2>
<p>Когда вы нажимаете клавишу «g», браузер получает событие и запускается механизм автоподстановки. В зависимости от алгоритма браузера и его режима (включена ли функция «инкогнито») в выпадающем окне под строкой URL пользователю будет предложено определённое количество вариантов для автоподстановки.</p>
<p>Большинство алгоритмов автоподстановки ранжируют рекомендации в зависимости от истории поиска и оставленных закладках. Некоторые браузеры (например, Rockmelt) даже предлагают профили друзей на Facebook. Когда пользователь планирует напечатать в адресной строке «google.com», ничего из вышеперечисленного не играет роли, но, тем не менее, выполнится большое количество кода, а рекомендации будут обновляться с каждой новой напечатанной буквой. Возможно, браузер предложит перейти на google.com, до того, как пользователь вобьёт адрес целиком.</p>
<h2 id="2-Клавиша-enter-нажата-до-конца"><a class="header" href="#2-Клавиша-enter-нажата-до-конца">2. Клавиша «enter» нажата до конца</a></h2>
<p>В качестве некой нулевой точки можно выбрать момент, когда клавиша Enter на клавиатуре нажата до конца и находится в нижнем положении. В этой точке замыкается электрическая цепь этой клавиши и небольшое количество тока отправляется по электросхеме клавиатуры, которая сканирует состояние каждого переключателя клавиши и конвертирует сигнал в целочисленный код клавиши (в данном случае — 13). Затем контроллер клавиатуры конвертирует код клавиши для передачи его компьютеру. Как правило, сейчас передача происходит через USB или Bluetooth, а раньше клавиатура подключалась к компьютеру с помощью коннекторов PS/2 или ADB.</p>
<p><em>В случае USB-клавиатуры:</em></p>
<ul>
<li>Для работы USB-контуру клавиатуры требуется 5 вольт питания, которые поступают через USB-контроллер на компьютере.</li>
<li>Сгенерированный код клавиши хранится в регистре внутренней памяти клавиатуры, который называется «конечной точкой» (endpoint).</li>
<li>USB-контроллер компьютера опрашивает эту конечную точку каждые 10 микросекунд и получает хранящийся там код клавиши.</li>
<li>Затем это значение поступает в USB SIE (Serial Interface Engine) для конвертации в один или более USB-пакетов, которые формируются по низкоуровневому протоколу USB.</li>
<li>Эти пакеты затем пересылаются с помощью различных электрических сигналов через D+ и D- контакты с максимальной скоростью 1,5 Мб/сек — поскольку HID-устройства (Human Interface Device) всегда были «низкоскоростными».</li>
<li>Этот последовательный сигнал далее декодируется в USB-контроллере компьютера и интерпретируется универсальным драйвером HID-устройства (клавиатуры). Затем значение кода клавиши передаётся на «железный» уровень абстракции операционной системы.</li>
</ul>
<p><em>В случае виртуальной клавиатуры (тачскрин):</em></p>
<ul>
<li>Когда пользователь прикладывает палец к современному ёмкостному тач-экрану, небольшое количество тока передаётся к пальцу. Это замыкает цепь через электростатическое поле проводящего слоя и создаёт падение напряжения в этой точке экрана. Экранный контроллер затем инициирует прерывание, сообщающее координату «клика».</li>
<li>Затем мобильная ОС оповещает текущее открытое приложение о событии клика в одном из GUI-элементов (в этом случае — кнопках виртуальной клавиатуры).</li>
<li>Виртуальная клавиатура вызывает программное прерывание для отправки сообщения «клавиша нажата» обратно в ОС.</li>
<li>Это прерывание оповещает текущее открытое приложение о возникновении события «нажатия клавиши».</li>
</ul>
<h4 id="21-Возникло-прерывание-не-для-usb-клавиатур"><a class="header" href="#21-Возникло-прерывание-не-для-usb-клавиатур">2.1 Возникло прерывание [не для USB-клавиатур]</a></h4>
<p>Клавиатура отправляет сигналы в свою «линию запросов прерываний» (IRQ), которая затем сопоставляется с «вектором прерывания» (целое число) контроллером прерываний. Процессор использует «таблицу дескрипторов прерываний» (IDT) для сопоставления векторов прерываний с функциями («обработчики прерываний») ядра. Когда появляется прерывание, процессор (CPU) обновляет IDT вектором прерывания и запускает соответствующий обработчик. Таким образом, в дело вступает ядро.</p>
<h4 id="22-На-windows-Сообщение-wm_keydown-отправлено-приложению"><a class="header" href="#22-На-windows-Сообщение-wm_keydown-отправлено-приложению">2.2 (На Windows) Сообщение <code>WM_KEYDOWN</code> отправлено приложению</a></h4>
<p>HID передаёт событие нажатой клавиши драйверу <code>KBDHID.sys</code>, который конвертирует его в <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BA%D0%B0%D0%BD-%D0%BA%D0%BE%D0%B4">скан-код</a> (scancode). В данном конкретном случае скан-код — <code>VK_RETURN</code> (<code>0x0D</code>). Драйвер <code>KDBHID.sys</code> связывается с драйвером <code>KBDCLASS.sys</code> (драйвер классов клавиатуры). Он отвечает за безопасную обработку всего ввода с клавиатуры. В дальнейшем этот драйвер вызывает <code>Win32K.sys</code> (после возможной передачи сообщения через установленные сторонние клавиатурные фильтры). Все это происходит в режиме ядра.</p>
<p>Win32K.sys определяет, какое окно активно в данный момент, с помощью функции <code>GetForegroundWindow()</code>. Этот API обеспечивает обработку окна адресной строки в браузере. Затем главный «насос сообщений» Windows вызывает <code>SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)</code>. <code>lParam</code> — это битовая маска, которая указывает на дальнейшую информацию о нажатии клавиши: счётчик повторов (в этом случае 0), актуальный скан-код (может зависеть от OEM, но <code>VK_RETURN</code> обычно не зависит от этого), информацию о том, были ли нажаты дополнительные клавиши (например, Alt, Shift, Ctrl — в нашем случае не были) и некоторые другие данные.</p>
<p>В API Windows есть функция <code>SendMessage</code>, которая помещает сообщение в очередь для конкретного обработчика окон (<code>hWnd</code>). После этого для обработки всех сообщений очереди вызывается главная функция обработки сообщений (<code>WindowProc</code>), присвоенная обработчику <code>hWnd</code>.</p>
<p>Окно (<code>hWnd</code>), активное в данный момент, представляет из себя контрол обработки и в этом случае у WindowsProc есть обработчик для сообщений <code>WM_KEYDOWN</code>. Этот код изучает третий параметр, который поступил в <code>SendMessage (wParam)</code> и, поскольку это <code>VK_RETURN</code>, понимает, что пользователь нажал клавишу ENTER.</p>
<h4 id="23-В-os-x-Событие-nsevent-keydown-отправлено-приложению"><a class="header" href="#23-В-os-x-Событие-nsevent-keydown-отправлено-приложению">2.3 (В OS X) Событие <code>NSEVent KeyDown</code> отправлено приложению</a></h4>
<p>Сигнал прерывания активирует событие прерывания в драйвере I/O Kit клавиатуры. Драйвер переводит сигнал в код клавиатуры, который затем передаётся процессу OS X под названием. В результате,  передаёт событие любому подходящему (активному или «слушающему») приложению через Mach-порт, в котором событие помещается в очередь. Затем события могут быть прочитаны из этой очереди потоками с достаточными привилегиями, чтобы вызывать функцию. Чаще всего это происходит и обрабатывается с помощью основного цикла через <code>NSEvent</code> в <code>NSEventype KeyDown</code>.</p>
<h4 id="24-В-gnulinux-Сервер-xorg-слушает-клавиатурные-коды"><a class="header" href="#24-В-gnulinux-Сервер-xorg-слушает-клавиатурные-коды">2.4 (В GNU/Linux) Сервер Xorg слушает клавиатурные коды</a></h4>
<p>В случае графического X server, для получения нажатия клавиши будет использован общий драйвер событий. Переназначение клавиатурных кодов скан-кодам осуществляется с помощью специальных правил и карт X Server. Когда скан-кода нажатой клавиши завершён, X server посылает символ в window manager (DWM, metacity, i3), который затем отправляет его в активное окно. Графический API окна, получившего символ, печатает соответствующий символ шрифта в нужном поле.</p>
<h2 id="3-Парсинг-url"><a class="header" href="#3-Парсинг-url">3. Парсинг URL</a></h2>
<p>Теперь у браузера есть следующая информация об URL:</p>
<pre><code>Protocol «HTTP» - Использовать «Hyper Text Transfer Protocol»
Resource «/» - Показать главную (индексную) страницу
</code></pre>
<h4 id="31-Это-url-или-поисковый-запрос"><a class="header" href="#31-Это-url-или-поисковый-запрос">3.1 Это URL или поисковый запрос?</a></h4>
<p>Когда пользователь не вводит протокол или доменное имя, то браузер «скармливает» то, что человек напечатал, поисковой машине, установленной по умолчанию. Часто к URL добавляется специальный текст, который позволяет поисковой машине понять, что информация передана из URL-строки определённого браузера.</p>
<h4 id="32-Список-проверки-hsts"><a class="header" href="#32-Список-проверки-hsts">3.2 Список проверки HSTS</a></h4>
<ul>
<li>Браузер проверяет список «предзагруженных HSTS (HTTP Strict Transport Security)». Это список сайтов, которые требуют, чтобы к ним обращались только по HTTPS.</li>
<li>Если нужный сайт есть в этом списке, то браузер отправляет ему запрос через HTTPS вместо HTTP. В противном случае начальный запрос посылается по HTTP. (При этом сайт может использовать политику HSTS, но не находиться в списке HSTS — в таком случае на первый запрос по HTTP будет отправлен ответ о том, что необходимо отправлять запросы по HTTPS. Однако это может сделать пользователя уязвимым к <a href="https://en.wikipedia.org/wiki/Moxie_Marlinspike#Notable_research">downgrade-атакам</a> — чтобы этого избежать, в браузеры и включают список HSTS).</li>
</ul>
<h4 id="33-Конвертация-не-ascii-unicode-символов-в-название-хоста"><a class="header" href="#33-Конвертация-не-ascii-unicode-символов-в-название-хоста">3.3 Конвертация не-ASCII Unicode символов в название хоста</a></h4>
<ul>
<li>Браузер проверяет имя хоста на наличие символов, отличных от <code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, <code>-</code>, или <code>.</code>.</li>
<li>В случае доменного имени google.com никаких проблем не будет, но если бы домен содержал не-ASCII символы, то браузер бы применил кодировку <a href="https://en.wikipedia.org/wiki/Punycode">Punycode</a> для этой части URL.</li>
</ul>
<h2 id="4-Определение-dns"><a class="header" href="#4-Определение-dns">4. Определение DNS</a></h2>
<ul>
<li>Браузер проверяет наличие домена в своём кэше.</li>
<li>Если домена там нет, то браузер вызывает библиотечную функцию <code>gethostbyname</code> (отличается в разных ОС) для поиска нужного адреса.</li>
<li>Прежде, чем искать домен по DNS <code>gethostbyname</code> пытается найти нужный адрес в файле <code>hosts</code> (его расположение отличается в разных ОС).</li>
<li>Если домен нигде не закэширован и отсутствует в файле <code>hosts</code>, <code>gethostbyname</code> отправляет запрос к сетевому DNS-серверу. Как правило, это локальный роутер или DNS-сервер интернет-провайдера.</li>
<li>Если DNS-сервер находится в той же подсети, то <a href="https://ru.wikipedia.org/wiki/ARP">ARP-запрос</a> отправляется этому серверу.</li>
<li>Если DNS-сервер находится в другой подсети, то ARP-запрос отправляется на IP-адрес шлюза по умолчанию (default gateway).</li>
</ul>
<h4 id="41-Процесс-отправки-arp-запроса"><a class="header" href="#41-Процесс-отправки-arp-запроса">4.1 Процесс отправки ARP-запроса</a></h4>
<p>Для того, чтобы отправить широковещательный ARP-запрос необходимо отыскать целевой IP-адрес, а также знать MAC-адрес интерфейса, который будет использоваться для отправки ARP-запроса.
<code>Target IP = MAC</code>
Если же записи в кэше нет:</p>
<ul>
<li>Проверяется таблица маршрутизации — это делается для того, чтобы узнать, есть ли искомый IP-адрес в какой-либо из подсетей локальной таблицы. Если он там, то запрос посылается с помощью интерфейса, связанного с этой подсетью. Если адрес в таблице не обнаружен, то используется интерфейс подсети шлюза по умолчанию.</li>
<li>Определяется MAC-адрес выбранного сетевого интерфейса.</li>
<li>Отправляется ARP-запрос (второй уровень стека):</li>
</ul>
<p>ARP-запрос:</p>
<pre><code>Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
</code></pre>
<p>В зависимости от того, какое «железо» расположено между компьютером и роутером (маршрутизатором):
Прямое соединение:</p>
<ul>
<li>Если компьютер подключён к сетевому концентратору, то этот хаб отправляет широковещательный ARP-запрос со всех своих портов. Если роутер подключён по тому же «проводу», то отправит ARP-ответ.</li>
</ul>
<p>Между ними концентратор (Хаб):</p>
<ul>
<li>Если компьютер подключён к сетевому концентратору, то этот хаб отправляет широковещательный ARP-запрос со всех своих портов. Если роутер подключён по тому же «проводу», то отправит ARP-ответ.</li>
</ul>
<p>Между ними коммутатор (свитч):</p>
<ul>
<li>Если компьютер соединён с сетевым коммутатором, то этот свитч проверит локальную CAM/MAC-таблицу, чтобы узнать, какой порт в ней имеет нужный MAC-адрес. Если нужного адреса в таблице нет, то он заново отправит широковещательный ARP-запрос по всем портам.</li>
<li>Если в таблице есть нужная запись, то свитч отправит ARP-запрос на порт с искомым MAC-адресом.</li>
<li>Если роутер «на одной линии» со свитчем, то он ответит (ARP Reply).</li>
</ul>
<p>ARP-ответ:</p>
<pre><code>Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
</code></pre>
<p>Теперь у сетевой библиотеки есть IP-адрес либо DNS-сервера, либо шлюза по умолчанию, который можно использовать для разрешения доменного имени:</p>
<ul>
<li>Порт 53 открывается для отправки UDP-запроса к DNS-серверу (если размер ответа слишком велик, будет использован TCP).</li>
<li>Если локальный или на стороне провайдера DNS-сервер «не знает» нужный адрес, то запрашивается рекурсивный поиск, который проходит по списку вышестоящих DNS-серверов, пока не будет найдена SOA-запись, а затем возвращается результат.</li>
</ul>
<h2 id="5-Открытие-сокета"><a class="header" href="#5-Открытие-сокета">5. Открытие сокета</a></h2>
<p>Когда браузер получает IP-адрес конечного сервера, то он берёт эту информацию и данные об используемом порте из URL (80 порт для HTTP, 443 для HTTPS) и осуществляет вызов функции <code>socket</code> системной библиотеки и запрашивает поток TCP сокета — <code>AF_INET</code> и <code>SOCK_STREAM</code>.</p>
<ul>
<li>Этот запрос сначала проходит через транспортный уровень, где собирается TCP-сегмент. В заголовок добавляется порт назначения, исходный порт выбирается из динамического пула ядра (<code>ip_local_port_range</code> в Linux).</li>
<li>Получившийся сегмент отправляется на сетевой уровень, на котором добавляется дополнительный IP-заголовок. Также включаются IP-адрес сервера назначения и адрес текущей машины — после этого пакет сформирован.</li>
<li>Пакет передаётся на канальный уровень. Добавляется заголовок кадра, включающий MAC-адрес сетевой карты (NIC) компьютера, а также MAC-адрес шлюза (локального роутера). Как и на предыдущих этапах, если ядру ничего не известно о MAC-адресе шлюза, то для его нахождения отправляется широковещательный ARP-запрос.</li>
</ul>
<p>На этой точке пакет готов к передаче через:</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/IEEE_802.3">Ethernet</a></li>
<li><a href="https://en.wikipedia.org/wiki/IEEE_802.11">WiFi</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cellular_data_communication_protocol">По сотовой связи</a></li>
</ul>
<p>В случае интернет-соединения большинства частных пользователей или небольших компаний пакет будет отправлен с компьютера, через локальную сеть, а затем через модем (), который транслирует цифровые единицы и нули в аналоговый сигнал, подходящий для передачи по телефонной линии, кабелю или беспроводным телефонным соединениям. На другой стороне соединения расположен другой модем, который конвертирует аналоговый сигнал в цифровые данные и передаёт их следующему, где происходит дальнейший анализ данных об отправителе и получателе.</p>
<p>В конечном итоге пакет доберётся до маршрутизатора, управляющего локальной подсетью. Затем он продолжит путешествовать от одного роутера к другому, пока не доберётся до сервера назначения. Каждый маршрутизатор на пути будет извлекать адрес назначения из IP-заголовка и отправлять пакет на следующий хоп. Значение поля TTL (time to live) в IP-заголовке будет каждый раз уменьшаться после прохождения каждого роутера. Если значение поля TTL достигнет нуля, пакет будет отброшен (это произойдёт также если у маршрутизатора не будет места в текущей очереди — например, из-за перегрузки сети).</p>
<p>Во время TCP-соединения происходит множество подобных запросов и ответов.</p>
<h4 id="51-Жизненный-цикл-tcp-соединения"><a class="header" href="#51-Жизненный-цикл-tcp-соединения">5.1 Жизненный цикл TCP-соединения</a></h4>
<p><strong>a. Клиент выбирает номер начальной последовательности (ISN) и отправляет пакет серверу с установленным битом SYN для открытия соединения.</strong></p>
<p><strong>b. Сервер получает пакет с битом SYN и, если готов к установлению соединения, то:</strong></p>
<ul>
<li>Увеличивает номер своей начальной последовательности;</li>
<li>Увеличивает номер подтверждения получения;</li>
<li>Устанавливает поле ACK.</li>
</ul>
<p><strong>c. Клиент подтверждает соединение путём отправки пакета:</strong></p>
<ul>
<li>Увеличивает номер своей начальной последовательности;</li>
<li>Увеличивает номер подтверждения получения;</li>
<li>Устанавливает поле ACK.</li>
</ul>
<p><strong>d. Данные передаются следующим образом:</strong></p>
<ul>
<li>Сторона, которая хочет закрыть соединение, отправляет пакет FIN;</li>
<li>Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;</li>
<li>Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.</li>
</ul>
<p><strong>e. Закрытие соединения:</strong></p>
<ul>
<li>Сторона, которая хочет закрыть соединение, отправляет пакет FIN;</li>
<li>Другая сторона подтверждает FIN (с помощью ACK) и отправляет собственный FIN-пакет;</li>
<li>Инициатор прекращения соединения подтверждает получение FIN отправкой собственного ACK.</li>
</ul>
<h2 id="6-tls-handshake"><a class="header" href="#6-tls-handshake">6. TLS handshake</a></h2>
<ul>
<li>Клиентский компьютер отправляет сообщение <code>ClientHello</code> серверу со своей версией протокола <a href="https://ru.wikipedia.org/wiki/TLS">TLS</a>, списком поддерживаемых алгоритмов шифрования и методов компрессии данных.</li>
<li>Сервер отвечает клиенту сообщением <code>ServerHello</code>, содержащим версию TLS, выбранный метод шифрования, выбранные методы компрессии и публичный сертификат сервиса, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использоваться клиентом для шифрования оставшейся части процедуры «рукопожатия» (<code>handshake</code>), пока не будет согласован симметричный ключ.</li>
<li>Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять, и клиент генерирует строку псевдослучайных байтов и шифрует её с помощью публичного ключа сервера. Эти случайные байты могут быть использованы для определения симметричного ключа.</li>
<li>Сервер расшифровывает случайные байты с помощью своего секретного ключа и использует эти байты для генерации своей копии симметричного мастер-ключа.</li>
<li>Клиент отправляет серверу сообщение <code>Finished</code>, шифруя хеш передачи с помощью симметричного ключа.</li>
<li>Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хеш, чтобы проверить, совпадёт ли он с собственным. Если совпадение обнаружено, сервер отправляет клиенту собственный ответ <code>Finished</code>, также зашифрованный симметричным ключом.</li>
<li>После этого TLS-сессия передаёт данные приложения (HTTP), зашифрованные с помощью подтверждённого симметричного ключа.</li>
</ul>
<h2 id="7-Протокол-http"><a class="header" href="#7-Протокол-http">7. Протокол HTTP</a></h2>
<p>Если используемый браузер был создан Google, то вместо отправки HTTP-запроса для получения страницы, он отправит запрос, чтобы попытаться «договориться» с сервером об «апгрейде» протокола с HTTP до <a href="https://ru.wikipedia.org/wiki/SPDY">SPDY</a> («спиди»).</p>
<p>Если клиент использует HTTP-протокол и не поддерживает SPDY, то отправляет серверу запрос следующей формы:</p>
<pre><code>GET / HTTP/1.1
Host: google.com
Connection: close
[другие заголовки]
</code></pre>
<p>где <code>[другие заголовки]</code> — это серия пар «ключ: значение», разбитых переносом строки. (Здесь предполагается, что в использованном браузере нет никаких ошибок, нарушающих спецификацию HTTP. Также предполагается, что браузер использует <code>HTTP/1.1</code>, в противном случае он может не включать заголовок <code>Host</code> в запрос и версия, отданная в ответ на GET-запрос может быть <code>HTTP/1.0</code> или <code>HTTP/0.9</code>).</p>
<p><code>HTTP/1.1</code> определяет опцию закрытия соединения («close») для отправителя — с её помощью происходит уведомление о закрытии соединения после завершения ответа. К примеру: </p>
<p><code>Connection: close</code></p>
<p>Приложения <code>HTTP/1.1</code>, которые не поддерживают постоянные соединения, обязаны включать опцию «close» в каждое сообщение.</p>
<p>После отправки запроса и заголовков, браузер отправляет серверу единичную пустую строку, сигнализируя о том, что содержимое сообщения закончилось.</p>
<p>Сервер отвечает специальным кодом, который обозначает статус запроса и включает ответ следующей формы:</p>
<pre><code>200 OK
[заголовки ответа]
</code></pre>
<p>После этого посылается пустая строка, а затем оставшийся контент HTML-страницы. Сервер может затем закрыть соединение, или, если того требуют отправленные клиентом заголовки, сохранять соединение открытым для его использования следующими запросами.</p>
<pre><code>304 Not Modified``[заголовки ответа]
</code></pre>
<p>и, соответственно, клиенту не посылается никакого контента, вместо этого браузер «достаёт» HTML из кэша.</p>
<p>После разбора HTML, браузер (и сервер) повторяет процесс загрузки для каждого ресурса (изображения, стили, скрипты, favicon.ico и так далее), на который ссылается HTML-страница, но при этом изменяется адрес каждого запроса c <code>GET / HTTP/1.1</code> на <code>GET /$(относительный URL ресурса www.google.com) HTTP/1.1</code>.</p>
<p>Если HTML ссылается на ресурс, размещённый на домене, отличном от google.com, то браузер возвращается к шагам, включающим разрешение доменного имени, а затем заново проходит процесс до текущего состояния, но уже для другого домена. Заголовок <code>Host</code> в запросе вместо google.com будет установлен на нужное доменное имя.</p>
<h4 id="71-Обработка-http-запросов-на-сервере"><a class="header" href="#71-Обработка-http-запросов-на-сервере">7.1 Обработка HTTP-запросов на сервере</a></h4>
<p><code>HTTPD</code> (HTTP Daemon) является одним из инструментов обработки запросов/ответов на стороне сервера. Наиболее популярные HTTPD-серверы это Apache или Nginx для Linux и IIS для Windows.</p>
<p>— HTTPD (HTTP Daemon) получает запрос.</p>
<p>— Сервер разбирает запрос по следующим параметрам:</p>
<ul>
<li>
<p>Метод HTTP-запроса (<code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code> или <code>DELETE</code>). В случае URL-адреса, который пользователь напечатал в строке браузера, мы имеем дело с GET-запросом.</p>
</li>
<li>
<p>Домен. В нашем случае — google.com.</p>
</li>
<li>
<p>Запрашиваемые пути/страницы, в нашем случае — <code>/</code> (нет запрошенных путей, <code>/</code> — это путь по умолчанию).</p>
</li>
<li>
<p>Сервер проверяет существование виртуального хоста, который соответствует google.com.</p>
</li>
<li>
<p>Сервер проверяет, что google.com может принимать GET-запросы.</p>
</li>
<li>
<p>Сервер проверяет, имеет ли клиент право использовать этот метод (на основе IP-адреса, аутентификации и прочее).</p>
</li>
<li>
<p>Если на сервере установлен модуль перезаписи (<code>mod_rewrite</code> для Apache или <code>URL Rewrite</code> для IIS), то он сопоставляет запрос с одним из сконфигурированных правил. Если находится совпадающее правило, то сервер использует его, чтобы переписать запрос.</p>
</li>
<li>
<p>Сервер находит контент, который соответствует запросу, в нашем случае он изучит индексный файл.</p>
</li>
<li>
<p>Далее сервер разбирает («парсит») файл с помощью обработчика. Если Google работает на PHP, то сервер использует PHP для интерпретации индексного файла и направляет результат клиенту.</p>
</li>
</ul>
<h2 id="8-За-кулисами-браузера"><a class="header" href="#8-За-кулисами-браузера">8. За кулисами браузера</a></h2>
<p>Задача браузера заключается в том, чтобы показывать пользователю выбранные им веб-ресурсы, запрашивая их с сервера и отображая в окне просмотра. Как правило, такими ресурсами являются HTML-документы, но это может быть и PDF, изображения или контент другого типа. Расположение ресурсов определяется с помощью URL.</p>
<p>Способ, который браузер использует для интерпретации и отображения HTML-файлов описан в спецификациях HTML и CSS. Эти документы разработаны и поддерживаются консорциумом W3C (World Wide Web Consortium), которая занимается стандартизацией веба.</p>
<p>Интерфейсы браузеров сильно похожи между собой. У них есть большое количество одинаковых элементов:</p>
<ul>
<li>Адресная строка, куда вставляются URL-адреса;</li>
<li>Кнопки возврата на предыдущую и следующую страницу;</li>
<li>Возможность создания закладок;</li>
<li>Кнопки обновления страницы (рефреш) и остановки загрузки текущих документов;</li>
<li>Кнопка «домой», возвращающая пользователя на домашнюю страницу.</li>
</ul>
<h3 id="Высокоуровневая-структура-браузера"><a class="header" href="#Высокоуровневая-структура-браузера">Высокоуровневая структура браузера</a></h3>
<p>Браузер включает следующие компоненты:</p>
<ul>
<li><strong>Пользовательский интерфейс</strong>: В него входит адресная строка, кнопки продвижения вперёд/назад, меню закладок и так далее. Сюда относятся все элементы, кроме окна, в котором собственно отображается веб-страница.</li>
<li><strong>«Движок» браузера</strong>: Распределяет действия между движком рендеринга и интерфейсом пользователя.</li>
<li><strong>«Движок» рендеринга</strong>: Отвечает за отображение запрашиваемого контента. К примеру, если запрашивается HTML, то «движок» разбирает код HTML и CSS, а затем отображает полученный контент на экране.</li>
<li><strong>Сетевая часть</strong>: с помощью сетевых функций браузер обрабатывает вызовы, вроде HTTP-запросов, с применением различных реализаций для разных платформ.</li>
<li><strong>Бэкенд интерфейса (UI)</strong>: Используется для отрисовки базовых виджетов, вроде комбо-боксов и окон.</li>
<li><strong>Интерпретатор JavaScript</strong>: Используется для парсинга и выполнения JavaScript-кода.</li>
<li><strong>Хранилище данных</strong>: Браузеру может понадобиться локально хранить некоторые данные (например, cookie). Кроме того, браузеры поддерживают различные механизмы хранения, такие как <code>localStorage</code>, <code>IndexedDB</code>, <code>WebSQL</code> и <code>FileSystem</code>.</li>
</ul>
<h2 id="9-Парсинг-html"><a class="header" href="#9-Парсинг-html">9. Парсинг HTML</a></h2>
<p>Движок рендеринга начинает получать содержимое запрашиваемого документа от сетевого механизма браузера. Как правило, контент поступает кусками по 8Кб. Главной задачей HTML-парсера является разбор разметки в специальное дерево.</p>
<p>Получающееся на выходе дерево («parse tree») — это дерево DOM-элементов и узлов атрибутов. DOM — сокращение от <code>Document Object Model</code>. Это модель объектного представления HTML-документа и интерфейс для взаимодействия HTML-элементов с «внешним миром» (например, JavaScript-кодом). Корнем дерева является объект «Документ».</p>
<h3 id="Алгоритм-разбора"><a class="header" href="#Алгоритм-разбора">Алгоритм разбора</a></h3>
<p>HTML-нельзя «распарсить» с помощью обычных анализаторов (нисходящих или восходящих). Тому есть несколько причин:</p>
<ul>
<li>Прощающая почти что угодно природа языка;</li>
<li>Тот факт, что браузеры обладают известной толерантностью к ошибкам и поддерживают популярные ошибки в HTML.</li>
<li>Процесс парсинга может заходить в тупик. В других языках код, который требуется разобрать, не меняется в процессе анализа, в то время как в HTML с помощью динамического кода (например, скриптовые элементы, содержащие вызовы <code>document.write()</code>) могут добавляться дополнительные токены, в результате чего сам процесс парсинга модифицирует вывод.</li>
</ul>
<p>Невозможность использования привычных технологий парсинга приводит к тому, что разработчики браузеров реализуют собственные механизмы разбора HTML. Алгоритм парсинга подробно описан в <a href="http://www.w3.org/TR/html5/">спецификации HTML5</a>.</p>
<p>Алгоритм состоит из двух этапов: токенизации и создания дерева.</p>
<h4 id="Действия-после-завершения-парсинга"><a class="header" href="#Действия-после-завершения-парсинга">Действия после завершения парсинга</a></h4>
<p>После этого браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).</p>
<p>На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть исполнены после парсинга. После этого статус документа устанавливается в состояние «<code>complete</code>» и инициируется событие загрузки («<code>load</code>»).</p>
<p>Важный момент: ошибки <code>«Invalid Syntax»</code> при разборе не может быть, поскольку браузеры исправляют любой «невалидный» контент и продолжают работу.</p>
<h2 id="10-Интерпретация-css"><a class="header" href="#10-Интерпретация-css">10. Интерпретация CSS</a></h2>
<ul>
<li>Во время разбора браузер парсит CSS-файлы, содержимое тегов <code>&lt;style&gt;</code> и атрибутов «style» c помощью «<a href="http://www.w3.org/TR/CSS2/grammar.html">лексической и синтаксической грамматики CSS</a>».</li>
<li>Каждый CSS-файл разбирается в объект <code>StyleSheet</code>, каждый из таких объектов содержит правила CSS с селекторами и объектами в соответствии с грамматикой CSS.</li>
<li>Парсер CSS может быть как восходящим, так и нисходящим.</li>
</ul>
<h2 id="11-Рендеринг-страниц"><a class="header" href="#11-Рендеринг-страниц">11. Рендеринг страниц</a></h2>
<ul>
<li>Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).</li>
<li>Вычисляется предпочтительная ширина каждого узла в нижней части дерева — для этого суммируются значения предпочтительной ширины дочерних узлов, а также горизонтальные поля, границы и отступы узлов.</li>
<li>Вычисляется реальная ширина каждого узла сверху-вниз (доступная ширина каждого узла выделяется его потомкам).</li>
<li>Вычисляется высота каждого узла снизу-вверх — для этого применяется перенос текста и суммируются значения полей, высоты, отступов и границ потомков.</li>
<li>Вычисляются координаты каждого узла (с использованием ранее полученной информации).</li>
<li>Если элементы плавающие или спозиционированы абсолютно, или относительно, предпринимаются более сложные действия. Более подробно они описаны <a href="http://dev.w3.org/csswg/css2/">здесь</a> и <a href="http://www.w3.org/Style/CSS/current-work">здесь</a>.</li>
<li>Создаются слои для описания того, какие части страницы можно анимировать без необходимости повторного растрирования. Каждый объект (фрейма или рендера) присваивается слою.</li>
<li>Для каждого слоя на странице выделяются текстуры.</li>
<li>Объекты (рендеры/фреймы) каждого слоя перебираются и для соответствующих слоёв выполняются команды отрисовки. Растрирование может осуществляться процессором или возможна отрисовка на графическом процессоре (GPU) через D2D/SkiaGL.</li>
<li>Все вышеперечисленные шаги могут требовать повторного использования значений, сохранённых с последнего рендеринга страницы, такая инкрементальная работа требует меньше затрат.</li>
<li>Слои страницы отправляются процессу-компоновщику, где они комбинируются со слоями для другого видимого контента (интерфейс браузера, iframe-элементы, addon-панели).</li>
<li>Вычисляются финальные позиции слоёв и через Direct3D/OpenGL отдаются композитные команды. Командные буферы GPU освобождаются для асинхронного рендеринга и фрейм отправляется для отображения на экран.</li>
</ul>
<h2 id="12-Рендеринг-gpu"><a class="header" href="#12-Рендеринг-gpu">12. Рендеринг GPU</a></h2>
<ul>
<li>Во время процесса рендеринга уровни графических вычислений могут использовать процессор компьютера или графический процессор (GPU).</li>
<li>Во втором случае уровни графического программного обеспечения делят задачу на множество частей, что позволяет использовать параллелизм GPU для вычисления плавающей точки, которое требуется для процесса рендеринга.</li>
</ul>
<h2 id="13-Вызванное-пользователем-и-пост-рендеринговое-исполнение"><a class="header" href="#13-Вызванное-пользователем-и-пост-рендеринговое-исполнение">13. Вызванное пользователем и пост-рендеринговое исполнение</a></h2>
<p>После завершения рендеринга, браузер исполняет JavaScript-код в результате срабатывания некоего часового механизма (так работают дудлы на странице Google) или в результате действий пользователя (ввод поискового запроса в строку и получение рекомендаций в ответ). Также могут срабатывать плагины вроде Flash или Java (но не в рассматриваемом примере с домашней страницей Google). Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт к следующему этапу рендеринга и отрисовки.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/company/htmlacademy/blog/254825/">Что на самом деле происходит, когда пользователь вбивает в браузер адрес google.com</a></li>
<li><a href="https://github.com/alex/what-happens-when">What happens when</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Операционные-системытеория"><a class="header" href="#Операционные-системытеория">Операционные системы(теория)</a></h1>
<h2 id="Многозадачность-и-параллельные-вычисления"><a class="header" href="#Многозадачность-и-параллельные-вычисления">Многозадачность и параллельные вычисления</a></h2>
<p><strong>Многозадачность</strong>(multitasking) — свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной)) обработки нескольких задач. Истинная многозадачность операционной системы возможна только в распределённых вычислительных системах.</p>
<p>Есть несколько разных понятий, связанных с областью параллельных вычислений.</p>
<h3 id="Конкурентность-concurrency"><a class="header" href="#Конкурентность-concurrency">Конкурентность (concurrency)</a></h3>
<p>Конкурентность (concurrency) - это наиболее общий термин, который говорит, что одновременно выполняется более одной задачи. Например, вы можете одновременно смотреть телевизор и комментить фоточки в фейсбуке.  К сожалению, вменяемого русскоязычного термина я не знаю. Википедия говорит, что concurrent computing - это параллельные вычисления, но как тогда будет parallel computing по русски?</p>
<p>Конкурентное исполнение - это самый общий термин, который не говорит о том, каким образом эта конкурентность будет получена: путем приостановки некоторых вычислительных элементов и их переключение на другую задачу, путем действительно одновременного исполнения, путем делегации работы другим устройствам или еще как-то. Это не важно.</p>
<p><em>Конкурентное исполнение</em> говорит о том, что за определенный промежуток времени будет решена более, чем одна задача. Точка.</p>
<h3 id="Параллельное-исполнение"><a class="header" href="#Параллельное-исполнение">Параллельное исполнение</a></h3>
<p>Параллельное исполнение (parallel computing) подразумевает наличие более одного вычислительного устройства (например, процессора), которые будут <em>одновременно</em> выполнять несколько задач.</p>
<p>Параллельное исполнение - это строгое подмножество конкурентного исполнения. Это значит, что на компьютере с одним процессором параллельное программирование - невозможно;)</p>
<h3 id="Многопоточность"><a class="header" href="#Многопоточность">Многопоточность</a></h3>
<p>Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции &quot;рабочего потока&quot; (worker thread).</p>
<p>Потоки &quot;абстрагируют&quot; от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу &quot;параллельно&quot;. Операционная система, среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).</p>
<h3 id="Асинхронное-исполнение"><a class="header" href="#Асинхронное-исполнение">Асинхронное исполнение</a></h3>
<p>Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за пределами текущего вычислительного устройства.</p>
<p>Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.</p>
<h3 id="cpu-bound-и-io-bound-операции"><a class="header" href="#cpu-bound-и-io-bound-операции">CPU-bound и IO-Bound операции</a></h3>
<p>Еще один важный момент, с точки зрения разработчика - разница между CPU-bound и IO-bound операциями. CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне текущей железки.</p>
<p>Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.</p>
<p><em>Дополнительно</em>:</p>
<ul>
<li><a href="https://ru.stackoverflow.com/questions/445768/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%B5-vs-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Многопоточное vs асинхронное программирование</a></li>
</ul>
<h2 id="Процессы-и-потоки"><a class="header" href="#Процессы-и-потоки">Процессы и потоки</a></h2>
<p>Существует 2 типа многозадачности:</p>
<ul>
<li><em>Процессная многозадачность</em> (основанная на процессах — одновременно выполняющихся программах). Здесь программа — наименьший элемент управляемого кода, которым может управлять планировщик операционной системы. Более известна большинству пользователей (работа в текстовом редакторе и прослушивание музыки).</li>
<li><em>Поточная многозадачность</em> (основанная на потоках). Наименьший элемент управляемого кода — поток (одна программа может выполнять 2 и более задачи одновременно).</li>
</ul>
<p><strong>Процесс</strong> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>
<p><strong>Поток</strong> использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.</p>
<p>В Linux (в ядре) понятие «threads» отсутствует. С точки зрения ядра все потоки — это полноценные, отдельные, процессы (просто с общим адресным пространством)</p>
<p>Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса. Программный поток (thread): в русскоязычной литературе часто употребляют термин «нить» (в программистском жаргоне — «нитка»).</p>
<p>Рассказ о жизни процессов естественно начать с самого начала - с их появления на свет. Так вот, процессы размножаются... почкованием: системный вызов Linux, создающий новый процесс, называется <strong>clone</strong>, а дочерний процесс представляет собой почти точную копию родительского. Только далее он выполняет назначенную ему функцию, а исходный процесс - то, что написано в программе после вызова clone. Потом отличий может стать больше, так что пути-дороги процессов способны разойтись достаточно далеко. Но если нам нужно этому воспрепятствовать, вызов clone позволит задать флаги, указывающие, что порожденный процесс будет иметь со своим предком общие моменты.</p>
<p>Если родительский процесс по какой-то причине завершится раньше дочернего, последний становится <strong>сиротой (orphaned process)</strong>. &quot;Сироты&quot; автоматически &quot;усыновляются&quot; программой init, выполняющейся в процессе с номером 1, которая и принимает сигнал об их завершении.</p>
<p>Если же потомок уже завершил работу, а предок не готов принять от системы сигнал об этом событии, то потомок не исчезает полностью, а превращается в <strong>зомби (zombie)</strong>; в поле Stat такие процессы помечаются буквой Z. Зомби не занимает процессорного времени, но строка в таблице процессов остается, и соответствующие структуры ядра не освобождаются. После завершения родительского процесса &quot;осиротевший&quot; зомби на короткое время также становится потомком init, после чего уже &quot;окончательно умирает&quot;.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="http://citforum.ru/operating_systems/articles/process.shtml">Процессы, задачи, потоки и нити</a></li>
</ul>
<h2 id="Асинхронность"><a class="header" href="#Асинхронность">Асинхронность</a></h2>
<ul>
<li><strong>Асинхронный</strong> буквально означает “не синхронный”. Например, отправка email асинхронная, потому что отправитель не ожидает получить ответ сразу же. В программировании “асинхронным” называют код, в котором компоненты посылают друг другу сообщения, не ожидая немедленного ответа.</li>
<li><strong>Неблокирующий</strong> - термин, чаще всего касающийся ввода-вывода. Он означает, что при вызове “неблокирующего” системного API управление сразу же будет возвращено программе, и она продолжит использовать свой квант процессорного времени. Обычные, простые в использовании системные вызовы блокирующие: они усыпляют вызывающий поток до тех пор, пока данные для ответа не будут готовы.</li>
<li><strong>Событийный</strong> означает, что компонент программы обрабатывает очередь событий с помощью цикла, а тем временем кто-либо добавляет события в очередь, формируя входные данные компонента, и забирает у него выходные данные.</li>
</ul>
<p>Синхронные операции — операции, при которых мы получаем результат в результате блокирования <a href="https://habrahabr.ru/post/318374/#potoki">потока</a> выполнения. Для простых вычислительных операций (сложение/умножение чисел) — это единственный вариант их совершения, для операций ввода/вывода — один из, при этом мы говорим, к примеру, <em>«попытайся прочитать из файла что-нибудь за 100мс»</em>, и если для чтения ничего нет — поток выполнения будет заблокирован на эти 100мс.</p>
<p>В некоторых случаях это допустимо (например, если мы делаем простое консольное приложение, либо какую-либо утилиту, цель которой — отработать и всё), но в некоторых — нет. К примеру, если мы так застрянем в потоке, в котором обрабатывается UI — наше приложение зависнет. За примерами далеко ходить не нужно — если javascript на сайте сделает <code>while(true);</code>, то перестанут вызываться какие-либо другие обработчики событий страницы и её придётся закрыть. Те же дела, если начать что-нибудь вычислять под Android'ом в обработчиках UI-событий (код которых вызывается в UI-потоке), это приведёт к появлению окна «приложение не отвечает, закрыть?» (подобные окна вызываются по <a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog-таймеру</a>, который сбрасывается, когда выполнение возвращается обратно к системе UI).</p>
<p>Асинхронные операции — операции, при которых мы <strong>просим совершить</strong> некоторую операцию и можем каким-либо образом отслеживать процесс/результат её выполнения. Когда она будет выполнена — неизвестно, но мы можем продолжить заниматься другими делами.</p>
<p>Блокировки - это проблема для всех программ, требующих конкурентного выполнения, поскольку заблокированные потоки процесса засыпают и не получают процессорное время. Существует два различных, но взаимодополняющих способа устранить блокировки:</p>
<ul>
<li>неблокирующий режим ввода-вывода</li>
<li>мультиплексирование с помощью системного API, такого как <code>select</code> либо <code>epoll</code></li>
</ul>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://ps-group.github.io/os/nonblocking_io_posix">Асинхронный ввод-вывод средствами POSIX</a></li>
</ul>
<h3 id="event-loop"><a class="header" href="#event-loop">Event loop</a></h3>
<p>Бесконечный цикл, который берёт <strong>события</strong> из очереди и как-то их обрабатывает. А в некоторых промежутках — смотрит, не произошло ли каких-нибудь <strong>IO-событий</strong>, либо не просрочились ли какие-либо <strong>таймеры</strong> — тогда добавляет в очередь событие об этом, чтобы потом обработать.</p>
<h2 id="race-condition"><a class="header" href="#race-condition">Race condition</a></h2>
<p><strong>Состояние гонки (race condition)</strong>, также конкуренция — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. Своё название ошибка получила от похожей ошибки проектирования электронных схем (см. Гонки сигналов).</p>
<p>Термин состояние гонки относится к инженерному жаргону и появился вследствие неаккуратного дословного перевода английского эквивалента. В более строгой академической среде принято использовать термин неопределённость параллелизма.</p>
<p>Состояние гонки — «плавающая» ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и «пропадающая» при попытке её локализовать.</p>
<h2 id="Вытесняющая-и-кооперативная-многозадачность"><a class="header" href="#Вытесняющая-и-кооперативная-многозадачность">Вытесняющая и кооперативная многозадачность</a></h2>
<h3 id="Совместная-или-кооперативная-многозадачность"><a class="header" href="#Совместная-или-кооперативная-многозадачность">Совместная или кооперативная многозадачность</a></h3>
<p>Тип многозадачности, при котором следующая задача выполняется только после того, как текущая задача явно объявит себя готовой отдать процессорное время другим задачам. Как частный случай такое объявление подразумевается при попытке захвата уже занятого объекта <a href="https://ru.wikipedia.org/wiki/%D0%9C%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81">мьютекс</a> (ядро Linux), а также при ожидании поступления следующего сообщения от подсистемы пользовательского интерфейса (Windows версий до <a href="https://ru.wikipedia.org/wiki/Windows_3.x">3.x</a> включительно, а также 16-битные приложения в <a href="https://ru.wikipedia.org/wiki/Windows_9x">Windows 9x</a>).</p>
<p>Кооперативную многозадачность можно назвать многозадачностью «второй ступени», поскольку она использует более передовые методы, чем простое переключение задач, реализованное многими известными программами (например, <a href="https://ru.wikipedia.org/wiki/DOS_Shell">DOS Shell</a> из <a href="https://ru.wikipedia.org/wiki/MS-DOS">MS-DOS</a> 5.0). При простом переключении активная программа получает все процессорное время, а фоновые приложения полностью замораживаются. При кооперативной многозадачности приложение может захватить фактически столько процессорного времени, сколько оно считает нужным. Все приложения делят процессорное время, периодически передавая управление следующей задаче.</p>
<p>Преимущества кооперативной многозадачности: отсутствие необходимости защищать все разделяемые структуры данных объектами типа критических секций и мьютексов, что упрощает программирование, особенно перенос кода из однозадачных сред в многозадачные.</p>
<p>Недостатки: неспособность всех приложений работать в случае ошибки в одном из них, приводящей к отсутствию вызова операции «отдать процессорное время». Крайне затрудненная возможность реализации многозадачной архитектуры ввода-вывода в ядре ОС, позволяющей процессору исполнять одну задачу, в то время как другая задача инициировала операцию ввода-вывода и ждет её завершения.</p>
<h3 id="Вытесняющая-или-приоритетная-многозадачность-режим-реального-времени"><a class="header" href="#Вытесняющая-или-приоритетная-многозадачность-режим-реального-времени">Вытесняющая, или приоритетная, многозадачность (<a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8">режим реального времени</a>)</a></h3>
<p>Вид многозадачности, в котором <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0">операционная система</a> сама передает управление от одной выполняемой программы другой в случае завершения операций ввода-вывода, возникновения событий в аппаратуре компьютера, истечения таймеров и квантов времени, или же поступлений тех или иных сигналов от одной программы к другой. В этом виде многозадачности процессор может быть переключен с исполнения одной программы на исполнение другой без всякого пожелания первой программы и буквально между любыми двумя инструкциями в её коде. Распределение процессорного времени осуществляется планировщиком процессов. К тому же каждой задаче может быть назначен пользователем или самой операционной системой определенный приоритет, что обеспечивает гибкое управление распределением процессорного времени между задачами (например, можно снизить приоритет ресурсоёмкой программе, снизив тем самым скорость её работы, но повысив производительность фоновых процессов). Этот вид многозадачности обеспечивает более быстрый отклик на действия пользователя.</p>
<p>Преимущества:</p>
<ul>
<li>возможность полной реализации многозадачного ввода-вывода в ядре ОС, когда ожидание завершения ввода-вывода одной программой позволяет процессору тем временем исполнять другую программу;</li>
<li>cильное повышение надежности системы в целом, в сочетании с использованием защиты памяти — идеал в виде «ни одна программа пользовательского режима не может нарушить работу ОС в целом» становится достижимым хотя бы теоретически, вне вытесняющей многозадачности он не достижим даже в теории.</li>
<li>возможность полного использования многопроцессорных и многоядерных систем.</li>
</ul>
<p>Недостатки:</p>
<ul>
<li>необходимость особой дисциплины при написании кода, особые требования к его <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B5%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%B1%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C">реентерабельности</a>, к защите всех разделяемых и глобальных данных объектами типа критических секций и мьютексов.</li>
</ul>
<h2 id="Системный-вызов"><a class="header" href="#Системный-вызов">Системный вызов</a></h2>
<p><strong>Системный вызов(system call)</strong> — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.</p>
<p>Современные операционные системы (ОС) предусматривают разделение времени между выполняющимися вычислительными процессами(многозадачность) и разделение полномочий, препятствующее обращению исполняемых программ к данным других программ и оборудованию. Ядро ОС исполняется в привилегированном режиме работы процессора. Для выполнения межпроцессорной операции или операции, требующей доступа к оборудованию, программа обращается к ядру, которое, в зависимости от полномочий вызывающего процесса, исполняет либо отказывает в исполнении такого вызова.</p>
<p>С точки зрения программиста, системный вызов обычно выглядит как вызов подпрограммы или функции из системной библиотеки. Однако системный вызов, как частный случай вызова такой функции или подпрограммы, следует отличать от более общего обращения к системной библиотеке, поскольку последнее может и не требовать выполнения привилегированных операций.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Системной-администрирование"><a class="header" href="#Системной-администрирование">Системной администрирование</a></h1>
<p>Системное администрирование - обеспечение штатной работы парка компьютерной техники, сети и программного обеспечения. Зачастую системному администратору вменяется обеспечение информационной безопасности в организации. Разговорное название — сисадми́н (англ. sysadmin).</p>
<ul>
<li><a href="devops/linux.html">Linux</a></li>
<li><a href="devops/virtualization/README.html">Основы виртуализации</a>
<ul>
<li><a href="devops/virtualization/docker.html">Docker</a></li>
<li><a href="devops/virtualization/kubernetes.html">Kubernetes</a></li>
</ul>
</li>
<li><a href="devops/deployment.html">Deployment</a></li>
<li><a href="devops/monitoring.html">Мониторинг</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Основы-linux"><a class="header" href="#Основы-linux">Основы Linux</a></h1>
<h2 id="Команды-Управление-файлами"><a class="header" href="#Команды-Управление-файлами">Команды Управление файлами</a></h2>
<ul>
<li><strong>ls</strong> - Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах передать путь, то она перечислит содержимое того каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в виде списка с более подробной информацией, а вторая включает показ скрытых файлов.</li>
<li><strong>cat</strong> - Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов, команда склеит их. Также можно перенаправить вывод в еще один файл, с помощью символа '&gt;'. Если нужно вывести только определенное количество строк используйте опцию -n (Number).</li>
<li><strong>cd</strong> - Позволяет перейти из текущего каталога, в указанный. Если запустить без параметров - возвращает в домашний каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тире (cd -) возвращает к предыдущему каталогу. </li>
<li><strong>pwd</strong> - Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую информацию, а также особенно полезно в Bash программировании, для получения ссылки на каталог в котором выполняется скрипт.</li>
<li><strong>mkdir</strong> - Создание новых каталогов. Наиболее удобная опция - p (Parents), позволяет создать всю структуру подкаталогов одной командой, даже если они еще не существуют.</li>
<li><strong>file</strong> - Показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать. Поэтому пользователю иногда трудно определить, что за файл перед ним. </li>
<li><strong>cp</strong> - Копирование файлов и каталогов. Она не копирует каталоги рекурсивно по умолчанию, поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает режим сохранения атрибутов, владельца и временного штампа, в дополнение к рекурсивному копированию.</li>
<li><strong>mv</strong> - Перемещение или переименование файлов и каталогов. Примечательно, что переименование и перемещение - это одна и та же операция. Переименование - это перемещение файла в ту же папку с другим именем.</li>
<li><strong>rm</strong> - Удаляет файлы и папки. Очень полезная команда Linux, с помощью нее вы можете убрать весь беспорядок. Однако будьте осторожны при ее использовании. Хоть и для того чтобы повредить систему вам нужно серьезно постараться, вы можете удалить собственные важные файлы. Rm не удаляет файлы в корзину, из которой потом все можно будет восстановить. Так что будьте осторожны, чтобы потом не говорили: &quot;rm съела мою курсовую&quot;. Все действия необратимы. Если нужно рекурсивное удаление, используйте опцию -r.</li>
<li><strong>ln</strong> - Создает жесткие или символические ссылки на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определенному файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жесткие ссылки в отличие от символических указывают на физический адрес области диска, где хранятся данные файла.</li>
<li><strong>chmod</strong></li>
</ul>
<p><code>chmod опции права /путь/к/файлу</code></p>
<p>Изменяет права доступа к файлу. </p>
<p>Есть три основных вида прав:</p>
<ul>
<li><strong>r</strong> - чтение;</li>
<li><strong>w</strong> - запись;</li>
<li><strong>x</strong> - выполнение;</li>
<li><strong>s</strong> - выполнение от имени суперпользователя (дополнительный);</li>
</ul>
<p>Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:</p>
<ul>
<li><strong>u</strong> - владелец файла;</li>
<li><strong>g</strong> - группа файла;</li>
<li><strong>o</strong> - все остальные пользователи;</li>
</ul>
<p>Наиболее популярен восьмеричный формат задания прав:</p>
<ul>
<li><strong>0</strong> - никаких прав;</li>
<li><strong>1</strong> - <strong>только выполнение</strong>;</li>
<li><strong>2</strong> - <strong>только запись</strong>;</li>
<li><strong>3</strong> - выполнение и запись;</li>
<li><strong>4</strong> -  <strong>только чтение</strong>;</li>
<li><strong>5</strong> - чтение и выполнение;</li>
<li><strong>6</strong> - чтение и запись;</li>
<li><strong>7</strong> - чтение запись и выполнение.</li>
</ul>
<p>Например:</p>
<ul>
<li>
<p><strong>744</strong> - разрешить все для владельца, а остальным только чтение;</p>
</li>
<li>
<p><strong>755</strong> - все для владельца, остальным только чтение и выполнение;</p>
</li>
<li>
<p><strong>764</strong> - все для владельца, чтение и запись для группы, и только чтение для остальных;</p>
</li>
<li>
<p><strong>777</strong> - всем разрешено все.</p>
</li>
<li>
<p><strong>chown</strong> - Изменяющая владельца и/или группу для указанных файлов. Только суперпользователь может изменять владельцев. Для рекурсивного изменения используйте опцию -R. Поменять владельца для <code>strace.log</code> в 'rob' и идентификатор группы в developers: <code>chown rob:developers strace.log</code></p>
</li>
<li>
<p><strong>find</strong> - Поиск в файловой системе, файлов и папок. Это очень гибкая и мощная команда Linux не только из-за своих возможностей поиска, но и благодаря возможности выполнять произвольные команды для найденных файлов.</p>
</li>
</ul>
<p><strong>locate</strong></p>
<p>В отличие от find ведет поиск в базе данных updatedb, для шаблонов имен файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадежен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.</p>
<p><strong>du</strong></p>
<p>(disk usage) Показать размер файла или каталога. Одни из наиболее полезных опций - h (Human), которая преобразует размеры файлов в легко читаемый формат, -s (Summarize) выводит минимум данных и -d (Depth) - устанавливает глубину рекурсии по каталогам. </p>
<p><code>du [опции][каталоги_или_файлы]</code></p>
<p>Опции:</p>
<ul>
<li><code>–b</code> выводит информацию в байтах(а не в килобайтах).</li>
<li><code>–c</code> выводит итоговую информацию об использовании дисковой памяти.</li>
<li><code>–k</code> выводит информацию в килобайтах(по умолчанию).</li>
<li><code>–s</code> выводит итоговую информацию об использовании дискового пространства без информации о каталогах.</li>
<li><code>-h</code> вывести информацию в человекочитаемом виде.</li>
<li><code>-d</code> (Depth) - устанавливает глубину рекурсии по каталогам. </li>
</ul>
<p><strong>df</strong></p>
<p><strong>df</strong>(disk free) - позволяет узнать размер свободного и занятого пространства во всех смонтированных файловых системах.</p>
<p><code>df [опции][файловая_система]</code></p>
<p>Опции:</p>
<ul>
<li><code>-a</code> выводит информацию обо всех файловых системах.</li>
<li><code>-h</code> выводит размеры в удобном для человека виде (мегабайты, килобайты, гигабайты и т.д.)</li>
<li><code>-T</code> показать тип файловой системы.</li>
<li><code>-t</code> выводит информацию только об указанных типах файловых систем.</li>
</ul>
<p><strong>dd</strong></p>
<p>Как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень понятное описание, но это все что делает dd. Вы передаете ей файл-источник и пункт назначения, и пару дополнительных опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жесткий диск нулями из /dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.</p>
<p><strong>mount /umount</strong></p>
<p>Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать все, от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.</p>
<h2 id="Работа-с-текстом"><a class="header" href="#Работа-с-текстом">Работа с текстом</a></h2>
<p><strong>more/less</strong></p>
<p>Это две простенькие команды терминала, для просмотра длинных текстов, которые не вмещаются на одном экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла и вашему эмулятору терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет причин.</p>
<p><strong>head/tail</strong></p>
<p>Еще одна пара, но здесь у каждой команды своя область применения. Head выводит несколько первых строк из файла (голова), а tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с помощью опции -n. Еще один полезный параметр -f. Это сокращение от Follow (следовать), утилита постоянно выводит изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того чтобы постоянно открывать и закрывать его используйте tail -nf.</p>
<p><strong>grep</strong></p>
<p>Grep, как и другие инструменты Linux делает одно действие, но делает его хорошо. Она ищет текст по шаблону. По умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой, или регулярным выражением. Она может вывести как совпадающие, так и несовпадающие строки и их контекст. Каждый раз, когда вы выполняете команду, которая выдает очень много информации, не нужно анализировать все вручную, пусть grep делает свою магию.</p>
<p><strong>sort</strong></p>
<p>Сортировка строк текста по различным критериям. Наиболее полезные: -n (Numeric) - по числовому значению, и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите отсортировать файлы по размеру, просто соедините эти команды.</p>
<p><strong>wc</strong></p>
<p>wc(word count) -Утилита командной строки Linux для подсчета количества слов, строк, байт и символов.</p>
<pre><code class="language-bash"> wc -l &lt;filename&gt; вывести количество строк
 wc -c &lt;filename&gt; вывести количество байт
 wc -m &lt;filename&gt; вывести количество символов
 wc -L &lt;filename&gt; вывести длину самой длинной строки
 wc -w &lt;filename&gt; вывести количество слов
</code></pre>
<p><strong>uniq</strong></p>
<p>Утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в отсортированном файле. Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода. Если выходной файл не задан, запись производится в стандартный вывод. Вторая и последующие копии повторяющихся соседних строк не записываются. Повторяющиеся входные строки не распознаются, если они не следуют строго друг за другом, поэтому может потребоваться предварительная сортировка файлов.</p>
<pre><code>uniq [-c | -d | -u] [-i] [-f число_полей] [-s | -w число_символов] [входной_файл [выходной_файл]]
</code></pre>
<p>Опции:</p>
<ul>
<li><code>-u</code> Выводить только те строки, которые не повторяются на входе.</li>
<li><code>-d</code> Выводить только те строки, которые повторяются на входе.</li>
<li><code>-c</code> Перед каждой строкой выводить число повторений этой строки на входе и один пробел.</li>
<li><code>-i</code> Сравнивать строки без учёта регистра.</li>
<li><code>-s число_символов</code> Определяет количество символов, начиная с начала строки, игнорируемых при сравнении. Все остальные символы сравниваются. Символы нумеруются начиная с единицы.</li>
<li><code>-w число символов</code> Определяет количество символов, начиная с начала строки, участвующих в сравнении. Все остальные символы игнорируются.</li>
<li><code>-f число_полей</code>  Игнорировать при сравнении первые число_полей полей каждой строки ввода. Полем является строка непробельных символов, отделённая от соседних полей пробельными символами. Поля нумеруются начиная с единицы.</li>
</ul>
<p><strong>diff</strong></p>
<p>Показывает различия между двумя файлами, в построчном сравнении. Причем выводятся только строки, в которых обнаружены отличия. Измененные строки отмечаются символом &quot;с&quot;, удаленные - &quot;d&quot;, а новые - &quot;а&quot;.</p>
<h2 id="Управление-процессам"><a class="header" href="#Управление-процессам">Управление процессам</a></h2>
<p><strong>kill / xkill / pkill / killall</strong></p>
<p>Все они служат для завершения процессов. Но они принимают различные параметры для идентификации процессов. <strong>Kill</strong> нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, <strong>killall</strong> и <strong>pkill</strong> принимают имя процесса. </p>
<p><strong>Команда killall</strong> в Linux предназначена для «убийства» всех процессов, имеющих одно и то же имя. Это удобно, так как нам не нужно знать PID процесса. Например, мы хотим закрыть все процессы с именем gcalctool. Выполните в терминале:</p>
<pre><code class="language-bash">killall gcalctool
</code></pre>
<p>Команда killall, так же как и kill, по умолчанию шлет сигнал SIGTERM. Чтобы послать другой сигнал нужно воспользоваться опцией <em>-s</em>. Например:</p>
<pre><code class="language-bash">killall -s 9 gcalctool
</code></pre>
<p>Когда вы выполняете команду &quot;kill&quot;, то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение. Всего вы можете использовать до 60 сигналов, но все, что нужно знать, это SIGTERM (15) и SIGKILL (9).</p>
<p><strong>SIGTERM</strong> – Этот сигнал запрашивает остановку процесса который работает. Этот сигнал может быть проигнорирован. Процессу дается время, чтобы хорошо выключился. Когда программа хорошо выключается, это означает, что ей дано время, чтобы спасти его прогресс и освободить ресурсы. Другими словами, он не «forced» прекращение работы процесса.</p>
<p><strong>SIGKILL</strong> – сигнал SIGKILL заставляет процесс прекратить выполнение своей работы немедленно. Программа не может игнорировать этот сигнал. Несохраненный прогресс будет потерян.</p>
<p>Вы можете просмотреть все сигналы с помощью команды:</p>
<pre><code class="language-bash">$ kill -l
</code></pre>
<p>Вот некоторые:</p>
<table><thead><tr><th>N</th><th>Имя</th><th>Описание</th><th>Можно перехватывать</th><th>Можно блокировать</th></tr></thead><tbody>
<tr><td>1</td><td>HUP</td><td>Hangup. Отбой</td><td>Да</td><td>Да</td></tr>
<tr><td>2</td><td>INT</td><td>Interrupt. В случае выполнения простых команд вызывает прекращение выполнения, в интерактивных программах - прекращение активного процесса</td><td>Да</td><td>Да</td></tr>
<tr><td>3</td><td>QUIT</td><td>Как правило, сильнее сигнала Interrupt</td><td>Да</td><td>Да</td></tr>
<tr><td>4</td><td>ILL</td><td>Illegal Instruction. Центральный процессор столкнулся с незнакомой командой (в большинстве случаев это означает, что допущена программная ошибка). Сигнал отправляется программе, в которой возникла проблема</td><td>Да</td><td>Да</td></tr>
<tr><td>8</td><td>FPE</td><td>Floating Point Exception. Вычислительная ошибка, например, деление на ноль</td><td>Да</td><td>Да</td></tr>
<tr><td>9</td><td>KILL</td><td>Всегда прекращает выполнение процесса</td><td>Нет</td><td>Нет</td></tr>
<tr><td>11</td><td>SEGV</td><td>Segmentation Violation. Доступ к недозволенной области памяти</td><td>Да</td><td>Да</td></tr>
<tr><td>13</td><td>PIPE</td><td>Была предпринята попытка передачи данных с помощью конвейера или очереди FIFO, однако не существует процесса, способного принять эти данные</td><td>Да</td><td>Да</td></tr>
<tr><td>15</td><td>TERM</td><td>Software Termination. Требование закончить процесс (программное завершение)</td><td>Да</td><td>Да</td></tr>
</tbody></table>
<p>​	</p>
<p><strong>ps / pgrep</strong></p>
<p>Команда ps выдает информацию об активных процессах. По умолчанию информация дается только о процессах, ассоциированных с данным терминалом. Выводятся идентификатор процесса, идентификатор терминала, истраченное к данному моменту время ЦП и имя команды. Если нужна иная информация, следует пользоваться опциями. Одна из самых распространенных комбинаций флагов: <code>ps aux</code> Выводятся все процессы, выполняющиеся от имени всех пользователей (выводит статистику, время старта процесса и команду, которая его стартовала)</p>
<p><strong>top / htop</strong></p>
<p>Обе команды похожи, обе отображают процессы, и могут быть использованы как консольные системные мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это намного улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный интерфейс.</p>
<p><strong>time</strong></p>
<p>Время выполнения процесса. Это секундомер для выполнения программы. Полезно если вам интересно насколько сильно ваша реализация алгоритма отстает от стандартной. Но несмотря на такое название она не сообщит вам текущее время, используйте для этого команду date.</p>
<h2 id="Пользовательское-окружение"><a class="header" href="#Пользовательское-окружение">Пользовательское окружение</a></h2>
<p><strong>su / sudo</strong></p>
<p>Su и sudo - это два способа выполнить одну и ту же задачу - запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива, вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы.</p>
<p><strong>сhroot</strong> </p>
<p>Операция изменения корневого каталога диска для запущенного процесса и его дочерних процессов. Программа, запущенная в таком окружении не может получить доступ к файлам вне нового корневого каталога. Это измененное окружение называется chroot jail.</p>
<p><strong>date</strong></p>
<p>В отличие от time, делает именно то, чего вы от него и ожидаете - выводит дату и время в стандартный вывод. Вывод можно форматировать, в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой формат, получить наносекунды или номер недели. Например, date +&quot;%j %V&quot;, выведет день в году и номер недели в формате ISO.</p>
<p><strong>alias</strong></p>
<p>Эта команда создает синонимы для других команд Linux. Это означает, что вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд которые вы используете нечасто и не можете запомнить.</p>
<p><strong>uname</strong></p>
<p>Выводит некоторую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки Linux, но если задать параметр -a (All) можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.</p>
<p><strong>uptime</strong></p>
<p>Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных вычислений или просто ради интереса, как давно был перезагружен сервер.</p>
<p><strong>sleep</strong></p>
<p>Вам, наверное, интересно как же ее можно использовать. Но даже кроме Bash скриптинга, у нее есть свои преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени, или в качестве импровизированной тревоги.</p>
<h2 id="Управления-пользователями"><a class="header" href="#Управления-пользователями">Управления пользователями</a></h2>
<p><strong>useradd / userdel / usermod</strong></p>
<p>Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы являетесь единственным пользователем. И даже если нет, управлять пользователями можно с помощью графического интерфейса, но лучше о них знать на случай, если вдруг понадобится.</p>
<p><strong>passwd</strong></p>
<p>Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь, вы можете сбросить пароли всех пользователей, несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль не очень редко.</p>
<h4 id="linux-команды-для-просмотра-документации"><a class="header" href="#linux-команды-для-просмотра-документации">Linux команды для просмотра документации</a></h4>
<p><strong>man / whatis</strong></p>
<p>Команда man открывает руководство по определенной команде. Для всех основных команд Linux есть man страницы. Whatis какие разделы руководств есть для данной команды.</p>
<p><strong>whereis</strong></p>
<p>Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам если они есть в системе.</p>
<h3 id="Команды-linux-для-управления-сетью"><a class="header" href="#Команды-linux-для-управления-сетью">Команды Linux для управления сетью</a></h3>
<p><strong>ip</strong></p>
<p>Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего, вы незнакомы с утилитой ip. В пакете net-tools содержится множество других утилит ipconfig, netstat и другие устаревшие, вроде iproute2. Все это заменяет одна утилита - ip. Вы можете рассматривать ее как швейцарский армейский нож для работы с сетью, или непонятную массу, но в любом случае за ней будущее.</p>
<p><strong>ping</strong></p>
<p>Ping - это ICMP ECHO_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень полезным диагностическим инструментом. Она поможет быстро проверить подключены ли вы к маршрутизатору или к интернету, и дает кое-какое представление о качестве этой связи.</p>
<p><strong>nethogs</strong></p>
<p>Если у вас медленный интернет, то вам, наверное, было бы интересно знать сколько трафика использует та или иная программа в Linux, или вообще какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.</p>
<p><strong>traceroute</strong></p>
<p>Это усовершенствованная версия ping. Кроме непосредственно доступности узла, мы можем увидеть полный маршрут сетевых пакетов, а также время доставки их на каждый узел.</p>
<h2 id="Рецепты"><a class="header" href="#Рецепты">Рецепты</a></h2>
<p><strong>Копируем файл/папку с сервера на сервер</strong></p>
<pre><code class="language-sh">scp -r /path/from/destination username@hostname:/path/to/destination
</code></pre>
<p><strong>Мониторим состояние сервера</strong></p>
<p><strong>Ищем логи</strong></p>
<p><strong>Системные вызовы скрипта пхп</strong></p>
<p><strong>Слушатель 80 порта</strong></p>
<p><strong>Посчитать топ 10 адресов в логах</strong></p>
<pre><code class="language-bash">less /var/log/nginx/access.log | cut -d' ' -f1 | sort | uniq -c
</code></pre>
<p>Разберём подробно:</p>
<ol>
<li><code>less</code> — утилита для вывода содержимого файла /var/log/nginx/access.log. Указываем путь до нужного access-лога.</li>
<li><code>cut -d' ' -f1</code> — разбиваем строку на подстроки разделителем &quot;пробел&quot;. Разделитель указывается флагом -d. Флагом -f указываем порядковый номер поля, которое будет отображаться в выводе. В данном случае «1» - первое поле, это и есть ip-адрес.</li>
<li><code>sort</code>  — сортировка строк по порядку. Команда сгруппирует одинаковые строки &quot;рядом&quot;. Команда sort необходима для корректной работы следующей команды - <code>uniq</code>.</li>
<li><code>uniq</code>— выведет только уникальные строки. Т.е. в результате будут только уникальные ip-адреса.</li>
<li>Для вывода количества, нужно добавить флаг <code>-с</code> (от слова <strong>c</strong>ount) к команде <code>uniq</code>:</li>
</ol>
<p>Ищем с каких серверов демон получает запросы</p>
<p><strong>.bashrc</strong>
Файл ~/.bashrc определяет поведение командной оболочки для конкретного пользователя(переменных окружения например). Загружается каждый раз, когда пользователь создает терминальный сеанс, то есть проще говоря, открывает новый терминал. Все переменные окружения, созданные в этом файле вступают в силу каждый раз когда началась новая терминальная сессия.</p>
<h2 id="cТРУКТУРА-ФАЙЛОВОЙ-СИСТЕМЫ-linux"><a class="header" href="#cТРУКТУРА-ФАЙЛОВОЙ-СИСТЕМЫ-linux">CТРУКТУРА ФАЙЛОВОЙ СИСТЕМЫ LINUX</a></h2>
<ul>
<li>/ - КОРЕНЬ</li>
<li>/BIN - (BINARIES) БИНАРНЫЕ ФАЙЛЫ ПОЛЬЗОВАТЕЛЯ</li>
<li>/SBIN - (SYSTEM BINARIES) СИСТЕМНЫЕ ИСПОЛНЯЕМЫЕ ФАЙЛЫ</li>
<li>/ETC - (ETCETERA) КОНФИГУРАЦИОННЫЕ ФАЙЛЫ</li>
<li>/DEV - (DEVICES) ФАЙЛЫ УСТРОЙСТВ</li>
<li>/PROC - (PROCCESS) ИНФОРМАЦИЯ О ПРОЦЕССАХ</li>
<li>/VAR (VARIABLE) - ПЕРЕМЕННЫЕ ФАЙЛЫ</li>
<li>/VAR/LOG - ФАЙЛЫ ЛОГОВ</li>
<li>/VAR/LIB - БАЗЫ ДАННЫХ</li>
<li>/VAR/MAIL - ПОЧТА</li>
<li>/VAR/SPOOL - ПРИНТЕР</li>
<li>/VAR/LOCK - ФАЙЛЫ БЛОКИРОВОК</li>
<li>/VAR/RUN - PID ПРОЦЕССОВ</li>
<li>/TMP (TEMP) - ВРЕМЕННЫЕ ФАЙЛЫ</li>
<li>/USR - (USER APPLICATIONS) ПРОГРАММЫ ПОЛЬЗОВАТЕЛЯ</li>
<li>/USR/BIN/ - ИСПОЛНЯЕМЫЕ ФАЙЛЫ</li>
<li>/USR/SBIN/ -  Содержит двоичные файлы программ для системного администрирования</li>
<li>/USR/LIB/ - БИБЛИОТЕКИ для программ из /usr/bin или /usr/sbin.</li>
<li>/USR/LOCAL - ФАЙЛЫ ПОЛЬЗОВАТЕЛЯ</li>
<li>/HOME - ДОМАШНЯЯ ПАПКА</li>
<li>/BOOT - ФАЙЛЫ ЗАГРУЗЧИКА</li>
<li>/LIB (LIBRARY) - СИСТЕМНЫЕ БИБЛИОТЕКИ</li>
<li>/OPT (OPTIONAL APPLICATIONS) - ДОПОЛНИТЕЛЬНЫЕ ПРОГРАММЫ</li>
<li>/MNT (MOUNT) - МОНТИРОВАНИЕ</li>
<li>/MEDIA - СЪЕМНЫЕ НОСИТЕЛИ</li>
<li>/SRV (SERVER) - СЕРВЕР</li>
<li>/RUN - ПРОЦЕССЫ</li>
<li>/SYS (SYSTEM) - ИНФОРМАЦИЯ О СИСТЕМЕ</li>
</ul>
<p><em><strong>Дополнительно:</strong></em></p>
<ul>
<li>https://habr.com/post/280093/</li>
<li>https://habr.com/company/ruvds/blog/323330/</li>
<li>http://rus-linux.net/MyLDP/server/monitoring-servera-v-konsoli.html</li>
<li><a href="https://losst.ru/ctruktura-fajlovoj-sistemy-linux">CТРУКТУРА ФАЙЛОВОЙ СИСТЕМЫ LINUX</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Виртуализация"><a class="header" href="#Виртуализация">Виртуализация</a></h1>
<p>Для изоляции процессов, запущенных на одном хосте, запуска приложений, предназначенных для разных платформ, можно использовать виртуальные машины. Виртуальные машины делят между собой физические ресурсы хоста:</p>
<ul>
<li>процессор,</li>
<li>память,</li>
<li>дисковое пространство,</li>
<li>сетевые интерфейсы.</li>
</ul>
<p><img src="https://habrastorage.org/webt/xi/an/fp/xianfp2j4ezvy4u-mg4yb3vf3ra.png" alt="img" /></p>
<p>На каждой ВМ устанавливаем нужную ОС и запускаем приложения. Недостатком такого подхода является то, что значительная часть ресурсов хоста расходуется не на полезную нагрузку(работа приложений), а на работу нескольких ОС.</p>
<h3 id="Контейнеры"><a class="header" href="#Контейнеры">Контейнеры</a></h3>
<p>В отличие от аппаратной виртуализации, при которой эмулируется аппаратное окружение и может быть запущен широкий спектр гостевых операционных систем, в контейнере может быть запущен экземпляр операционной системы только с тем же ядром, что и у хостовой операционной системы (все контейнеры узла используют общее ядро). При этом при контейнеризации отсутствуют дополнительные ресурсные накладные расходы на эмуляцию виртуального оборудования и запуск полноценного экземпляра операционной системы, характерные при аппаратной виртуализации.</p>
<p>Альтернативным подходом к изоляции приложений являются контейнеры. Само понятие контейнеров не ново и давно известно в Linux. Идея состоит в том, чтобы в рамках одной ОС выделить изолированную область и запускать в ней приложение. В этом случае говорим о виртуализации на уровне ОС. В отличие от ВМ контейнеры изолированно используют свой кусочек ОС:</p>
<ul>
<li>
<p>файловая система</p>
</li>
<li>
<p>дерево процессов</p>
</li>
<li>
<p>сетевые интерфейсы</p>
</li>
<li>
<p>и др.</p>
<p><img src="https://habrastorage.org/webt/bd/oe/fu/bdoefumbrdxevhvhs65glqsvexq.png" alt="img" /></p>
</li>
</ul>
<p>Т.о. приложение, запущенное в контейнере думает, что оно одно во всей ОС. Изоляция достигается за счет использования таких Linux-механизмов, как <strong>namespaces</strong> и <strong>control groups</strong>. Если говорить просто, то namespaces обеспечивают изоляцию в рамках ОС, а control groups устанавливают лимиты на потребление контейнером ресурсов хоста, чтобы сбалансировать распределение ресурсов между запущенными контейнерами.</p>
<p>Дополнительно:</p>
<ul>
<li><a href="https://habr.com/ru/company/selectel/blog/303190/">CGRoups</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p>Docker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, который может быть перенесён на любую Linux-систему с поддержкой cgroups в ядре, а также предоставляет среду по управлению контейнерами. Изначально использовал возможности LXC, с 2015 года применял собственную библиотеку, абстрагирующую виртуализационные возможности ядра Linux — libcontainer. С появлением Open Container Initiative начался переход от монолитной к модульной архитектуре.</p>
<h2 id="Основные-термины"><a class="header" href="#Основные-термины">Основные термины</a></h2>
<h3 id="image-образ"><a class="header" href="#image-образ">Image (образ)</a></h3>
<p>Образ в первом приближении можно рассматривать как набор файлов. В состав образа входит все необходимое для запуска и работы приложения на голой машине с докером: ОС, среда выполнения и приложение, готовое к развертыванию.</p>
<ul>
<li>Образ — это набор файлов, необходимых для работы приложения на голой машине с установленным Docker.</li>
<li>Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.</li>
<li>Неизменяемость слоев позволяет их использовать совместно в разных образах.</li>
</ul>
<h3 id="docker-контейнеры"><a class="header" href="#docker-контейнеры">Docker-контейнеры</a></h3>
<p>Контейнер -  процесс, инициализированный на базе образа. То есть контейнер существует только когда запущен. Это как экземпляр класса, а образ это типа класс. Суть преобразования образа в контейнер состоит в добавлении верхнего слоя, для которого разрешена запись. Результаты работы приложения (файлы) пишутся именно в этом слое.</p>
<p><img src="https://habrastorage.org/webt/it/vl/bc/itvlbcymwunjvfhufp55k14gssm.jpeg" alt="img" /></p>
<ul>
<li><strong>Host (хост)</strong> – среда, в которой запускается докер т.е ваша локальная машина.</li>
<li><strong>Volume</strong> – дисковое пространство между хостом и контейнером. Это папка на вашей локальной машине примонтированная внутрь контейнера. Меняете тут меняется там, и наоборот.</li>
<li><strong>Dockerfile</strong> – файл с набором инструкций для создания образа будущего контейнера</li>
<li><strong>Service (сервис)</strong> – по сути это запущенный образ (один или несколько контейнеров), дополнительно сконфигурированный такими опциями как открытие портов, маппинг папок (volume) и прочее. Обычно это делается при помощи docker-compose.yml файла.</li>
<li><strong>Docker-compose</strong> – тулза, облегчающая сборку и запуск системы состоящей из нескольких контейнеров, связанных между собой.</li>
<li><strong>Build (билд, билдить)</strong> – процесс создания образа из набора инструкций в докерфайле, или нескольких докерфайлов, если билд делается с помощью композера</li>
</ul>
<h2 id="Популярные-команды"><a class="header" href="#Популярные-команды">Популярные команды:</a></h2>
<ul>
<li><strong>RUN</strong></li>
<li><strong>CMD</strong></li>
<li><strong>ENTRYPOINT</strong></li>
<li><strong>ADD</strong></li>
<li><strong>COPY</strong></li>
<li><strong>FROM</strong></li>
<li><strong>ENV</strong></li>
<li><strong>WORKDIR</strong></li>
<li><strong>ARG</strong></li>
<li><strong>LABEL</strong></li>
<li><strong>EXPOSE</strong></li>
</ul>
<h2 id="run-vs-cmd-vs-entrypoint"><a class="header" href="#run-vs-cmd-vs-entrypoint">RUN vs CMD vs ENTRYPOINT</a></h2>
<p>Эти инструкции выполняются при сборке docker-образа из Dockerfile. <code>RUN</code> позволяет выполнять команды внутри вашего docker-образа — такие команды выполняются только <strong>один раз во время сборки</strong> и <strong>создают новый слой</strong> в итоговом docker-образе.</p>
<p>Если вам необходимо установить пакет или создать каталог внутри вашего docker-образа, то инструкция <code>RUN</code> подойдет вам как нельзя лучше. Например:</p>
<pre><code class="language-dockerfile">RUN mkdir -p /var/www/test
</code></pre>
<p>Инструкция <code>CMD</code> позволяет определить команду по умолчанию, которая будет выполняться при <strong>запуске</strong> вашего docker-контейнера (запущенный docker-образ называется контейнером). Эта инструкция <strong>не выполняется во время сборки</strong>!</p>
<p>Например, в Dockerfile для веб-приложения вполне логично добавить инструкцию <code>CMD</code>, которая запустит веб-сервер при старте контейнера, например:</p>
<pre><code class="language-dockerfile">CMD [&quot;php&quot;, &quot;-S&quot;, &quot;0.0.0.0:9095&quot;, &quot;-t&quot;, &quot;public&quot;, &quot;public/index.php&quot;]
</code></pre>
<ol>
<li>Use RUN instructions to build your image by adding layers on top of initial image.</li>
<li>Prefer ENTRYPOINT to CMD when building executable Docker image, and you need a command always to be executed. Additionally, use CMD if you need to provide extra default arguments that could be overwritten from command line when docker container runs.</li>
<li>Choose CMD if you need to provide a default command and/or arguments that can be overwritten from command line when docker container runs.</li>
</ol>
<h2 id="docker-compose"><a class="header" href="#docker-compose">Docker-compose</a></h2>
<p>Пакетный менеджер Docker Compose, позволяющий описывать и запускать многоконтейнерные приложения. Конфигурационные файлы Compose описываются на языке YAML</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://habr.com/ru/post/353238/">Docker. Начало</a></li>
<li><a href="https://habr.com/ru/post/337306/">Основы Docker за Х часов и Y дней</a></li>
<li><a href="https://habr.com/ru/company/ruvds/blog/438796/">Изучаем Docker, часть 1: основы</a></li>
<li><a href="https://habr.com/ru/company/ruvds/blog/450312/">Руководство по Docker Compose для начинающих</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p><a href="https://kubernetes.io/">Kubernetes</a> (часто сокращают до k8s) — открытая система оркестрации контейнеров, представленная компанией Google в 2014 году. Kubernetes реализует идею, ранее использованную во внутренней системе Google под названием [Borg <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf">PDF]</a>. Если вкратце, идея состоят в том, что ваш деплоймент строится на базе контейнеров (например, <a href="https://eax.me/docker/">Docker</a>), а также описании того, сколько этих контейнеров нужно и какие ресурсы они используют. Kubernetes на базе этого описания и доступных физических машин разворачивает контейнеры и делает все возможное для поддержания требуемой конфигурации. В том числе, он перезапускает упавшие контейнеры, перемещает их для выделения ресурсов, необходимых новым контейнерам, и так далее.</p>
<h3 id="Зачем-это-нужно"><a class="header" href="#Зачем-это-нужно">Зачем это нужно?</a></h3>
<p>Другими словами, используется декларативный подход — мы описываем, <em>что</em> требуется достичь, а не <em>как</em>. Из преимуществ данного подхода можно отметить следующие. Система сама себя восстанавливает в случае сбоев. У вас не болит голова о том, на какой физической машине запущен тот или иной контейнер, и куда его перенести, чтобы запустить новый тяжелый сервис. Система становится повторяемой. Если у вас все развернулось и работает в тестовом окружении, вы можете с хорошей долей уверенности сказать, что оно развернется в точно такую же систему и на продакшене. Наконец, система становится версионируемой. Если что-то пошло не так, вы можете достать из Git старую конфигурацию и развернуть все в точности, как было раньше.</p>
<p>Стоит однако понимать, что кубер является просто инструментом, а не серебряной пулей. В частности, такие проблемы, как <a href="https://eax.me/backward-compatibility/">миграции схем баз данных или обеспечение обратной совместимости API</a>, остаются на вас. Не следует сломя голову внедрять в проекте кубер, просто потому что сейчас так модно. Определитесь, какую конкретную проблему вы хотели бы решить, и является ли она настолько приоритетной, что решать ее нужно именно сейчас. Затем поднимите где-нибудь на стенде кубер, или воспользуйтесь услугами одной из компаний, <a href="https://kubernetes.io/docs/setup/pick-right-solution/#hosted-solutions">предоставляющих его в качестве сервиса</a>. Посмотрите, решает ли кубер вашу проблему, и не создает ли при этом парочку новых. В общем, совсем не факт, что в каждой IT-компании обязательно нужно использовать Kubernetes.</p>
<h2 id="Основные-понятия-в-kubernetes"><a class="header" href="#Основные-понятия-в-kubernetes">Основные понятия в Kubernetes</a></h2>
<ul>
<li>Kubectl</li>
<li>master node</li>
<li>worker node</li>
<li>Kubelet</li>
<li>pod</li>
<li>secret</li>
<li>service</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<h2 id="Синезеленый-деплой"><a class="header" href="#Синезеленый-деплой">Синезеленый деплой</a></h2>
<p>Одна из задач автоматизации деплоя — переход из одного состояния в другое внутри себя же, с переводом софта из финальной стадии тестирования в действующий продакшен. Обычно это нужно сделать быстро, чтобы минимизировать время простоя. При сине-зеленом подходе у вас есть два продакшена, насколько возможно идентичных. В любое время один из них, допустим синий, активен. При подготовке новой версии софта, вы делаете финальное тестирование в зелёном продакшене. Вы убеждаетесь, что программа в этом продакшене работает и настраиваете роутер так, чтобы все входящие запросы шли в зелёную операционную среду — синяя в режиме ожидания.</p>
<p>Сине-зелёный деплой также даёт вам возможность быстро откатиться до старого состояния: если что-то пойдет не так, переключите роутер обратно на синий продакшен. Но вам всё ещё придётся справляться с пропущенными транзакциями, пока зелёный продакшен активен, и, в зависимости от структуры кода, вы сможете направлять транзакции в оба продакшена, чтобы сохранять синий как резервную копию, при активном зелёном. Или можете перевести приложение в read-only режим, перед синхронизацией, запустить его на время в этом режиме, а потом переключить в режим read-write. Этого может оказаться достаточно, чтобы избавиться от многих нерешенных проблем.</p>
<p>Две среды должны быть полностью самостоятельными, но настолько идентичными, насколько возможно. Иногда это могут быть разные компьютеры, иногда просто две виртуальные машины, запущенные одном (или нескольких) компьютерах. Они также могут быть единой операционной средой, разбитой на обособленные зоны с отдельными IP-адресами.</p>
<p>После того, как зелёный продакшен оказывается в работе, и вы довольны его стабильностью, можете использовать синий как staging, чтобы прогнать его через финальные тесты следующего деплоя. Когда вы будете готовы к следующему релизу, сможете переключаться с зеленого на синий так же как переключались с синего на зелёный. В такой конфигурации и зеленый и синий продакшен регулярно проходят через три состояния — действующее приложение, предыдущую версию (для отката) и staging следующей версии.</p>
<p>Преимущество такого подхода в том, что это тот же самый базовый механизм, который нужен для горячего резервирования (hot-standby). Он позволит вам тестировать процедуру аварийного восстановления при каждом релизе. (Надеюсь, что вы релизите чаще, чем у вас происходит аварийное восстановление).</p>
<p>Основная идея в том, чтобы иметь две легко переключаемых среды, а способов изменять детали — множество. Один вариант — делать переключение перезапуском веб-сервера, а не через роутер. Другой — использовать единую базу данных, а сине-зеленые переключения делать для веба и прикладного уровня.</p>
<h2 id="Канареечный-релизы"><a class="header" href="#Канареечный-релизы">Канареечный релизы</a></h2>
<p><em>Шаблон канареечного релиза</em> автоматизирует процесс релиза, распространяя его последовательно на все более крупные и более критически важные среды, по мере того как мы убеждаемся в том, что код работает, как задумано.</p>
<p>Термин <em>«канареечный релиз»</em> придуман по аналогии с тем, как шахтеры в угольных шахтах брали с собой канареек в клетках, чтобы обнаруживать опасный уровень угарного газа. Если в шахте скапливалось много угарного газа, то он убивал канарейку до того, как становился опасным для шахтеров, и они успевали спастись.</p>
<p>При использовании этого шаблона, когда мы делаем выпуск, то наблюдаем, как программное обеспечение работает в каждой среде. Когда что-то кажется неправильным, мы выполняем откат, в противном случае мы выполняем развертывание в следующей среде.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="Тестирование"><a class="header" href="#Тестирование">Тестирование</a></h1>
<h2 id="Уровни-Тестирования"><a class="header" href="#Уровни-Тестирования">Уровни Тестирования</a></h2>
<h3 id="Модульное-тестирование-unit-testing"><a class="header" href="#Модульное-тестирование-unit-testing">Модульное тестирование (Unit Testing)</a></h3>
<p>Компонентное (модульное) тестирование проверяет функциональность и ищет дефекты в частях приложения, которые доступны и могут быть протестированы по-отдельности (модули программ, объекты, классы, функции и т.д.).</p>
<h4 id="aaaarrange-act-assert"><a class="header" href="#aaaarrange-act-assert">AAA(arrange-act-assert)</a></h4>
<p>Шаблон для форматирования Unit тестов. Обозначающий разделения теста на 3 части</p>
<ol>
<li>Arrange - все необходимые подготовки и входные данные</li>
<li>Act - собственно вызов того метода который вы тестируете</li>
<li>Assert - проверки, что метод делает то что надо</li>
</ol>
<h3 id="Интеграционное-тестирование-integration-testing"><a class="header" href="#Интеграционное-тестирование-integration-testing">Интеграционное тестирование (Integration Testing)</a></h3>
<p>Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.</p>
<h3 id="Системное-тестирование-system-testing"><a class="header" href="#Системное-тестирование-system-testing">Системное тестирование (System Testing)</a></h3>
<p>Основной задачей системного тестирования является проверка как функциональных, так и не функциональных требований в системе в целом. При этом выявляются дефекты, такие как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.</p>
<h3 id="Операционное-тестирование-release-testing"><a class="header" href="#Операционное-тестирование-release-testing">Операционное тестирование (Release Testing).</a></h3>
<p>Даже если система удовлетворяет всем требованиям, важно убедиться в том, что она удовлетворяет нуждам пользователя и выполняет свою роль в среде своей эксплуатации, как это было определено в бизнес модели системы. Следует учесть, что и бизнес модель может содержать ошибки. Поэтому так важно провести операционное тестирование как финальный шаг валидации. Кроме этого, тестирование в среде эксплуатации позволяет выявить и нефункциональные проблемы, такие как: конфликт с другими системами, смежными в области бизнеса или в программных и электронных окружениях; недостаточная производительность системы в среде эксплуатации и др. Очевидно, что нахождение подобных вещей на стадии внедрения — критичная и дорогостоящая проблема. Поэтому так важно проведение не только верификации, но и валидации, с самых ранних этапов разработки ПО.</p>
<h3 id="Приемочное-тестирование-acceptance-testing"><a class="header" href="#Приемочное-тестирование-acceptance-testing">Приемочное тестирование (Acceptance Testing)</a></h3>
<p>Формальный процесс тестирования, который проверяет соответствие системы требованиям и проводится с целью:
•	определения удовлетворяет ли система приемочным критериям;
•	вынесения решения заказчиком или другим уполномоченным лицом принимается приложение или нет.</p>
<h2 id="Виды--типы-тестирования"><a class="header" href="#Виды--типы-тестирования">Виды / типы тестирования</a></h2>
<h4 id="Функциональные-виды-тестирования"><a class="header" href="#Функциональные-виды-тестирования">Функциональные виды тестирования</a></h4>
<ul>
<li>
<p>Функциональное тестирование (Functional testing)</p>
</li>
<li>
<p>Тестирование пользовательского интерфейса (GUI Testing)</p>
</li>
<li>
<p>Тестирование безопасности (Security and Access Control Testing)</p>
</li>
<li>
<p>Тестирование взаимодействия (Interoperability Testing)</p>
</li>
</ul>
<h4 id="Нефункциональные-виды-тестирования"><a class="header" href="#Нефункциональные-виды-тестирования">Нефункциональные виды тестирования</a></h4>
<ul>
<li>Все виды тестирования производительности:</li>
<li>нагрузочное тестирование (Performance and Load Testing)</li>
<li>стрессовое тестирование (Stress Testing)</li>
<li>тестирование стабильности или надежности (Stability / Reliability Testing)</li>
<li>объемное тестирование (Volume Testing)</li>
<li>Тестирование установки (Installation testing)</li>
<li>Тестирование удобства пользования (Usability Testing)</li>
<li>Тестирование на отказ и восстановление (Failover and Recovery Testing)</li>
<li>Конфигурационное тестирование (Configuration Testing)</li>
</ul>
<h4 id="Связанные-с-изменениями-виды-тестирования"><a class="header" href="#Связанные-с-изменениями-виды-тестирования">Связанные с изменениями виды тестирования</a></h4>
<ul>
<li>Дымовое тестирование (Smoke Testing)</li>
<li>Регрессионное тестирование (Regression Testing)</li>
<li>Повторное тестирование (Re-testing)</li>
<li>Тестирование сборки (Build Verification Test)</li>
<li>Санитарное тестирование или проверка согласованности/исправности (Sanity Testing)</li>
</ul>
<h2 id="Фреймворкиинструменты-для-тестирования"><a class="header" href="#Фреймворкиинструменты-для-тестирования">Фреймворки/инструменты для тестирования</a></h2>
<h3 id="php-unit"><a class="header" href="#php-unit">PHP Unit</a></h3>
<p>PHP Unit - самый популярный фреймворк для модульного тестирования в PHP.</p>
<p>PHPUnit is based on the idea that developers should be able to find mistakes in their newly committed code quickly and assert that no <a href="https://en.wikipedia.org/wiki/Regression_testing">code regression</a> has occurred in other parts of the code base. Much like other <a href="https://en.wikipedia.org/wiki/Unit_testing">unit testing</a> frameworks, PHPUnit uses <a href="https://en.wikipedia.org/wiki/XUnit#Assertions">assertions</a> to verify that the behavior of the specific component - or <em>&quot;unit&quot;</em> - being tested behaves as expected.</p>
<p><strong>Data Provider</strong></p>
<p>Метод, являющийся <em>data provider</em>-ом, должен возвращать массив массивов или объект, реализующий интерфейс <code>Iterator</code>. Метод, являющийся тестом, будет вызван несколько раз - с каждым массивом и в качестве аргументов будет передано содержимое массива.</p>
<p>Некоторые ключевые моменты при использовании <em>data provider</em>-а:</p>
<ul>
<li>Метод <em>data provider</em>-а должен быть публичным (<code>public</code>).</li>
<li>Метод <em>data provider</em>-а должен возвращать массив собранных данных.</li>
<li>Метод теста должен использовать аннотацию <code>@dataProvider</code> чтобы указать какой метод использовать в качестве <em>data provider</em>-а.</li>
</ul>
<p><strong>Mock vs Stub</strong></p>
<p>The <code>createMock</code> method is used to create three mostly known test doubles. It's how you configure the object makes it a dummy, a stub, or a mock.</p>
<p>You can also create test stubs with the mock builder (<code>getMockBuilder</code> returns the mock builder). It's just another way of doing the same thing that lets you to tweak some additional mock options with a fluent interface (see <a href="https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.mock-objects">the documentation</a> for more).</p>
<p>Dummy is passed around, but never actually called, or if it's called it responds with a default answer (mostly <code>null</code>). It mainly exists to satisfy a list of arguments.</p>
<pre><code class="language-php">$dummy = $this-&gt;createMock(SomeClass::class);

// SUT - System Under Test
$sut-&gt;action($dummy);
</code></pre>
<p>Stubs are used with query like methods - methods that return things, but it's not important if they're actually called.</p>
<pre><code class="language-php">$stub = $this-&gt;createMock(SomeClass::class);
$stub-&gt;method('getSomething')
    -&gt;willReturn('foo');

$sut-&gt;action($stub);
</code></pre>
<p>Mocks are used with command like methods - it's important that they're called, and we don't care much about their return value (command methods don't usually return any value).</p>
<pre><code class="language-php">$mock = $this-&gt;createMock(SomeClass::class);
$mock-&gt;expects($this-&gt;once())
    -&gt;method('doSomething')
    -&gt;with('bar');

$sut-&gt;action($mock);
</code></pre>
<p>Expectations will be verified automatically after your test method finished executing. In the example above, the test will fail if the method <code>doSomething</code> wasn't called on <code>SomeClass</code>, or it was called with arguments different to the ones you configured.</p>
<h3 id="codeception"><a class="header" href="#codeception">Codeception</a></h3>
<p>Сodeception это, надстройка над PHPUnit(или любым другим тест фреймворком). Она позволяет выполнять сценарные тесты на движке PHPUnit. При этом все ваши существующие тесты для PHPUnit Codeception сможет подхватить без каких-либо проблем. К ним вы сможете легко добавить функциональные и приемочные тесты. Очень многие задачи, требующие костылей (например, интеграция с <a href="https://automated-testing.info/tags/webdriver">Selenium</a>, с БД) в Codeception уже решены.</p>
<h3 id="behat"><a class="header" href="#behat">Behat</a></h3>
<p>Behat - это инструмент BDD.</p>
<p>BDD - behaviour-driven development - это разработка, основанная на описании поведения. То есть, есть специальный человек(или люди) который пишет описания вида &quot;я как пользователь хочу <strong>когда</strong> нажали кнопку пуск <strong>тогда</strong> показывалось меню как на картинке&quot;. (там есть специально выделенные ключевые слова). </p>
<p>В чем преимущество BDD?</p>
<ul>
<li><strong>тесты</strong> читаемые для не программистов.</li>
<li>их легко изменять. Они часто пишутся почти на чистом английском.</li>
<li>их теперь может писать product owner или другие заинтересованные лица.</li>
<li>результаты выполнения тестов более &quot;человечные&quot;.</li>
<li><strong>тесты</strong> не зависят от целевого языка программирования. Миграция на другой язык сильно упрощается.</li>
</ul>
<p>И именно для этих целей Behat и используется. Позволяет писать тесты человекопонятным английским языком в формате Given-When-Then, преобразуя эти инструкции в вызов автотестов.</p>
<h3 id="selenium"><a class="header" href="#selenium">Selenium</a></h3>
<p><em>Selenium -- это инструмент для автоматизированного управления браузерами.</em> Наиболее популярной областью применения Selenium является автоматизация тестирования веб-приложений. Однако при помощи Selenium можно автоматизировать любые другие рутинные действия, выполняемые через браузер(клик на кнопку, наведение мыши на объект, печать в инпут и т.д).</p>
<h2 id="tdd"><a class="header" href="#tdd">TDD</a></h2>
<p><strong>Разработка через тестирование</strong> (test-driven development, TDD) — техника <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">разработки программного обеспечения</a>, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://dou.ua/forums/topic/13389/">Тестирование. Фундаментальная теория</a> - самый лучший</li>
<li><a href="https://phpunit.de/getting-started/phpunit-7.html">PHPUnit Getting Started</a> </li>
<li><a href="https://jtreminio.com/blog/unit-testing-tutorial-part-i-introduction-to-phpunit/">Unit Testing Tutorial Part I: Introduction to PHPUnit</a></li>
<li><a href="http://www.protesting.ru">ProTesting</a></li>
<li><a href="https://phpprofi.ru/series/show/1">PHPUnit для начинающих</a></li>
<li>https://codeception.com/05-06-2013/specification-testing-coparison.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Неотсортированные-темы"><a class="header" href="#Неотсортированные-темы">Неотсортированные темы</a></h1>
<p>Здесь будет различная инфа, которую сложно(на данный момент) отнести к какому-либо разделу книги.</p>
<ul>
<li><a href="unsorted/bits.html">Побитовые операции</a></li>
<li><a href="unsorted/unicode.html">Юникод</a></li>
<li><a href="unsorted/types.html">Типизация</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Побитовые-операторы"><a class="header" href="#Побитовые-операторы">Побитовые операторы</a></h1>
<p>Побитовые операторы интерпретируют операнды как последовательность из 32 битов (нулей и единиц). Они производят операции, используя двоичное представление числа, и возвращают новую последовательность из 32 бит (число) в качестве результата.</p>
<h2 id="Формат-32-битного-целого-числа-со-знаком"><a class="header" href="#Формат-32-битного-целого-числа-со-знаком">Формат 32-битного целого числа со знаком</a></h2>
<p>Что такое двоичная система счисления, вам, надеюсь, уже известно. При разборе побитовых операций мы будем обсуждать именно двоичное представление чисел, из 32 бит.</p>
<p>Старший бит слева – это научное название для самого обычного порядка записи цифр (от большего разряда к меньшему). При этом, если больший разряд отсутствует, то соответствующий бит равен нулю.</p>
<p>Примеры представления чисел в двоичной системе:</p>
<pre><code>a = 0;  // 00000000000000000000000000000000
a = 1;  // 00000000000000000000000000000001
a = 2;  // 00000000000000000000000000000010
a = 3;  // 00000000000000000000000000000011
a = 255;// 00000000000000000000000011111111
</code></pre>
<p>Обратите внимание, каждое число состоит ровно из 32-битов.</p>
<p>Дополнение до двойки – это название способа поддержки отрицательных чисел.</p>
<p>Двоичный вид числа, обратного данному (например, 5 и -5) получается путём обращения всех битов с прибавлением 1.</p>
<p>То есть, нули заменяются на единицы, единицы – на нули и к числу прибавляется 1. Получается внутреннее представление того же числа, но со знаком минус.</p>
<p>Например, вот число 314:</p>
<p><code>00000000000000000000000100111010</code></p>
<p>Чтобы получить -314, первый шаг – обратить биты числа: заменить 0 на 1, а 1 на 0:</p>
<p><code>11111111111111111111111011000101</code></p>
<p>Второй шаг – к полученному двоичному числу прибавить единицу, обычным двоичным сложением: 11111111111111111111111011000101 + 1 = 11111111111111111111111011000110.</p>
<p>Итак, мы получили:</p>
<p><code>-314 = 11111111111111111111111011000110</code></p>
<p>Принцип дополнения до двойки делит все двоичные представления на два множества: если крайний-левый бит равен 0 – число положительное, если 1 – число отрицательное. Поэтому этот бит называется знаковым битом.</p>
<p><em>Дополнительно:</em></p>
<ul>
<li><a href="https://learn.javascript.ru/bitwise-operators">Основы JavaScript Побитовые операторы</a></li>
<li><a href="http://php.net/manual/ru/language.operators.bitwise.php">Побитовые операторы</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типизация"><a class="header" href="#Типизация">Типизация</a></h1>
<p>Языки программирования по типизации принято делить на два больших лагеря <strong>типизированные</strong> и <strong>нетипизированные(бестиповые)</strong>. К первому например относятся C, Python, Scala, PHP и Lua, а ко второму — язык ассемблера, Forth и Brainfuck.</p>
<p>Так как «бестиповая типизация» по своей сути — проста как пробка, дальше она ни на какие другие виды не делится. А вот типизированные языки разделяются еще на несколько пересекающихся категорий:</p>
<p><strong><em>Статическая</em> / <em>динамическая</em></strong> типизация. Статическая определяется тем, что конечные типы переменных и функций устанавливаются на этапе компиляции. Т.е. уже компилятор на 100% уверен, какой тип где находится. В динамической типизации все типы выясняются уже во время выполнения программы. </p>
<p>Примеры:
Статическая: C, Java, C#; 
Динамическая: Python, JavaScript, Ruby.</p>
<p><strong><em>Сильная</em> / <em>слабая</em></strong> типизация (также иногда говорят строгая / нестрогая). Сильная типизация выделяется тем, что язык не позволяет смешивать в выражениях различные типы и не выполняет автоматические неявные преобразования, например нельзя вычесть из строки множество. Языки со слабой типизацией выполняют множество неявных преобразований автоматически, даже если может произойти потеря точности или преобразование неоднозначно.</p>
<p>Примеры:
Сильная: Java, Python, Haskell, Lisp;
Слабая: C, JavaScript, Visual Basic, PHP.</p>
<p><strong><em>Явная</em> / <em>неявная</em></strong> типизация. Явно-типизированные языки отличаются тем, что тип новых переменных / функций / их аргументов нужно задавать явно. Соответственно языки с неявной типизацией перекладывают эту задачу на компилятор / интерпретатор.</p>
<p>Примеры:
Явная: C++, D, C#
Неявная: PHP, Lua, JavaScript</p>
<p>Также нужно заметить, что все эти категории пересекаются, например язык C имеет статическую слабую явную типизацию, а язык Python — динамическую сильную неявную.</p>
<p><em><strong>Номинативная/Структурная</strong></em> типизация. Номинативная, следит за названиями типов, структурная типизация принимает решение о совместимости типов на основе их содержимого. Т.е если тип А содержит все свойства/методы типа б, то он может быть использован как тип Б.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="О-Юникоде"><a class="header" href="#О-Юникоде">О Юникоде</a></h1>
<p>До появления Юникода широко использовались 8-битные кодировки, главные минусы которых очевидны:</p>
<ul>
<li>Всего 255 символов, да и то часть из них не графические;</li>
<li>Возможность открыть документ не с той кодировкой, в которой он был создан;</li>
<li>Шрифты необходимо создавать для каждой кодировки.</li>
</ul>
<p>Так и было решено создать единый стандарт «широкой» кодировки, которая включала бы все символы (при чем сначала хотели в нее включить только обычные символы, но потом передумали и начали добавлять и экзотические). Юникод использует 1 112 064 кодовых позиций (больше чем 16 бит). Начало дублирует ASCII, а дальше остаток латиницы, кирилица, другие европейские и азиатские символы. Для обозначений символов используют шестнадцатеричную запись вида «U+xxxx» для первых 65k и с большим количеством цифр для остальных.</p>
<h2 id="О-utf-8"><a class="header" href="#О-utf-8">О UTF-8</a></h2>
<p>Когда-то я думал что есть Юникод, а есть UTF-8. Позже я узнал, что ошибался.</p>
<p>UTF-8 является лишь представлением Юникода в 8-битном виде. Символы с кодами меньше 128 представляются одним байтом, а так как в Юникоде они повторяют ASCII, то текст написанный только этими символами будет являться текстом в ASCII. Символы же с кодами от 128 кодируются 2-мя байтами, с кодами от 2048 — 3-мя, от 65536 — 4-мя. Так можно было бы и до 6-ти байт дойти, но кодировать ими уже ничего.</p>
<pre><code>0 — 127: 0xxxxxxx
128 — 2047: 110xxxxx 10xxxxxx
2048 — 65535: 1110xxxx 10xxxxxx 10xxxxxx
655356 — 0x001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>
<h2 id="Кодируем-в-utf-8"><a class="header" href="#Кодируем-в-utf-8">Кодируем в UTF-8</a></h2>
<p>Порядок действий примерно такой:</p>
<ul>
<li>Каждый символ превращаем в Юникод.</li>
<li>Проверяем из какого символ диапазона.</li>
<li>Если код символа меньше 128, то к результату добавляем его в неизменном виде.</li>
<li>Если код символа меньше 2048, то берем последние 6 бит и первые 5 бит кода символа. К первым 5 битам добавляем 0xC0 и получаем первый байт последовательности, а к последним 6 битам добавляем 0x80 и получаем второй байт. Конкатенируем и добавляем к результату.</li>
<li>Похожим образом можем продолжить и для больших кодов, но если символ за пределами U+FFFF придется иметь дело с UTF-16 суррогатами.</li>
</ul>
<h2 id="utf-32"><a class="header" href="#utf-32">UTF-32</a></h2>
<p>UTF-32 — способ представления Юникода, при котором каждый символ занимает ровно 4 байта. Главное преимущество UTF-32 перед кодировками переменной длины заключается в том, что символы Юникод в ней непосредственно индексируемы, поэтому найти символ по номеру его позиции в файле можно чрезвычайно быстро, и получение любого символа <em>n</em>-й позиции при этом является операцией, занимающей всегда одинаковое время. Это также делает замену символов в строках UTF-32 очень простой. Напротив, кодировки с переменной длиной требуют последовательного доступа к символу <em>n</em>-й позиции, что может быть очень затратной по времени операцией. Главный недостаток UTF-32 — это неэффективное использование пространства, так как для хранения любого символа используется четыре байта. Символы, лежащие за пределами нулевой (базовой) плоскости кодового пространства, редко используются в большинстве текстов. Поэтому удвоение, в сравнении с UTF-16, занимаемого строками в UTF-32 пространства, зачастую не оправдано.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Методологии-разработки-ПО"><a class="header" href="#Методологии-разработки-ПО">Методологии разработки ПО</a></h1>
<h2 id="Водопад-или-Каскадная-модель"><a class="header" href="#Водопад-или-Каскадная-модель">Водопад или Каскадная модель</a></h2>
<p><strong>Каскадная модель</strong> (waterfall model) - <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%81%D0%BA%D0%B0%D0%B4%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C"><em>модель процесса разработки</em></a> программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы анализа требований, проектирования, реализации, тестирования, интеграции и поддержки.
Каскадная модель подходит для больших проектов с большими сроками, большими штатами, большим функционалом: сложные системы в банковской сфере, большие интернет-магазины, проекты с большим числом пользователей и так далее. ТЗ для таких проектов может занимать тысячи страниц, но для разработчиков такой процесс фактически идеален: все описано, всё завизировано и утверждено, сделано максимально всё, чтобы понять как должна работать система.</p>
<p>Водопад даёт качественный результат в силу чёткого следования порядку работы, отсутствию смены требований.</p>
<p>Минус системы: при необходимости изменений возникает большой объём &quot;бюрократических&quot; работ: согласование и утверждение со всеми заинтересованными лицами.</p>
<h2 id="Итеративный-процесс"><a class="header" href="#Итеративный-процесс">Итеративный процесс</a></h2>
<p><strong>Итеративная разработка</strong> - это выполнение работ параллельно с непрерывным анализом полученных результатов и корректировкой предыдущих этапов работы. Проект при этом <a href="http://ru.wikipedia.org/wiki/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0"><em>подходе</em></a> в каждой фазе развития проходит повторяющийся цикл: Планирование — Реализация — Проверка — Оценка ( plan-do-check-act cycle).</p>
<p>Предпочтителен в случаях когда система сложная и непонятно как она должна работать в конечном виде. Основной принцип: пошаговое приближение к конечной цели. То есть сделать от начала и до конца часть системы, внедрить, собрать фидбек, обсудить, скорректировать процесс и перейти к следующему шагу. Итерация может быть большой (2-3 месяца) или нет (2-3 недели).</p>
<p>Метод очень эффективен в плане взаимодействия с клиентом. Особенно с тем, кто толком не представляет чего он хочет. Улучшается обратная связь с Заказчиком – он принимает каждый этап (итерацию). Выпуск проекта в стартовой, урезанной конфигурации позволяет Заказчику самому понять куда идти дальше. И он идёт дальше <strong>вместе с вами</strong>.</p>
<p>Метод позволяет брать в работу приоритетные задачи и риски. Распределяется нагрузка равномерно по всему сроку, то есть проектировщики не сидят без дела, после выполнения проектирования, как было бы в методе &quot;водопад&quot;, а после выполнения первого этапа, когда программисты только начали работу, переходят ко второму. В это время дизайнеры могут заниматься уже третьим этапом.</p>
<p>Затраты на проект распределяются равномерно, а не в конце проекта. Это важно для Заказчика.</p>
<p>Сложности метода:</p>
<ul>
<li>Нужно внедрять, обучать людей;</li>
<li>Много ролей, требующих узкой специализации;</li>
<li>Требуется постоянный контроль, поддержание процесса.</li>
</ul>
<p>Итеративный процесс имеет несколько видов: Agile, XP, Kanban, RUP и другие.</p>
<h3 id="agilescrum"><a class="header" href="#agilescrum">Agile/Scrum</a></h3>
<p><a href="http://www.agilemanifesto.org/iso/ru/"><em><strong>Agile</strong></em></a> - серия подходов к разработке программного обеспечения, ориентированных на использование итеративной разработки, динамическое формирование требований и обеспечение их реализации в результате постоянного взаимодействия внутри самоорганизующихся рабочих групп, состоящих из специалистов различного профиля.</p>
<p><strong>Scrum</strong> - методология гибкой разработки программного обеспечения. Scrum чётко делает акцент на неотвратимости срока демонстрации готового функционала клиенту.</p>
<p><img src="../media/image11.jpeg" alt="" /></p>
<p>Работа организуется по следующему принципу:</p>
<ol>
<li>Менеджер проекта (Product owner) собирает все потребности, &quot;хотелки&quot; по продукту, сценарии использования в списке задач (Product backlog).</li>
<li>На основе Product backlog на собрании перед циклом разработки (Sprint planning meeting) составляется круг задач (Sprint backlog) решаемых в этой итерации (Sprint'e)</li>
<li>Производится цикл с разработкой, тестированием, демонстрацией результата заказчику.</li>
<li>По результатам Sprint'а проводится публичный анализ (Sprint Retrospective) результатов работы.</li>
<li>Цикл повторяется нужное число раз до выхода готового продукта.</li>
</ol>
<p><strong>Плюсы и минусы технологии</strong></p>
<p><strong>Плюсы:</strong></p>
<ul>
<li>Просто внедрить</li>
<li>Разработчикам обычно нравится</li>
<li>Прозрачность проекта</li>
<li>Ориентация на результат</li>
</ul>
<p><strong>Минусы:</strong></p>
<ul>
<li>Не все люди сработаются, сложности &quot;человеческого фактора&quot;.</li>
<li>Издержки на «болтовню» 10-30%</li>
<li>Качество веб-системы может сильно пострадать, если неверно организован процесс и неверно заданы Definition of Done.</li>
</ul>
<h3 id="Канбан"><a class="header" href="#Канбан">Канбан</a></h3>
<p><strong>Kanban</strong> - модель разработки, в условиях ограничения числа выполняемых задач каждым разработчиком.</p>
<p>Модель подходит для веб-студий, работающих с большим количеством несложных заказов. Работа по этой модели - это работа без конечных сроков. Клиент платит за то, что студия потратила время. При доверии со стороны клиента, что программист работает эффективно и поставленную задачу реально можно было решить именно за то время, которое на неё потрачено.</p>
<p>Канбан позволяет сократить время прохода задачи до состояния «готовности». Количество незавершённой работы разработчика должно быть ограничено. Новая задача может ставиться только тогда, когда какая-то из существующих передаётся следующему элементу производственного цикла. Kanban (или сигнальная карточка) подразумевает, что производится некое визуальное оповещение о том, что можно задавать новую работу, так как текущий объём работ не равен принятым лимитам.</p>
<p><strong>Смысл системы с точки зрения разработчика</strong>: максимально упростить бюрократию и дать человеку просто работать над небольшим числом задач.</p>
<p><strong>Смысл системы с точки зрения компании</strong>: снижение времени прохождения задачи через группу специалистов до её релиза. Система позволяет создать работнику такие комфортные условия работы, что бы задача проходила через все эти этапы быстро. При этом происходит визуализация задач, облегчающая контроль.</p>
<p><img src="../media/image12.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Чеклист-подготовки"><a class="header" href="#Чеклист-подготовки">Чеклист подготовки</a></h1>
<p>Чеклист нужен для того, чтобы в максимально короткие сроки выявить пробелы в знаниях.</p>
<h2 id="Алгоритмы-и-Структуры-Данных"><a class="header" href="#Алгоритмы-и-Структуры-Данных">Алгоритмы и Структуры Данных</a></h2>
<ul>
<li>Базовые структуры</li>
<li>Массив и его сортировки(сложность и реализация)
<ul>
<li>Пузырек</li>
<li>Вставками</li>
<li>Быстрая</li>
<li>Выборками</li>
</ul>
</li>
<li>Хэш-Таблица
<ul>
<li>Хеш функция</li>
<li>Методы разрешения колизий
<ul>
<li>Метод цепочек</li>
<li>Последовательность проб </li>
</ul>
</li>
</ul>
</li>
<li>Дерево
<ul>
<li>Бинарное дерево поиска</li>
<li>B(balanced) Tree</li>
<li>B+ Tree</li>
<li>АВЛ </li>
<li>Красно черное </li>
<li>Поворот </li>
</ul>
</li>
<li>Граф
<ul>
<li>Поиск в ширину, в глубину, алгоритм Дейкстры</li>
</ul>
</li>
<li>Разное
<ul>
<li>Бинарный поиск</li>
<li>Динамическое программирование</li>
<li>Жадные алгоритмы</li>
<li>Побитовые операции</li>
</ul>
</li>
</ul>
<h2 id="Базы-Данных"><a class="header" href="#Базы-Данных">Базы Данных</a></h2>
<ul>
<li>Теория Баз Данных
<ul>
<li>Транзакции
<ul>
<li>ACID</li>
<li>Проблемы параллельного чтения</li>
<li>Уровни изолированности транзакций</li>
</ul>
</li>
<li>Нормальные формы(1-6 + бойса кода + доменная)</li>
<li>Распределенные БД
<ul>
<li>Репликация
<ul>
<li>Синхронная и асинхронная и полусинхронная</li>
<li>Master/Master &amp; Master/Slave</li>
<li>Покомандная(логическая) &amp; Построчная(физическая)</li>
</ul>
</li>
<li>Шардинг
<ul>
<li>Статический и динамический + комбинированный, vitual bucket</li>
<li>Решардинг</li>
<li>Ключ шардирования</li>
<li>Паттерны поиска(умный клиент, прокси, координатор)</li>
<li>Консистентный хеш</li>
</ul>
</li>
<li>Теорема САР</li>
<li>MapReduce</li>
</ul>
</li>
</ul>
</li>
<li>Конкретные реализации СУБД
<ul>
<li>MySql
<ul>
<li>Архитектура MySql
<ul>
<li>Конекшн</li>
<li>Парсер, оптимизатор, кеш и буфер, sql интерфейс</li>
<li>Движки(подсистемы хранения)</li>
<li>Файловая система</li>
</ul>
</li>
<li>Конкурентный доступ
<ul>
<li>Блокировки
<ul>
<li>shared lock и exclusive loc</li>
<li>построчная и табличная</li>
<li>явные/неявные</li>
<li>SELECT… LOCK IN SHARE MODE</li>
<li>SELECT… FOR UPDATE </li>
<li>Блокировка индекса innoDB(record lock, gap lock, next key lock)</li>
<li>согласованное неблокирующее чтение</li>
</ul>
</li>
<li>Deadlock</li>
<li>MVCC</li>
</ul>
</li>
<li>Индексы
<ul>
<li>B Tree
<ul>
<li>B Tree</li>
<li>B+ Tree</li>
<li>Составной индекс</li>
<li>Устройство B Tree индекса изнутри</li>
</ul>
</li>
<li>Hash</li>
<li>R-Tree</li>
<li>Селективность и кардинальность</li>
<li>Кластерные индексы</li>
<li>Покрывающие индексы</li>
</ul>
</li>
<li>Основы SQL
<ul>
<li>CREATE,  ALTER,  DROP,  SELECT, INSERT, UPDATE, DELETE, HAVING, GROUP BY, JOIN</li>
</ul>
</li>
<li>Explain</li>
<li>Разное
<ul>
<li>Innodb vs MyIsam</li>
<li>Datetime vs Timestamp</li>
</ul>
</li>
</ul>
</li>
<li>PostgreSql</li>
<li>NoSql
<ul>
<li>Memcaced</li>
<li>Redis
<ul>
<li>Типы данных</li>
<li>Redis Cluster</li>
<li>Репликация и шардинг</li>
</ul>
</li>
<li>Tarantool</li>
<li>Rabbit</li>
<li>Kafka</li>
<li>Mongo</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Архитектура"><a class="header" href="#Архитектура">Архитектура</a></h2>
<ul>
<li>Основы ООП
<ul>
<li>Инкапсуляция</li>
<li>Полиморфзим</li>
<li>Наследование</li>
<li>Композиция/агрегация</li>
</ul>
</li>
<li>Паттерны GoFБанда 4
<ul>
<li>Создающие</li>
<li>Поведенческие</li>
<li>Структурные</li>
</ul>
</li>
<li>Принципы хорошей архитектуры
<ul>
<li>SOLID</li>
<li>GRASP</li>
<li>DRY</li>
<li>KISS</li>
</ul>
</li>
<li>Архитектурные паттерны
<ul>
<li>Layer architecture</li>
<li>Onion architecutre</li>
<li>Hexogonal architecture</li>
<li>CQRS</li>
<li>ES</li>
<li>Saga</li>
</ul>
</li>
<li>DDD
<ul>
<li>Стратегические
<ul>
<li>Bounded context</li>
<li>Ubiquitous language</li>
<li>Subdomain</li>
</ul>
</li>
<li>Тактические
<ul>
<li>Agregate root</li>
<li>Entity</li>
<li>Value object</li>
</ul>
</li>
</ul>
</li>
<li>Api и Микросервисы
<ul>
<li>Rest</li>
<li>Rpc</li>
<li>JsonApi</li>
<li>GraphQL</li>
<li>gRpc</li>
<li>protobuf</li>
</ul>
</li>
</ul>
<h2 id="php-1"><a class="header" href="#php-1">PHP</a></h2>
<ul>
<li>Фичи новых версий</li>
<li>PHP Internals
<ul>
<li>Zval</li>
<li>Union</li>
<li>CopyOnWrite</li>
</ul>
</li>
<li>Стандартные функции</li>
<li>Фреймворки
<ul>
<li>Laravel</li>
<li>Symfony</li>
</ul>
</li>
<li>Разное</li>
</ul>
<h2 id="golang-1"><a class="header" href="#golang-1">GoLang</a></h2>
<ul>
<li>shceduler
<ul>
<li>3 сущности - горутина, поток, контекст привязанный к потоку</li>
<li>m : n (m задач на n потоках)</li>
<li>work stealing</li>
</ul>
</li>
<li>указатели(передача по ссылке/значению)</li>
<li>arrays &amp; slices</li>
<li>channels(небуферизированные/буферизированные) неблокирующее чтение</li>
<li>sync(mutex(r/w), atomic, once, pool, map, waitgrop)</li>
<li>рефлексия</li>
<li>unsafe</li>
<li>Error(), panic, deffer, recover</li>
<li>context.Context</li>
</ul>
<h2 id="Информационная-безопасность-1"><a class="header" href="#Информационная-безопасность-1">Информационная безопасность</a></h2>
<ul>
<li>SQL injection</li>
<li>XSS</li>
<li>CSRF</li>
</ul>
<h2 id="git-1"><a class="header" href="#git-1">Git</a></h2>
<ul>
<li>Rebase vs Merge</li>
<li>Checkout vs reset vs revert</li>
</ul>
<h2 id="Основы-сетей-1"><a class="header" href="#Основы-сетей-1">Основы сетей</a></h2>
<ul>
<li>Взаимодействие с веб-сервером</li>
<li>HTTP</li>
<li>SSL/TLS</li>
<li>DNS</li>
<li>Сетевые модели</li>
<li>realTime взаимодействие с сервером</li>
<li>Что происходит при нажатии на g</li>
</ul>
<h2 id="Операционные-системы"><a class="header" href="#Операционные-системы">Операционные системы</a></h2>
<ul>
<li>потоки и процессы</li>
<li>гринтреды</li>
<li>вытесняющая и кооперативная многозадачность</li>
</ul>
<h2 id="Системное-администрирование"><a class="header" href="#Системное-администрирование">Системное администрирование</a></h2>
<ul>
<li>Linux
<ul>
<li>Как убить процесс</li>
<li>Load Average</li>
</ul>
</li>
<li>Docker
<ul>
<li>Теория виртуализации</li>
<li>Kubernetes</li>
</ul>
</li>
</ul>
<h2 id="Тестирование-1"><a class="header" href="#Тестирование-1">Тестирование</a></h2>
<ul>
<li>Юнит тесты</li>
<li>Интеграционные тесты</li>
<li>Приемочные тесты</li>
<li>Системные</li>
<li>Мутационное тестирование</li>
</ul>
<h2 id="Менеджмент-и-тимлидство"><a class="header" href="#Менеджмент-и-тимлидство">Менеджмент и тимлидство</a></h2>
<ul>
<li>Обязанности тимлида
<ul>
<li>Resource Manager</li>
<li>Product Owner</li>
<li>Integrator</li>
<li>Technical Lead</li>
<li>Administrator</li>
</ul>
</li>
<li>Методологии разработки
<ul>
<li>Водопад</li>
<li>Итеративные модели</li>
<li>Scrum</li>
<li>Kanban</li>
<li>Scrumban</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
