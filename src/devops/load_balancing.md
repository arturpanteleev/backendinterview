# Load Balancing

В этом разделе будут рассмотрены различные стратегии балансировки нагрузки, контроля ошибок и различных ограничителей работы системы.

## Load Balancing

Существует много алгоритмов балансировки нагрузки, которые используются для распределения запросов между серверами или ресурсами с целью обеспечения равномерной загрузки и повышения производительности системы. Вот несколько популярных алгоритмов балансировки нагрузки:

1. **Round Robin (Круговой выбор):** Этот алгоритм выбирает сервера в порядке их перечисления и возвращает следующий сервер при каждом запросе. После достижения последнего сервера алгоритм начинает выбор снова с первого сервера. Round Robin прост в реализации и хорошо подходит для равномерного распределения нагрузки.
2. **Least Connections (Наименьшее количество соединений):** Этот алгоритм направляет запросы на сервер с наименьшим текущим количеством активных соединений. Это может быть полезно, если некоторые серверы более загружены, чем другие.
3. **Weighted Round Robin (Взвешенный круговой выбор):** Этот алгоритм допускает установку весов (приоритетов) для каждого сервера. Серверы с более высокими весами получают больше запросов, чем серверы с более низкими весами. Это позволяет управлять нагрузкой и учитывать разную производительность серверов.
4. **Weighted Least Connections (Взвешенное наименьшее количество соединений):** По аналогии с Weighted Round Robin, этот алгоритм учитывает веса серверов, но выбирает сервер с наименьшим количеством соединений и учитывает их веса при принятии решения.
5. **IP Hash (Хэш IP-адреса):** В этом алгоритме балансировки нагрузки используется IP-адрес клиента для распределения запросов. Каждый клиент всегда направляется к одному и тому же серверу на основе его IP-адреса. Это обеспечивает последовательность запросов от одного и того же клиента на один и тот же сервер.
6. **Sticky sessions(липкие сессии)** - это механизм балансировки нагрузки, который направляет запросы от одного и того же клиента всегда к одному и тому же серверу в кластере. Это особенно полезно, когда веб-приложение хранит состояние сеанса на сервере (например, данные в сессии или куки), и вы хотите, чтобы все запросы от клиента обрабатывались тем же сервером.
7. **Random (Случайный выбор):** В этом алгоритме балансировки нагрузки запросы случайным образом распределяются между серверами. Этот метод может быть прост в реализации, но не всегда обеспечивает равномерное распределение нагрузки.
8. **Least Response Time (Наименьшее время ответа):** Этот алгоритм направляет запросы на сервер с наименьшим временем ответа на предыдущие запросы. Он учитывает производительность серверов и стремится маршрутизировать запросы к наиболее отзывчивым серверам.
9. **Chaos Monkey (Обезьяна Хаоса):** Это не стандартный алгоритм балансировки нагрузки, а скорее инструмент для внесения случайных сбоев в инфраструктуру с целью проверки ее надежности и отказоустойчивости.

## Обработка ошибок и отказов

1. **Circuit Breaker :**
   - **Описание:** Этот паттерн помогает предотвратить повторные запросы к сервису, который временно не доступен, чтобы уменьшить нагрузку и ускорить восстановление.
   - **Принцип работы:** Защитный выключатель имеет три состояния: "Закрыто" (Closed), "Открыто" (Open) и "Полуоткрыто" (Half-Open).
     - В начале, когда система работает нормально, выключатель находится в состоянии "Закрыто". Он позволяет запросам проходить.
     - Если количество ошибок (например, неудачных запросов) превысит определенный порог, выключатель переходит в состояние "Открыто", и все запросы отклоняются без попыток обращения к сервису. Это предотвращает перегрузку сервиса и ускоряет его восстановление.
     - После некоторого времени выключатель переходит в состояние "Полуоткрыто", и несколько тестовых запросов выполняются к сервису. Если они успешно завершаются, выключатель возвращается в состояние "Закрыто", и запросы начинают проходить снова. Если запросы продолжают завершаться с ошибками, выключатель остается в состоянии "Открыто".
   - **Использование:** Circuit Breaker помогает улучшить отказоустойчивость системы и предотвратить бесконечные попытки обращения к неработающему сервису.
2. **Retry:**
   - **Описание:** Паттерн Retry позволяет повторно отправлять запросы, которые временно не удалось выполнить из-за ошибок или отказов.
   - **Принцип работы:** Когда запрос завершается с ошибкой, механизм Retry может повторно отправить запрос через некоторое время. Повторные попытки выполняются до тех пор, пока запрос не будет выполнен успешно или не будет достигнут лимит повторов.
   - **Использование:** Retry полезен в ситуациях, когда ошибка может быть временной, и повторная попытка выполнения запроса может привести к успешному результату.
3. **Timeout:**
   - **Описание:** Паттерн Timeout определяет максимальное разрешенное время ожидания выполнения операции.
   - **Принцип работы:** Когда операция выполняется, система отсчитывает таймер. Если операция не завершается в течение установленного времени, она автоматически прерывается.
   - **Использование:** Timeout позволяет избегать бесконечного ожидания результатов операций и предотвращать блокировки.
4. **Fallback:**
   - **Описание:** Паттерн Fallback определяет альтернативное действие, которое выполняется, если основная операция завершается с ошибкой.
   - **Принцип работы:** Когда основная операция завершается с ошибкой, Fallback позволяет выполнить альтернативное действие, которое может быть предопределено.
   - **Использование:** Fallback помогает обеспечить градацию отказа и позволяет системе продолжать функционировать, даже если не удалось выполнить основную операцию.
5. **Bulkhead:**
   - **Описание:** Паттерн Bulkhead помогает изолировать и ограничивать негативное воздействие отказов на другие части системы.
   - **Принцип работы:** Система разделяется на "булкхеды" или отдельные группы ресурсов. Если одна группа ресурсов перегружена или переживает сбой, это не влияет на работу других групп.
   - **Использование:** Bulkhead помогает предотвратить "каскадные" отказы, при которых сбой в одной части системы может привести к сбоям в других частях.
6. - **Graceful Degradation** - концепция в разработке и дизайне систем, где система обладает способностью продолжать функционировать с пониженным уровнем производительности или функциональности без краха. Вот ключевые аспекты:
     - **Постепенное снижение функциональности:** Система постепенно снижает свои функции в случае сбоев или недоступности определенных ресурсов, чтобы сохранить работоспособность.
     - **Приоритизация:** Система определяет критически важные функции и сохраняет их работоспособность, даже если другие функции снижаются.
     - **Информирование пользователя:** Пользователи информируются о снижении производительности или доступности функций, чтобы принимать информированные решения.
     - **Работоспособность в ограниченных режимах:** Система продолжает предоставлять базовые функции даже при ограниченной производительности.
     - **Постепенное восстановление:** После устранения проблем система постепенно восстанавливает нормальную функциональность.