# Вы не знаете JS: This и Прототипы Объектов
# Глава 1: `this` (этот) или That (тот)?

Одним из наиболее запутанных механизмов в Javascript является ключевое слово `this`. Это специальное ключевое слово идентификатор, которое автоматически определяется внутри области видимости каждой функции, но то, к чему именно оно относится, сбивает с толку даже опытных JavaScript-разработчиков.

> Любая достаточно продвинутая технология неотличима от магии. -- Артур Си. Клэрк

Механизм `this` Javascript на самом деле не такой уж и продвинутый, но разработчики часто перефразируют эту цитату вставив "сложный" или "сбивающий с толку", и совершенно понятно, что без четкого понимания это может казаться совершенно магическим в вашем понимании.

**Примечание:** Слово "this" — это достаточно распространенное местоимение в общих беседах. Поэтому, может быть очень сложно, особенно на словах, определить используем мы "this" как местоимение или же используем его, чтобы ссылаться на данное ключевое слово. Для ясности, я всегда буду использовать `this` для ссылки на специальное ключевое слово, а "this" или *this* или this в остальных случаях.

## Зачем нужен `this`?

Раз механизм `this` такой запутанный даже для опытных JavaScript-разработчиков, можно задаться вопросом, а точно ли он полезный? Может у него больше недостатков, чем достоинств?
Перед тем, как перейти к тому *как он работает*, мы должны проанализировать *зачем он нужен*.

Давайте попытаемся проиллюстрировать мотивацию и полезность механизма `this`:

```js
function identify() {
	return this.name.toUpperCase();
}

function speak() {
	var greeting = "Hello, I'm " + identify.call( this );
	console.log( greeting );
}

var me = {
	name: "Kyle"
};

var you = {
	name: "Reader"
};

identify.call( me ); // KYLE
identify.call( you ); // READER

speak.call( me ); // Hello, I'm KYLE
speak.call( you ); // Hello, I'm READER
```

Если то, *как работает* этот фрагмент кода путает вас, не волнуйтесь! Мы скоро вернемся к этому. Просто отложите ваши вопросы в сторону, чтобы мы могли более четко взглянуть на то, *зачем* это нужно.

Этот фрагмент кода позволяет функциям `identify()` и `speak()` быть переиспользованными с разными объектами *контекста* (`me` и `you`), а не требовать новой версии функции для каждого объекта.

Вместо того, чтобы полагаться на `this`, вы могли бы явно передать *объект контекста* функциям `identify()` и `speak()`.

```js
function identify(context) {
	return context.name.toUpperCase();
}

function speak(context) {
	var greeting = "Hello, I'm " + identify( context );
	console.log( greeting );
}

identify( you ); // READER
speak( me ); // Hello, I'm KYLE
```

Однако, механизм `this` предоставляет более элегантный путь, неявно "передавая" ссылку на объект, что приводит к чистому дизайну API и облегчению повторного переиспользования.

Чем сложнее будет используемый вами паттерн, тем более ясно вы увидите, что указание контекста явным параметром часто запутаннее, чем неявное указание контекста `this`. Когда мы изучим объекты и прототипы, вы увидите полезность коллекции функций, которые способны автоматически ссылаться на правильный объект контекста.

## Заблуждения

Мы скоро объясним как `this` *на самом деле* работает, но сначала мы должны рассеять несколько заблуждений о том, как он *на самом деле не* работает.

Имя "this" создает заблуждение, когда разработчики пытаются думать о нем слишком буквально. Есть два часто предполагаемых значения, но оба являются неверными.

### Сама функция

Первый общий соблазн это предполагать, что `this` ссылается на саму функцию. Это, как минимум, резонное грамматическое заключение.

Но зачем вы бы хотели ссылаться на функцию из неё же? Наиболее распространенной причиной может быть такая вещь как рекурсия (вызов функции внутри себя) или чтобы назначить обработчик события, который сможет отписаться, когда впервые будет вызван.

Разработчики, незнакомые с механизмами JavaScript, часто думают, что ссылка на функцию как на объект (все функции в JavaScript являются объектами!) позволяет хранить состояния (значения в свойствах) между вызовами функций. Хотя это, конечно, возможно, но это имеет некоторые ограничения в использовании, остаток книги будет повествовать о многих других шаблонах для *лучшего* хранения состояния, чем объект функции.

Но для начала мы используем этот шаблон, чтобы проиллюстрировать как `this` не дает функции получить ссылку на саму себя, как мы могли бы предположить.

Рассмотрим следующий код, где мы попытаемся отследить сколько раз функция (`foo`) была вызвана:

```js
function foo(num) {
	console.log( "foo: " + num );

	// Отслеживаем сколько раз `foo` была вызвана
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// Сколько раз была вызвана `foo`?
console.log( foo.count ); // 0 -- WTF?
```

`foo.count` *до сих пор* равен `0`, даже не смотря на то, что 4 инструкции `console.log` очевидно показывают, что `foo(..)` на самом деле была вызвана 4 раза. Разочарование происходит от *слишком буквального* толкования того, что означает `this` (в `this.count++`).

Когда код выполняет команду `foo.count = 0`, он на самом деле добавляет свойство `count` в объект функции `foo`. Но для ссылки `this.count` внутри функции `this` фактически не указывает на тот же объект функции, и несмотря на то, что имена свойств одинаковые, это разные объекты, вот тут то и начинается неразбериха.

**Примечание:** ответственный разработчик в этом месте должен спросить: "Если я увеличил свойство `count`, но оно не то, которое я ожидал, то какое `count` было мной увеличено?". На самом деле, если он копнет глубже, он обнаружит что случайно создал глобальную переменную `count`(смотрите в главе 2 *как* это произошло!), а её текущим значением является `NaN`. Конечно, после того, как он определит это, у него появится совсем другой ряд вопросов: "почему она стала глобальной и почему она имеет значение `NaN`, вместо правильного значения счетчика?". (см. главу 2).

Вместо того, чтобы остановиться на этом месте и копнуть глубже, чтобы узнать почему ссылка `this` не ведет себя как *ожидалось*, большинство разработчиков просто откладывают проблему целиком и ищут другие решения, например, создают другой объект для хранения свойства `count`:

```js
function foo(num) {
	console.log( "foo: " + num );

	// отслеживаем сколько раз вызывалась `foo`
	data.count++;
}

var data = {
	count: 0
};

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// сколько раз вызывалась `foo`?
console.log( data.count ); // 4
```

Хоть это и верно, что этот подход "решает" проблему, к сожалению, это просто игнорирование реальной проблемы — недостатка понимания того, что значит `this` и как он работает и вместо этого возвращение в зону комфорта более простого механизма: области видимости.

**Примечание:** Области видимости - замечательный и полезный механизм. Я не против использования их любым способом(см. книгу *"Области видимости и замыкания"* из этой серии книг). Но постоянно гадать, как использовать `this`, и, как правило, ошибаться — не лучшая причина возвращаться к областям видимости и никогда не узнать *почему* `this` ускользает от вас.

Для ссылки на объект функции изнутри этой функции, `this` самого по себе обычно бывает недостаточно. Вам обычно нужна ссылка на объект функции через лексический идентификатор (переменную), который указывает на него.

Рассмотрим эти 2 функции:

```js
function foo() {
	foo.count = 4; // `foo` ссылается на саму себя
}

setTimeout( function(){
	// анонимная функция (без имени), не может
	// ссылаться на себя
}, 10 );
```

В первой функции вызывалась "именованная функция", `foo` — это ссылка, которая может быть использована для ссылки на функцию из самой себя.

Но во втором примере функция обратного вызова, передаваемая в `setTimeout(..)`, не имела имени идентификатора (так называемая "анонимная функция"), так что у неё нет правильного пути чтобы обратиться к её объекту.

**Примечание:** Старомодная, но ныне устаревшая и неиспользуемая ссылка `arguments.callee` внутри функции *также* указывает на объект функции, которая в данный момент выполняется. Эта ссылка обычно используется как возможность получить объект анонимной функции изнутри этой функции. Лучший подход, однако, состоит в том, чтобы избежать использования анонимных функций, по крайней мере тех, которые требуют обращения к себе изнутри, и вместо них использовать именованные функции. `arguments.callee` устарела и не должна использоваться.

Таким образом, другое решение нашего примера — это использовать идентификатор `foo` как ссылку на объект функции в каждом месте и вообще не использовать `this`, и это *работает*:

```js
function foo(num) {
	console.log( "foo: " + num );

	// следим, сколько раз вызывается функция
	foo.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// сколько раз `foo` была вызвана?
console.log( foo.count ); // 4
```

Однако, этот подход также является уклонением от фактического понимания `this`, и полностью зависит от области видимости переменной `foo`.

Еще один путь решения проблемы - это заставить `this` действительно указывать на объект функции `foo`:

```js
function foo(num) {
	console.log( "foo: " + num );

	// следим, сколько раз вызывается функция
	// Заметьте: `this` теперь действительно ссылается на `foo`, это основано на том,
	// как `foo` вызывается (см. ниже)
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		// используя `call(..)` мы гарантируем что `this`
		// ссылается на объект функции (`foo`) изнутри
		foo.call( foo, i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// сколько раз `foo` была вызвана?
console.log( foo.count ); // 4
```

**Вместо избегания `this`, мы воспользовались им.** Мы отведем немного времени на то, чтобы объяснить более детально как такие методы работают, так что не волнуйтесь если вы до сих пор недоумеваете как это работает!

### Это область видимости функции

Следующее большое общее заблуждение касательно того, на что указывает `this` - это то, что он каким-то образом ссылается на область видимости функции. Это очень сложный вопрос, потому что с одной стороны так и есть, но с другой это совершенно не так.

Для ясности, `this`, в любом случае, не ссылается на область видимости функции. Это правда, что внутри область видимости имеет вид объекта со свойствами для каждого определенного значения. Но "объект" области видимости не доступен в JavaScript коде. Это внутренняя часть механизма реализации языка (интерпретатора).

Рассмотрим код, который пытается (и безуспешно!) перейти границу и использовать `this` неявно ссылаясь на область видимости функции:

```js
function foo() {
	var a = 2;
	this.bar();
}

function bar() {
	console.log( this.a );
}

foo(); //undefined
```
В этом коде содержится более одной ошибки. Хотя он может казаться надуманным, код который вы видите — это фрагмент из реального практического кода, которым обменивались в публичных форумах сообщества. Это замечательная (если не печальная) иллюстрация того, насколько ошибочным может быть предположение о `this`.

Во-первых, попытка ссылаться на функцию `bar()` как `this.bar()`. Это почти наверняка *случайность*, что это работает, но мы коротко объясним *как* это работает позже. Наиболее естественным путем вызвать `bar()` было бы опустить предшествующий `this.` и просто сделать ссылку на идентификатор.

Однако, разработчик, который писал этот код, пытался использовать `this`, чтобы создать мост между областями видимости `foo()` и `bar()` так, чтобы `bar()` получила доступ к переменной `a` внутри области видимости `foo()`. **Не всякий мост возможен.** Вы не можете использовать ссылку `this`, чтобы найти что-нибудь в области видимости. Это невозможно.

Каждый раз, когда вы чувствуете, что вы смешиваете поиски в области видимости с `this`, напоминайте себе: *это не мост*.

## Что же такое `this`?

Оставив ошибочные предположения, давайте обратим наше внимание на то, как механизм `this` действительно работает.

Мы ранее сказали, что `this` привязывается не во время написания функции, а во время её вызова. Это вытекает из контекста, который основывается на обстоятельствах вызова функции. Привязка `this` не имеет ничего общего с определением функции, но зависит от того при каких условиях функция была вызвана.

Когда функция вызывается, создается запись активации, также известная как контекст вызова. Эта запись содержит информацию о том, откуда функция была вызвана (стэк вызова), *как* функция была вызвана, какие параметры были в неё переданы и т.д. Одним из свойств этой записи является ссылка `this`, которая будет использоваться на протяжении выполнения этой функции.

В следующей главе мы научимся находить **место вызова** функции, чтобы определить как оно связано с определением `this`

## Обзор (TL;DR)

Определение `this` - постоянный источник заблуждений для JavaScript разработчиков, которые не уделяют времени на изучение того, как этот механизм в действительности работает. Гадать, методом проб и ошибок, и слепо копировать код из StackOverflow - неэффективный и неправильный путь использовать этот важный механизм `this`.

Чтобы понять что такое `this`, вам сначала нужно понять чем `this` не является, несмотря на любые предположения или заблуждения, которые могут тянуть вас вниз. `this` — это не ссылка функции на саму себя и это не ссылка на область видимости функции.

В действительности `this` — это привязка, которая создается во время вызова функции, и на *что* она ссылается определяется тем, где и при каких условиях функция была вызвана.

# Вы не знаете JS: *this* и прототипы объектов
# Глава 2: Весь `this` теперь приобретает смысл!

В главе 1 мы отбросили различные ложные представления о `this` и взамен изучили, что привязка `this` происходит при каждом вызове функции, целиком на основании ее **места вызова** (как была вызвана функция).

## Точка вызова

Чтобы понять привязку `this`, мы должны понять что такое точка вызова: это место в коде, где была вызвана функция (**не там, где она объявлена**). Мы должны исследовать точку вызова, чтобы ответить на вопрос: на что же *этот* `this` указывает?

В общем поиск точки вызова выглядит так: "найти откуда вызывается функция", но это не всегда так уж легко, поскольку определенные шаблоны кодирования могут ввести в заблуждение относительно *истинной* точки вызова.

Важно поразмышлять над **стеком вызовов** (стеком функций, которые были вызваны, чтобы привести нас к текущей точке исполнения кода). Точка вызова, которая нас интересует, находится *в* вызове *перед* текущей выполняемой функцией.

Продемонстрируем стек вызовов и точку вызова:

```js
function baz() {
    // стек вызовов: `baz`
    // поэтому наша точка вызова — глобальная область видимости

    console.log( "baz" );
    bar(); // <-- точка вызова для `bar`
}

function bar() {
    // стек вызовов: `baz` -> `bar`
    // поэтому наша точка вызова в `baz`

    console.log( "bar" );
    foo(); // <-- точка вызова для `foo`
}

function foo() {
    // стек вызовов: `baz` -> `bar` -> `foo`
    // поэтому наша точка вызова в `bar`

    console.log( "foo" );
}

baz(); // <-- точка вызова для `baz`
```

Позаботьтесь при анализе кода о том, чтобы найти настоящую точку вызова (из стека вызовов), поскольку это единственная вещь, которая имеет значение для привязки `this`.

**Примечание:** Вы можете мысленно визуализировать стек вызовов посмотрев цепочку вызовов функций в том порядке, в котором мы это делали в  комментариях в коде выше. Но это утомительно и чревато ошибками. Другой путь посмотреть стек вызовов — это использование инструмента отладки в вашем браузере. Во многих современных настольных браузерах есть встроенные инструменты разработчика, включающие JS-отладчик. В вышеприведенном коде вы могли бы поставить точку остановки в такой утилите на первой строке функции `foo()` или просто вставить оператор `debugger;` в первую строку. Как только вы запустите страницу, отладчик остановится в этом месте и покажет вам список функций, которые были вызваны, чтобы добраться до этой строки, каковые и будут являться необходимым стеком вызовов. Таким образом, если вы пытаетесь выяснить привязку `this`, используйте инструменты разработчика для получения стека вызовов, затем найдите второй элемент стека от его вершины и это и будет реальная точка вызова.

## Ничего кроме правил

Теперь обратим наш взор на то, *как* точка вызова определяет на что будет указывать `this` во время выполнения функции.

Вам нужно изучить точку вызова и определить какое из 4 правил применяется. Сначала разъясним каждое из 4 правил по отдельности, а затем проиллюстрируем их порядок приоритета, для случаев когда к точке вызова *могут* применяться несколько правил сразу.

### Привязка по умолчанию

Первое правило, которое мы изучим, исходит из самого распространенного случая вызовов функции: отдельный вызов функции. Представьте себе *это* правило `this` как правило, действующее по умолчанию когда остальные правила не применяются.

Рассмотрим такой код:

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2
```

Первая вещь, которую можно отметить, если вы еще не сделали этого, то, что переменные, объявленные в глобальной области видимости, как например `var a = 2`,  являются синонимами глобальных свойств-объектов с таким же именем. Они не являются копиями друг друга, они и *есть* одно и то же. Представляйте их как две стороны одной монеты.

Во-вторых, видно, что когда вызывается `foo()` `this.a` указывает на нашу глобальную переменную  `a`. Почему? Потому что в этом случае, для `this` применяется *привязка по умолчанию* при вызове функции и поэтому `this` указывает на глобальный объект.

Откуда мы знаем, что здесь применяется *привязка по умолчанию*? Мы исследуем точку вызова, чтобы выяснить как вызывается `foo()`. В нашем примере кода `foo()` вызывается по прямой, необернутой ссылке на функцию. Ни одного из демонстрируемых далее правил тут не будет применено, поэтому вместо них применяется *привязка по умолчанию*.

Когда включен `strict mode`, объект 'global' не подпадает под действие *привязки по умолчанию*, поэтому в противоположность обычному режиму `this` устанавливается в `undefined`.

```js
function foo() {
	"use strict";

	console.log( this.a );
}

var a = 2;

foo(); // TypeError: `this` is `undefined`
```

Едва уловимая, но важная деталь: даже если все правила привязки `this` целиком основываются на точке вызова, глобальный объект подпадает под *привязку по умолчанию* **только** если **содержимое** `foo()` **не** выполняется в режиме `strict mode`; Состояние `strict mode` в точке вызова `foo()` не имеет значения.

```js
function foo() {
	console.log( this.a );
}

var a = 2;

(function(){
	"use strict";

	foo(); // 2
})();
```

**Примечание:** К намеренному смешиванию включения и выключения `strict mode` в коде обычно относятся неодобрительно. Вся программа пожалуй должна быть либо **строгой**, либо **нестрогой**. Однако, иногда вы подключаете сторонние библиотеки, в которых этот режим **строгости** отличается от вашего, поэтому нужно отнестись с вниманием к таким едва уловимым деталям совместимости.

### Неявная привязка

Рассмотрим еще одно правило: есть ли у точки вызова объект контекста, также называемый как владеющий или содержащий объект, хотя *эти* альтернативные термины могут немного вводить в заблуждение.

Рассмотрим:

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2
```

Во-первых, отметим способ, которым была объявлена `foo()`, а затем позже добавлена как ссылочное свойство в `obj`. Независимо от того была ли `foo()` изначально объявлена *в* `obj` или добавлена позднее как ссылка (как в вышеприведенном коде), ни в том, ни в другом случае **функция** на самом деле не "принадлежит" или "содержится" в объекте `obj`.

Однако, точка вызова *использует* контекст `obj`, чтобы **ссылаться** на функцию, поэтому *можно* сказать, что объект `obj` "владеет" или "содержит" **ссылку на функцию** в момент вызова функции.

Какое название вы бы ни выбрали для этого шаблона, в момент когда вызывается  `foo()`, ей предшествует объектная ссылка на `obj`. Когда есть объект контекста для ссылки на функцию, правило *неявной привязки* говорит о том, что именно *этот* объект и следует использовать для привязки `this` к вызову функции.

Поскольку `obj` является `this` для вызова `foo()`, `this.a` — синоним  `obj.a`.

Только верхний/последний уровень ссылки на свойство объекта в цепочке имеет значение для точки вызова. Например:

```js
function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42
```

#### Неявно потерянный

Одним из самых распространенных недовольств, которые вызывает привязка `this` — когда *неявно привязанная* функция теряет эту привязку, что обычно означает что она вернется к *привязке по умолчанию*, либо объекта `global`, либо  `undefined`, в зависимости от режима `strict mode`.

Представим такой код:

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var bar = obj.foo; // ссылка/алиас на функцию!

var a = "ой, глобальная"; // `a` также и свойство глобального объекта

bar(); // "ой, глобальная"
```

Несмотря на то, что `bar` по всей видимости ссылка на `obj.foo`, фактически, это на самом деле другая ссылка на саму `foo`. Более того, именно точка вызова тут имеет значение, а точкой вызова является `bar()`, который является прямым непривязанным вызовом, а следовательно применяется *привязка по умолчанию*.

Более неочевидный, более распространенный и более неожиданный путь получить такую ситуацию когда мы предполагаем передать функцию обратного вызова:

```js
function foo() {
	console.log( this.a );
}

function doFoo(fn) {
	// `fn` — просто еще одна ссылка на `foo`

	fn(); // <-- точка вызова!
}

var obj = {
	a: 2,
	foo: foo
};

var a = "ой, глобальная"; // `a` еще и переменная в глобальном объекте

doFoo( obj.foo ); // "ой, глобальная"
```

Передаваемый параметр — всего лишь неявное присваивание, а поскольку мы передаем функцию, это неявное присваивание ссылки, поэтому окончательный результат будет таким же как в предыдущем случае.

Что если функция, в которую вы передаете функцию обратного вызова, не ваша собственная, а встроенная в язык? Никакой разницы, такой же результат.

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var a = "ой, глобальная"; // `a` еще и переменная в глобальном объекте

setTimeout( obj.foo, 100 ); // "ой, глобальная"
```

Поразмышляйте над этой грубой теоретической псевдо-реализацией `setTimeout()`, которая есть в качестве встроенной в JavaScript-среде:

```js
function setTimeout(fn,delay) {
	// подождать (так или иначе) `delay` миллисекунд
	fn(); // <-- точка вызова!
}
```

Достаточно распространенная ситуация, когда функции обратного вызова *теряют* свою привязку `this`, как мы только что видели. Но еще один способ, которым `this` может удивить нас, когда функция, которой мы передаем нашу функцию обратного вызова, намеренно меняет `this` для этого вызова. Обработчики событий в популярных JavaScript-библиотеках часто любят, чтобы в вашей функции обратного вызова `this` принудительно указывал, например, на DOM-элемент, который вызвал это событие. Несмотря на то, что иногда это бывает полезно, в другое время это может прямо таки выводить из себя. К сожалению, эти инструменты редко дают возможность выбирать.

Каким бы путем ни менялся неожиданно `this`, у вас в действительности нет контроля над тем как будет вызвана ваша функция обратного вызова, таким образом у вас нет возможности контролировать точку вызова, чтобы получить заданную привязку. Мы кратко рассмотрим способ "починки" этой проблемы  *починив* `this`.

### Явная привязка

В случае *неявной привязки*, как мы только что видели, нам требуется менять объект, о котором идет речь, чтобы включить в него функцию и использовать эту ссылку на свойство-функцию, чтобы опосредованно (неявно) привязать `this` к этому объекту.

Но, что если вам надо явно использовать при вызове функции указанный объект для привязки `this`, без помещения ссылки на свойство-функцию в объект?

У "всех" функций в языке есть несколько инструментов, доступных для них (через их `[[Прототип]]`, о котором подробности будут позже), которые могут оказаться полезными в решении этой задачи. Говоря конкретнее, у функций есть методы `call(..)` и `apply(..)` . Технически, управляющие среды JavaScript иногда обеспечивают функции, которые настолько специфичны, что у них нет такой функциональности. Но таких мало. Абсолютное большинство предоставляемых функций и конечно все функции, которые создаете вы сами, безусловно имеют доступ к `call(..)` и `apply(..)`.

Как работают эти инструменты? Они оба принимают в качестве первого параметра объект, который будет использоваться в качестве `this`, а затем вызывают функцию с указанным `this`. Поскольку вы явно указываете какой `this` вы хотите использовать, мы называем такой способ *явной привязкой*.

Представим такой код:

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

Вызов `foo` с *явной привязкой* посредством `foo.call(..)` позволяет нам указать, что `this` будет `obj`.

Если в качестве привязки `this` вы передадите примитивное значение (типа `string`, `boolean` или `number`), то это примитивное значение будет обернуто в свою объектную форму (`new String(..)`, `new Boolean(..)` или `new Number(..)` соответственно). Часто это называют "обертка".

**Примечание:*  * В отношении привязки `this` `call(..)` и `apply(..)` идентичны. Они *по-разному* ведут себя с дополнительными параметрами, но мы не будем сейчас на этом останавливаться.

К сожалению, *явная привязка* сама по себе все-таки не предлагает никакого решения для указанной ранее проблемы "потери" функцией ее привязки `this`, либо оставляет это на усмотрение фреймворка.

#### Жесткая привязка

Но поиграв с вариациями на тему *явной привязки* на самом деле можно получить желаемое. Пример:

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj );
};

bar(); // 2
setTimeout( bar, 100 ); // 2

// `bar` жестко привязывает `this` в `foo` к `obj`
// поэтому его нельзя перекрыть
bar.call( window ); // 2
```

Давайте изучим как работает этот вариант. Мы создаем функцию `bar()`, которая внутри вручную вызывает `foo.call(obj)`, таким образом принудительно вызывая `foo` с привязкой `obj` для `this`. Неважно как вы потом вызовете функцию  `bar`, она всегда будет вручную вызывать `foo` с `obj`. Такая привязка одновременно явная и сильная, поэтому мы называем ее *жесткой привязкой*.

Самый типичный способ обернуть функцию с *жесткой привязкой* — создать сквозную обертку, передающую все параметры и возвращающую полученное значение:

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = function() {
	return foo.apply( obj, arguments );
};

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

Еще один способ выразить этот шаблон — создать переиспользуемую вспомогательную функцию:

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

// простая вспомогательная функция `bind`
function bind(fn, obj) {
	return function() {
		return fn.apply( obj, arguments );
	};
}

var obj = {
	a: 2
};

var bar = bind( foo, obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

Поскольку *жесткая привязка* — очень распространеный шаблон, он есть как встроенный инструмент в ES5: `Function.prototype.bind`, а используется вот так:

```js
function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = foo.bind( obj );

var b = bar( 3 ); // 2 3
console.log( b ); // 5
```

`bind(..)` возвращает новую функцию, в которой жестко задан вызов оригинальной функции с именно тем контекстом `this`, который вы указываете.

**Примечание:** Начиная с ES6, в функции жесткой привязки, выдаваемой `bind(..)`, есть свойство `.name`, наследуемое от исходной *функции*. Например: у `bar = foo.bind(..)` должно быть в `bar.name` значение `"bound foo"`, которое является названием вызова функции, которое должно отражаться в стеке вызовов.

#### "Контексты" в вызовах API

Функции многих библиотек, и разумеется многие встроенные в язык JavaScript и во внешнее окружение функции, предоставляют необязательный параметр, обычно называемый "контекст", который спроектирован как обходной вариант для вас, чтобы не пользоваться `bind(..)`, чтобы гарантировать, что ваша функция обратного вызова использует данный `this`.

Например:

```js
function foo(el) {
	console.log( el, this.id );
}

var obj = {
	id: "awesome"
};

// используем `obj` как `this` для вызовов `foo(..)`
[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome
```

Внутренне эти различные функции почти наверняка используют *явную привязку* через `call(..)` или `apply(..)`, избавляя вас от хлопот.

### Привязка `new`

Четвертое и последнее правило привязки `this` потребует от нас переосмысления самого распространенного заблуждения о функциях и объектах в JavaScript.

В традиционных классо-ориентированных языках, "конструкторы" — это особые методы, связанные с классами, таким образом, что когда создается экземпляр класса с помощью операции `new`, вызывается конструктор этого класса. Обычно это выглядит как-то так:

```js
something = new MyClass(..);
```

В JavaScript есть операция `new` и шаблон кода, который используется для этого, выглядит в основном идентично такой же операции в класс-ориентированных языках; многие разработчики полагают, что механизм JavaScript выполняет что-то похожее. Однако, на самом деле *нет никакой связи* с классо-ориентированной функциональностью у той, что предполагает использование `new` в JS.

Во-первых, давайте еще раз посмотрим что такое "конструктор" в JavaScript. В JS конструкторы — это **всего лишь функции**, которые, так уж получилось, были вызваны с операцией `new` перед ними. Они ни связаны с классами, ни создают экземпляров классов. Они — даже не особые типы функций. Они — всего лишь обычные функции, которые, по своей сути, "украдены" операцией `new` при их вызове.

Например, функция `Number(..)` действует как конструктор, цитируя спецификацию ES5.1:

> 15.7.2 Конструктор Number
>
> Когда Number вызывается как часть выражения new, оно является конструктором: оно инициализирует только что созданный объект.

Так что, практически любая старенькая функция, включая встроенные объектные функции, такие как `Number(..)` (см. главу 3), могут вызываться с `new` перед ними и это превратит такой вызов функции в *вызов конструктора*. Это важное, но едва уловимое различие: нет такой вещи как "функции-конструкторы", а скорее есть вызовы, конструирующие *из* функций.

Когда функция вызывается с указанием перед ней `new`, также известный как вызов конструктора, автоматически выполняются следующие вещи:

1. Создается новенький объект (т.е. конструируется) прямо из воздуха
2. *Только что сконструированный объект связывается с `[[Прототипом]]`*
3. Только что сконструированный объект устанавливается как привязка `this` для этого вызова функции
4. За исключением тех случаев, когда функция возвращает свой собственный альтернативный **объект**, вызов функции с `new` *автоматически* вернет только что сконструированный объект.

Пункты 1, 3 и 4 применимы к нашему текущему обсуждению. Сейчас мы пропустим пункт 2 и вернемся к нему в главе 5.

Взглянем на такой код:

```js
function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2
```

Вызывая `foo(..)` с `new` впереди нее, мы конструируем новый объект и устанавливаем этот новый объект как `this` для вызова `foo(..)`. **Таким образом `new` — единственный путь, которым `this` при вызове функции может быть привязан.** Мы называем это *привязкой new*.

## Всё по порядку

Итак, теперь мы раскрыли 4 правила привязки `this` в вызовах функций. *Всё*, что вам нужно сделать — это найти точку вызова и исследовать ее, чтобы понять какое правило применяется. Но что если к точке вызова можно применить несколько соответствующих правил? Должен быть порядок очередности применения этих правил, а потому далее мы покажем в каком порядке применяются эти правила.

Думаю, совершенно ясно, что *привязка по умолчанию* имеет самый низкий приоритет из четырех. Поэтому мы отложим ее в сторону.

Что должно идти раньше: *неявная привязка* или *явная привязка*? Давайте проверим:

```js
function foo() {
	console.log( this.a );
}

var obj1 = {
	a: 2,
	foo: foo
};

var obj2 = {
	a: 3,
	foo: foo
};

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
```

Итак, *явная привязка* имеет приоритет над *неявной привязкой*, что означает, что вы должны спросить себя применима ли **сначала** *явная привязка* до проверки на *неявную привязку*.

Теперь, нам нужно всего лишь указать куда подходит по приоритету *привязка new*.

```js
function foo(something) {
	this.a = something;
}

var obj1 = {
	foo: foo
};

var obj2 = {};

obj1.foo( 2 );
console.log( obj1.a ); // 2

obj1.foo.call( obj2, 3 );
console.log( obj2.a ); // 3

var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
```

Хорошо, *привязка new* более приоритетна, чем *неявная привязка*. Но как вы думаете: *привязка new* более или менее приоритетна, чем *явная привязка*?

**Примечание:** `new` и `call`/`apply` не могут использоваться вместе, поэтому `new foo.call(obj1)` не корректно, чтобы сравнить напрямую *привязку new* с *явной привязкой*. Но мы все-таки можем использовать *жесткую привязку*, чтобы проверить приоритет этих двух правил.

До того, как мы начнем исследовать всё это на примере кода, постарайтесь вспомнить как физически работает *жесткая привязка*, которая есть в `Function.prototype.bind(..)`, которая создает новую функцию-обертку, и в ней жестко задано игнорировать ее собственную привязку `this` (какой бы она ни была) и использовать указанную вручную нами.

По этой причине, кажется очевидным предполагать, что *жесткая привязка* (которая является формой *явной привязки*) более приоритетна, чем *привязка new*, а потому и не может быть перекрыта действием `new`.

Давайте проверим:

```js
function foo(something) {
	this.a = something;
}

var obj1 = {};

var bar = foo.bind( obj1 );
bar( 2 );
console.log( obj1.a ); // 2

var baz = new bar( 3 );
console.log( obj1.a ); // 2
console.log( baz.a ); // 3
```

Ого! `bar` жестко связан с `obj1`, но `new bar(3)` **не** меняет `obj1.a` на значение `3` что было бы ожидаемо нами. Вместо этого *жестко связанный* (с `obj1`) вызов `bar(..)` ***может*** быть перекрыт с `new`. Поскольку был применен `new`, обратно мы получили новый созданный объект, который мы назвали `baz`, и в результате видно, что в `baz.a` значение `3`.

Это должно быть удивительно с учетом ранее рассмотренной "фальшивой" вспомогательной функции привязки:

```js
function bind(fn, obj) {
	return function() {
		fn.apply( obj, arguments );
	};
}
```

Если вы порассуждаете о том, как работает код этой вспомогательной функции, в нем нет способа для перекрытия жесткой привязки к `obj` операцией `new` как мы только что выяснили.

Но встроенная `Function.prototype.bind(..)` из ES5 — более сложная, даже очень на самом деле. Вот (немного отформатированный) полифиллинг кода, предоставленный со страницы MDN для функции `bind(..)`:

```js
if (!Function.prototype.bind) {
	Function.prototype.bind = function(oThis) {
		if (typeof this !== "function") {
			// наиболее подходящая вещь в ECMAScript 5
			// внутренняя функция IsCallable
			throw new TypeError( "Function.prototype.bind - what " +
				"is trying to be bound is not callable"
			);
		}

		var aArgs = Array.prototype.slice.call( arguments, 1 ),
			fToBind = this,
			fNOP = function(){},
			fBound = function(){
				return fToBind.apply(
					(
						this instanceof fNOP &&
						oThis ? this : oThis
					),
					aArgs.concat( Array.prototype.slice.call( arguments ) )
				);
			}
		;

		fNOP.prototype = this.prototype;
		fBound.prototype = new fNOP();

		return fBound;
	};
}
```

**Примечание:** Полифиллинг `bind(..)`, показанный выше, отличается от встроенной `bind(..)` в ES5, учитывающей функции жесткой привязки, которые используются с `new` (см. ниже почему это может быть полезно). Поскольку полифиллинг не может создавать функцию без `.prototype` так, как это делает встроенная утилита, есть едва уловимый окольный путь, чтобы приблизиться к такому же поведению. Двигайтесь осторожно, если планируете использовать `new` вместе с функцией жесткой привязки и полагаетесь на этот полифиллинг.

Часть, которая позволяет перекрыть `new`:

```js
this instanceof fNOP &&
oThis ? this : oThis

// ... and:

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
```

Мы не будем на самом деле углубляться в объяснения того, как работает эта хитрость (это сложно и выходит за рамки нашего обсуждения), но по сути утилита определяет была ли вызвана или нет функция жесткой привязки с `new` (в результате получая новый сконструированный объект в качестве ее `this`), и если так, то она использует *этот* свежесозданный `this` вместо ранее указанной *жесткой привязки* для `this`.

Почему перекрытие операцией `new` *жесткой привязки* может быть полезным?

Основная причина такого поведения — чтобы создать функцию (которую можно использовать вместе с `new` для конструирования объектов), которая фактически игнорирует *жесткую привязку* `this`, но которая инициализирует некоторые или все аргументы функции. Одной из возможностей `bind(..)` является умение сделать аргументы, переданные после аргумента, привязки `this`,  стандартными аргументами по умолчанию для предшествующей функции (технически называемое "частичным применением", которое является подмножеством "карринга").

Пример:

```js
function foo(p1,p2) {
	this.val = p1 + p2;
}

// используем здесь `null`, т.к. нам нет дела до 
// жесткой привязки `this` в этом сценарии, и она 
// будет переопределена вызовом с операцией `new` в любом случае!
var bar = foo.bind( null, "p1" );

var baz = new bar( "p2" );

baz.val; // p1p2
```

### Определяем `this`

Теперь можно кратко сформулировать правила для определения `this` по точке вызова функции, в порядке их приоритета. Зададим вопросы в том же порядке и остановимся как только будет применено первое же правило.

1. Функция вызвана с `new` (**привязка new**)? Раз так, то `this` — новый сконструированный объект.

   `var bar = new foo()`

2. Функция вызвана с `call` или `apply` (**явная привязка**), даже скрыто внутри *жесткой привязки* в `bind`? Раз так, `this` — явно указанный объект.

   `var bar = foo.call( obj2 )`

3. Функция вызвана с контекстом (**неявная привязка**), иначе называемым как владеющий или содержащий объект? Раз так, `this` является *тем самым* объектом контекста.

   `var bar = obj1.foo()`

4. В противном случае, будет `this` по умолчанию (**привязка по умолчанию**). В режиме `strict mode`, это будет `undefined`, иначе будет объект `global`.

   `var bar = foo()`

Вот и всё. Вот *всё, что нужно*, чтобы понимать правила привязки `this` для обычных вызовов функций. Ну... почти.

## Исключения привязок

Как обычно, из "правил" есть несколько *исключений*.

Поведение привязки `this` в некоторых сценариях может быть неожиданным, там где вы подразумеваете одну привязку, а получаете в итоге поведение привязки по правилу *привязки по умолчанию* (см. ранее).

### Проигнорированный `this`

Если вы передаете `null` или `undefined` в качестве параметра привязки `this` в `call`, `apply` или `bind`, то эти значения фактически игнорируются, а взамен к вызову применяется правило *привязки по умолчанию*.

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo.call( null ); // 2
```

Зачем вам бы понадобилось намеренно передавать что-то подобное `null` в качестве привязки `this`?

Довольно распространено использовать `apply(..)` для распаковки массива значений в качестве параметров вызова функции. Аналогично и `bind(..)` может каррировать параметры (предварительно заданные значения), что может быть очень полезно.

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// распакуем массив как параметры
foo.apply( null, [2, 3] ); // a:2, b:3

// каррируем с помощью `bind(..)`
var bar = foo.bind( null, 2 );
bar( 3 ); // a:2, b:3
```

Обa этих инструмента требуют указания привязки `this` в качестве первого параметра. Если рассматриваемым функциям не важен `this`, то вам нужно -значение-заменитель, и `null` — это похоже разумный выбор, как мы видели выше.

**Примечание:** В этой книге мы не уделим этому внимания, но в ES6 есть операция расширения `...`, которая дает возможности синтаксически "развернуть" массив как параметры без необходимости использования `apply(..)`, например как в `foo(...[1,2])`, что равносильно `foo(1,2)` — синтаксически избегая привязки `this`, раз она не нужна. К сожалению, в ES6 нет синтаксической замены каррингу, поэтому параметр `this` вызова `bind(..)` все еще требует внимания.

Однако, есть некоторая скрытая "опасность" в том, чтобы всегда использовать `null`, когда вам не нужна привязка `this`. Если вы когда-нибудь воспользуетесь этим при вызове функции (например, функции сторонней библиотеки, которой вы не управляете) и эта функция *все-таки* воспользуется ссылкой на `this`, сработает правило *привязки по умолчанию*, что повлечет за собой ненамеренно ссылку (или еще хуже, мутацию!) на объект `global` (`window` в браузере).

Очевидно, что такая ловушка может привести к ряду *очень трудно* диагностируемых/отслеживаемых ошибок.

#### Более безопасный `this`

Пожалуй в некоторой степени "более безопасная" практика — передавать особым образом настроенный объект для `this`, который гарантирует отсутствие побочных эффектов в вашей программе. Заимствуя терминологию из сетевых (и военных) технологий, мы можем создать объект "DMZ" (демилитаризованной зоны (de-militarized zone)) — не более чем полностью пустой, неделегированный (см. главы 5 и 6) объект.

Если всегда передавать DMZ-объект для привязок `this`, которые не требуются, то мы можем быть уверены в том, что любое скрытое/неожидаемое использование `this` будет ограничено пустым объектом, который защитит объект `global` нашей программы от побочных эффектов.

Поскольку этот объект совершенно пустой, лично я люблю давать его переменной имя `ø` (математический символ пустого множества в нижнем регистре). На многих клавиатурах (как например US-раскладка на Mac), этот символ легко можно ввести с помощью `⌥`+`o` (option+`o`). В некоторых системах есть возможность назначать горячие клавиши на определенные символы. Если вам не нравится символ `ø` или на вашей клавиатуре сложно набрать такой символ, вы конечно же можете назвать переменную как вам угодно.

Как бы вы ни назвали ее, самый простой путь получить **абсолютно пустой** объект — это `Object.create(null)` (см. главу 5). `Object.create(null)` — похож на `{ }`, но без передачи `Object.prototype`, поэтому он "более пустой", чем просто `{ }`.

```js
function foo(a,b) {
	console.log( "a:" + a + ", b:" + b );
}

// наш пустой DMZ-объект
var ø = Object.create( null );

// распаковываем массив как параметры
foo.apply( ø, [2, 3] ); // a:2, b:3

// каррируем с помощью `bind(..)`
var bar = foo.bind( ø, 2 );
bar( 3 ); // a:2, b:3
```

Не только функционально "безопаснее", но еще и стилистически выгоднее использовать `ø`, что семантически отражает желание "Я хочу, чтобы `this` был пустым" немного точнее, чем `null`. Но опять таки, называйте свой DMZ-объект как хотите.

### Косвенность

Еще одной вещью, которую нужно опасаться, является создание (намеренно или нет) "косвенных ссылок" на функции, и в этих случаях, когда такая ссылка на функцию вызывается, то также применяется правило *привязки по умолчанию*.

Самый распространенный путь появления *косвенных ссылок* — при присваивании:

```js
function foo() {
	console.log( this.a );
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
(p.foo = o.foo)(); // 2
```

*Результатом* выражения присваивания `p.foo = o.foo` будет всего лишь ссылка  на внутренний объект функции. В силу этого, настоящая точка вызова - это просто `foo()`, а не `p.foo()` или `o.foo()` как вы могли бы предположить. Согласно вышеприведенным правилам будет применено правило *привязки по умолчанию*.

Напоминание: независимо от того как вы добрались до вызова функции используя правило *привязки по умолчанию*, статус **содержимого** вызванной функции в режиме  `strict mode`, использующего ссылку на `this`, а не точка вызова функции, определяет значение *привязки по умолчанию*: либо объект `global` если не в `strict mode` или `undefined` в `strict mode`.

### Смягчение привязки

Ранее мы отметили, что *жесткая привязка* была одной из стратегий для предотвращения случайного действия правила *привязки по умолчанию* при вызове функции, заставив ее привязаться к указанному `this` (до тех пор, пока вы не используете `new`, чтобы переопределить это поведение!). Проблема в том, что *жесткая привязка* значительно уменьшает гибкость функции, не давая указывать `this` вручную, чтобы перекрыть *неявную привязку* или даже последующие попытки *явной привязки*.

Было бы неплохо, если бы был путь указать другое умолчание для *привязки по умолчанию* (не `global` или `undefined`), но при этом оставив возможность для функции вручную привязать `this` через технику *неявной* или *явной* привязки.

Можно собрать инструмент так называемой *мягкой привязки*, который эмулирует желаемое поведение.

```js
if (!Function.prototype.softBind) {
	Function.prototype.softBind = function(obj) {
		var fn = this,
			curried = [].slice.call( arguments, 1 ),
			bound = function bound() {
				return fn.apply(
					(!this ||
						(typeof window !== "undefined" &&
							this === window) ||
						(typeof global !== "undefined" &&
							this === global)
					) ? obj : this,
					curried.concat.apply( curried, arguments )
				);
			};
		bound.prototype = Object.create( fn.prototype );
		return bound;
	};
}
```

Инструмент `softBind(..)`, представленный здесь, работает подобно встроенному  в ES5 инструменту `bind(..)`, за исключением нашего поведения *мягкой привязки*. Он делает обертку указанной функции с логикой, которая проверяет `this` в момент вызова и если это `global` или `undefined`, использует указанное заранее альтернативное *умолчание* (`obj`). В противном случае  `this` остается как есть. Также этот инструмент дает возможность опционального карринга (см. ранее обсуждение`bind(..)`).

Продемонстрируем его в действии:

```js
function foo() {
   console.log("name: " + this.name);
}

var obj = { name: "obj" },
    obj2 = { name: "obj2" },
    obj3 = { name: "obj3" };

var fooOBJ = foo.softBind( obj );

fooOBJ(); // name: obj

obj2.foo = foo.softBind(obj);
obj2.foo(); // name: obj2   <---- смотрите!!!

fooOBJ.call( obj3 ); // name: obj3   <---- смотрите!

setTimeout( obj2.foo, 10 ); // name: obj   <---- возврат к мягкой привяке
```

Для мягкопривязанной версии функции `foo()` можно вручную привязать `this` к `obj2` или `obj3` как показано выше, но он возвращается к `obj` в случае применения *привязки по умолчанию*.

## Лексический `this`

В обычных функциях строго соблюдаются 4 правила, которые мы только что рассмотрели. Но в ES6 представлен особый вид функции, которая не использует эти правила: стрелочная функция.

Стрелочные функции обозначаются не ключевым словом `function`, а операцией `=>`, так называемой "жирной стрелкой". Вместо использования четырех стандартных `this`-правил, стрелочные функции заимствуют привязку `this` из окружающей (функции или глобальной) области видимости.

Проиллюстрируем лексическую область видимости стрелочной функции:

```js
function foo() {
	// возвращаем стрелочную функцию
	return (a) => {
		// Здесь `this` лексически заимствован из `foo()`
		console.log( this.a );
	};
}

var obj1 = {
	a: 2
};

var obj2 = {
	a: 3
};

var bar = foo.call( obj1 );
bar.call( obj2 ); // 2, а не 3!
```

Стрелочная функция, созданная в `foo()`, лексически захватывает любой `this` в `foo()` во время ее вызова. Поскольку в `foo()` `this` был привязан к `obj1`, `bar` (ссылка на возвращаемую стрелочную функцию) также будет с привязкой `this` к `obj1`. Лексическая привязка стрелочной функции не может быть перекрыта (даже с помощью `new`!).

Самый распространенный вариант использования стрелочной функции — обычно при использовании функций обратного вызова, таких как обработчики событий или таймеры:

```js
function foo() {
	setTimeout(() => {
		// Здесь `this` лексически заимствован из `foo()`
		console.log( this.a );
	},100);
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

Несмотря на то, что стрелочные функции предоставляют альтернативу применению `bind(..)` к функции, чтобы гарантировать определенный `this`, что может выглядеть весьма привлекательно, важно отметить, что они фактически запрещают традиционный механизм `this` в пользу более понятной лексической области видимости. До ES6, у нас уже был довольно распространенный шаблон для выполнения такой задачи, который по сути почти неотличим от сущности стрелочных функций ES6:

```js
function foo() {
	var self = this; // лексический захват `this`
	setTimeout( function(){
		console.log( self.a );
	}, 100 );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2
```

В том время как `self = this` и стрелочные функции обе кажутся хорошим "решением" при нежелании использовать `bind(..)`, они фактически убегают от `this` вместо того, чтобы понять и научиться использовать его.

Если вы застали себя пишущим код в стиле `this`, но большую часть или всё время вы сводите на нет механизм `this` с помощью трюков лексической конструкции `self = this` или стрелочной функции, возможно вам следует сделать что-то одно из этого:

1. Использовать только лексическую область видимости и забыть о фальшивости кода в стиле `this`.

2. Полностью научиться использовать механизмы `this`-стиля, включая применение `bind(..)`, где необходимо, и попытаться избегать трюков "лексического this" с помощью `self = this` и стрелочной функции.

Программа может эффективно использовать оба стиля кодирования (лексический и  `this`), но внутри одной и той же функции и, разумеется, при одних и тех же видах поисков переменных, смешивание двух этих механизмов обычно приводит к менее обслуживаемому коду, и возможно будет слишком перегруженным, чтобы выглядеть умным.

## Обзор

Определение привязки `this` для вызова функции требует поиска непосредственной точки вызова этой функции. Как уже выяснилось, к точке вызова могут быть применены четыре правила, в *именно таком* порядке  приоритета:

1. Вызвана с `new`? Используем только что созданный объект.

2. Вызвана с помощью `call` или `apply` (или `bind`)? Используем указанный объект.

3. Вызвана с объектом контекста, владеющего вызовом функции? Используем этот объект контекста.

4. По умолчанию: `undefined` в режиме `strict mode`, в противном случае объект global.

Остерегайтесь случайного/неумышленного вызова с применением правила *привязки по умолчанию*. В случаях, когда вам нужно "безопасно" игнорировать привязку `this`, "DMZ"-объект, подобный `ø = Object.create(null)`, — хорошая замена, защищающая объект `global` от непредусмотренных побочных эффектов.

Вместо четырех стандартных правил привязки стрелочные функции ES6 используют лексическую область видимости для привязки `this`, что означает, что они  заимствуют привязку `this` (какой бы она ни была) от вызова своей окружающей функции. Они по существу являются синтаксической заменой `self = this` в до-ES6 коде.

# Вы не знаете JS: *this* и прототипы объектов
# Глава 3: Объекты

В первых двух главах мы объяснили как `this` указывает на разные объекты, в зависимости от места вызова функции. Но что представляют собой объекты на самом деле, и почему нам нужно указывать на них? Мы подробно рассмотрим объекты в этой главе.

## Синтаксис

Объекты создаются двумя способами: декларативно (литерально) и с помощью конструктора.

Литеральный синтаксис для объекта выглядит так:

```js
var myObj = {
key: value
// ...
};
```

Конструкторная форма выглядит так:

```js
var myObj = new Object();
myObj.key = value;
```

Конструкторная и литеральная формы в результате дают одинаковые объекты. Единственное отличие в том, что в литеральной форме вы можете добавлять сразу несколько пар ключ-значение, в то время как с конструктором вам нужно добавлять свойства по одному.

**Примечание:** Конструкторная форма для создания объектов, показанная выше, используется крайне редко. Почти всегда вы предпочтёте использовать литеральную форму. Это справедливо и для большинства встроенных объектов (смотрите ниже).

## Тип

Объекты -- это основные элементы из которых построена большая часть JS. В JS есть шесть основных типов (в спецификации называются «языковые типы»):

* `string`
* `number`
* `boolean`
* `null`
* `undefined`
* `object`

Обратите внимание, что *простые примитивы* (`string`, `number`, `boolean`, `null`, and `undefined`) сами по себе **не являются** объектами. `null` иногда упоминается как объект, но это заблуждение произошло из ошибки в языке, которая приводит к тому, что `typeof null` ошибочно возвращает `"object"`. По факту, `null` это самостоятельный примитивный тип.

**Есть распространённое заблуждение, что «в JS всё является объектом». Это совсем не так.**

Однако, *есть* несколько специальных подтипов, которые мы можем называть *сложными примитивами*.

`function` -- это подтип объекта (технически, «вызываемый объект»). Говорят, что функции в JS это объекты «первого класса», поскольку в основном они являются обычными объектами и с ними можно работать как с любым другим объектом.

Массивы -- это тоже форма объекта с расширенным поведением. Содержимое массивов организовано более структурировано, чем у обычных объектов.

### Встроенные Объекты

Существует несколько других подтипов объектов, обычно называемых встроенными объектами. Некоторые их названия подразумевают, что они непосредственно относятся к соответствующим простым примитивам. На самом деле, их отношения гораздо сложнее. Скоро мы рассмотрим их подробнее.

* `String`
* `Number`
* `Boolean`
* `Object`
* `Function`
* `Array`
* `Date`
* `RegExp`
* `Error`

Эти подтипы выглядят как настоящие типы или даже классы, если вы полагаетесь на сходство с другими языками вроде класса `String` в Java.

Но в JS это, на самом деле, встроенные функции. Каждая из этих встроенных функций может быть использована как конструктор (ага, вызов функции с оператором `new` -- смотрите Главу 2), а результатом будет новый *сконструированный* объект указанного подтипа. Например:

```js
var strPrimitive = "I am a string";
typeof strPrimitive;	// "string"
strPrimitive instanceof String;	// false
var strObject = new String( "I am a string" );
typeof strObject; // "object"
strObject instanceof String;	// true
// проверим подтип объекта
Object.prototype.toString.call( strObject );	// [object String]
```

В следующей главе мы подробно рассмотрим как именно работает `Object.prototype.toString...`. Вкратце: мы можем проверить внутренний подтип, заимствовав базовый стандартный метод `toString()`. Как видите, он показывает, что этот `strObject` -- на самом деле объект, созданный конструктором `String`.

Значение примитива «I am a string» это не объект, а литерал примитива, и его значение иммутабельно. Чтобы выполнять над ним операции вроде проверки длины, доступа к содержимому символов и т. д. требуется объект `String`.

К счастью, при необходимости язык автоматически приводит примитив `"string"` к объекту `String`, а значит, вам почти никогда не придется дополнительно создавать форму Объекта. Большая часть сообщества JS **настоятельно рекомендует** по возможности использовать литеральную форму вместо конструкторной формы.

Рассмотрим:

```js
var strPrimitive = "I am a string";
console.log( strPrimitive.length );	// 13
console.log( strPrimitive.charAt( 3 ) );	// "m"
```

В обоих случаях мы вызываем свойство или метод строчного примитива и движок автоматически преобразует его к объекту `String`, так что свойство/метод работают.

Такое же преобразование происходит между численным литеральным примитивом `42` и обёрткой объекта `new Number(42)` при использовании методов вроде `42.359.toFixed(2)`. То же самое и с объектом `Boolean` из примитива `"boolean"`.

`null` и `undefined` не имеют формы Объекта, только значения их примитивов. Для примера, значения `Date` могут быть созданы *только* с помощью их конструкторной формы объекта, так как у них нет соответствующей литеральной формы.

`Object`, `Array`, `Function`, и `RegExp` (регулярные выражения) -- это объекты, не зависимо от того, используется литеральная или конструкторная форма. Конструкторная форма в некоторых случаях предлагает больше опций для создания, чем литеральная. Поскольку объекты создаются в любом случае, простая литеральная форма почти универсальна. **Используйте конструкторную форму только если вам нужны дополнительные опции.**

Объекты `Error` редко создаются в коде в явном виде. Обычно они создаются автоматически, когда появляются исключения. Они могут быть созданы с помощью конструкторной формы `new Error(..)`, но обычно в этом нет необходимости.

## Содержимое

Как мы упоминали ранее, содержимое объекта состоит из значений (любого типа), которые хранятся в специально названных *местах*, которые мы называем свойствами.

Важно отметить, что когда мы говорим о «содержимом» и подразумеваем, что эти значения хранятся прямо внутри объекта, то это лишь абстракция. Движок хранит значения в зависимости от его реализации и может запросто не хранить их *внутри* какого-нибудь контейнера объекта. Что *действительно* хранится в контейнере, так это названия свойств, которые работают как указатели (технически, *ссылаются*) туда, где хранятся значения.

Рассмотрим:

```js
var myObject = {
    a: 2
};
myObject.a;	    // 2
myObject["a"];	// 2
```

Чтобы получить значение по *адресу* `a` в `myObject` мы должны использовать либо оператор `.` либо оператор `[]`. Синтаксис `.a` обычно описывают как доступ к «свойству», а синтаксис `["a"]` называют доступ по «ключу». В реальности они оба обращаются по одному *адресу* и выведут одно и то же значение `2`, так что эти термины взаимозаменяемы. Далее мы будем использовать наиболее общий термин «доступ к свойству».

Основное различие между двумя синтаксисами в том, что оператор `.` требует, чтобы после него шло название свойства, совместимое с `Идентификатором`, в то время как синтаксис `[".."]` может принять в качестве имени свойства любую строку, совместимую с UTF-8/unicode.

Также, поскольку синтаксис `[".."]` использует **значение** строки для указания адреса, можно программно сгенерировать значение этой строки, например, так:

```js
var wantA = true;
var myObject = {
    a: 2
};
var idx;
if (wantA) {
    idx = "a";
}
// позже
console.log( myObject[idx] ); // 2
```

В объектах названия свойств **всегда** являются строкой. Если вы используете в качестве свойств любые другие значения кроме `string` (примитив), они будут сконвертированы в строку. Это относится и к числам, которые обычно используют как индексы массивов. Так что будьте осторожны и не путайте использование чисел в объектах и массивах.

```js
var myObject = { };
myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";
myObject["true"];	            // "foo"
myObject["3"];	                // "bar"
myObject["[object Object]"];	// "baz"
```

### Вычисляемые имена свойств

Описанный выше синтаксис доступа к свойствам вида `myObject[..]` полезен, когда необходимо использовать результат выражения *в качестве* ключа, вроде `myObject[prefix + name]`. Но он не сильно помогает при объявлении объектов через объектно-литеральный синтаксис.

ES6 добавляет *вычисляемые имена свойств*, где можно указать выражение, обрамленное `[ ]`, в качестве пары ключ-значение при литеральном объявлении объекта:

```js
var prefix = "foo";
var myObject = {
    [prefix + "bar"]: "hello",
    [prefix + "baz"]: "world"
};
myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

Наиболее распространённым, вероятно, будет использование *вычисляемых имен свойств* для `Symbol` в ES6, которые не будут подробно рассматриваться в этой книге. Вкратце, это новый примитивный тип данных, значение которого непрозрачно и неопределимо (технически, это значение -- `string`). Вы будете сильно озадачены, работая с *действительным значением* `Symbol` (которое теоретически может быть разным в разных движках JS), поэтому вы будете использовать имя Символа, вроде `Symbol.Something` (просто выдуманное имя!):

```js
var myObject = {
    [Symbol.Something]: "hello world"
};
```

### Свойство против Метода

Если разговор идет о доступе к свойству объекта, некоторые разработчики считают, что есть различие, если запрашиваемое значение является функцией.

Интересно, что *спецификация делает такое же различие*.

Технически функции никогда не «относились» к объектам, поэтому утверждение, что функция, к которой обратились через объект автоматически становится «методом» похоже на растягивание семантики.

Это *правда*, что в некоторых функциях есть указание на `this` и *иногда* использование `this` связано с указанием на объект в точке вызова. Но такое использование не делает эту функцию более «методной», чем другую, поскольку `this` привязывается динамически во время вызова в точке вызова, и поэтому его отношение к объекту в лучшем случае косвенное.

Каждый раз, когда вы запрашиваете свойство объекта, это **обращение к свойству**, вне зависимости от типа значения, которое вы получаете. Если *вдруг* вы получите в результате обращения к этому свойству функцию, она не превратится волшебным образом в «метод». Нет ничего особенного в том, что функция выводится при обращении к свойству (кроме возможной неявной привязки `this`, как было описано ранее).

Например:

```js
function foo() {
    console.log( "foo" );
}
var someFoo = foo;	// переменная указывает на `foo`
var myObject = {
    someFoo: foo
};
foo;	            // function foo(){..}
someFoo;	        // function foo(){..}
myObject.someFoo;	// function foo(){..}
```

`someFoo` и `myObject.someFoo` это лишь две разных ссылки на одну функцию, и ни одна из них не подразумевает, что функция является особенной или «принадлежит» какому-то другому объекту.

**Возможно, кто-то возразит**, что функция *становится методом* не в момент объявления, а в процессе выполнения конкретного вызова, в зависимости от того, как она была вызвана и точки ее вызова (в контексте ссылки на объект или нет -- подробнее смотрите в Главе 2). Даже такая интерпретация выглядит притянутой за уши.

Возможно, самым безопасным выводом будет такой: «функция» и «метод» взаимозаменяемы в JavaScript.

**Примечание:** ES6 добавляет указатель `super`, который обычно используется вместе с `class` (см. Приложение А). То, как работает `super` (статическая привязка вместо поздней привязки в виде `this`) прибавляет весомости идее, что функция, которую привязывает `super` больше похожа на «метод», чем на «функцию». Но опять же, это лишь тонкие нюансы семантики (и механики).

Даже если вы объявляете функциональное выражение как часть литерала объекта, эта функция не становится волшебным образом более привязанной к объекту -- это по-прежнему лишь несколько указателей на ту же функцию.

```js
var myObject = {
    foo: function foo() {
    console.log( "foo" );
}
};
var someFoo = myObject.foo;
someFoo;	    // function foo(){..}
myObject.foo;	// function foo(){..}
```

**Примечание**: В Главе 6 мы рассмотрим сокращенный синтаксис ES6 для `foo: function foo(){ .. }` в нашем литерале объекта.

### Массивы

Массивы тоже используют для доступа форму `[ ]`, но, как упоминалось ранее, имеют более структурированную организацию того, как хранятся значения (хотя всё еще без ограничений *типов* хранимых значений). Массивы предполагают *числовую индексацию*. Это означает, что значения хранятся в местах, обычно называемых *индексами*, с неотрицательными целыми числами, вроде `0` и `42`.

```js
var myArray = [ "foo", 42, "bar" ];
myArray.length;	// 3
myArray[0];	    // "foo"
myArray[2];	    // "bar"
```

Массивы -- *это* объекты, поэтому даже если каждый индекс является положительным целым числом, вы можете *также* добавить свойства массива:

```js
var myArray = [ "foo", 42, "bar" ];
myArray.baz = "baz";
myArray.length;	// 3
myArray.baz;	// "baz"
```

Обратите внимание, что добавление именованных свойств (не зависимо от синтаксиса `.` или `[ ]`) не влияет на выводимый результат свойства `length`.

Вы можете использовать массив как простой объект вида ключ/значение и не добавлять числовые индексы, но это плохая идея, поскольку у массивов есть особенное поведение и оптимизации, заточенные для их использования; то же самое и с обычными объектами. Используйте объекты для хранения пар ключ/значение, а массивы для хранения значений с числовыми индексами.

**Осторожно**: Если вы попытаетесь добавить свойство к массиву, но имя свойства *выглядит* как число, оно добавится в виде числового индекса (таким образом изменится содержимое массива):

```js
var myArray = [ "foo", 42, "bar" ];
myArray["3"] = "baz";
myArray.length;	// 4
myArray[3];	    // "baz"
```

### Дублирование Объектов

Один из наиболее распространенных вопросов для разработчиков JavaScript, которые только знакомятся с языком, это копирование объекта. Казалось бы, должен быть простой встроенный метод `copy()`, верно? Оказывается, всё немного сложнее, потому что изначально не до конца понятно каким должен быть алгоритм для создания дубликата.

Для примера рассмотрим этот объект:

```js
function anotherFunction() { /*..*/ }
var anotherObject = {
    c: true
};
var anotherArray = [];
var myObject = {
    a: 2,
    b: anotherObject,	// ссылка, а не копия!
    c: anotherArray,	// еще одна ссылка!
    d: anotherFunction
};
anotherArray.push( anotherObject, myObject );
```

Как же на самом деле должна выглядеть *копия* объекта `myObject`?

Во-первых, мы должны решить будет это *поверхностная* или *глубокая* копия? Результатом *поверхностного копирования* в новом объекте будет свойство `a` в виде копии значения `2`, но свойства `b`, `c`, и `d` -- лишь в виде ссылки на те же места, что и в оригинальном массиве. *Глубокая копия* продублирует не только `myObject`, но и `anotherObject` и `anotherArray`. Но тогда у нас будет проблема с тем, что `anotherArray` содержит ссылки на `anotherObject` и `myObject`, так что их тоже нужно скопировать вместо того чтобы сохранять ссылку. Теперь у нас есть проблема бесконечного дублирования из-за зацикленности ссылок.

Должны ли мы выявлять цикличные ссылки и просто прерывать цикличный обход (оставляя глубокие элементы не до конца  продублированными)? Может просто вывести ошибку? Или что-то среднее?

Более того, не до конца ясно, что будет означать *дублирование* функции. Существует несколько хаков, вроде вытягивания исходного кода функции через `toString()` (которые варьируются в разных реализациях и даже не являются надежными для всех движков, в зависимости от типа проверяемой функции)

Так как же нам решить все эти каверзные вопросы? Различные фреймворки имеют свои собственные интерпретации и решения. Но какое из них (если такое имеется) должен принять JS в качестве *стандартного*? Долгое время не было четкого ответа.

Одно из решений заключается в том, что объекты безопасные для JSON (то есть те, которые можно преобразовать в строку JSON и распарсить с теми же значениями и структурой) могут быть легко продублированы с помощью:

```js
var newObj = JSON.parse( JSON.stringify( someObj ) );
```

Конечно, для этого вам нужно убедиться, что ваш объект безопасен для JSON. В некоторых ситуациях это элементарно. В других этого недостаточно.

В то же время, поверхностное копирование достаточно понятно и имеет меньше проблем, поэтому в ES6 для этой задачи есть `Object.assign(..)`. `Object.assign(..)` принимает *целевой* объект в качестве первого параметра, а также один или более *исходных* объектов в качестве последующих параметров. Он проходит по всем *перечисляемым* (см. ниже), *собственным ключам* (**существующим непосредственно**) в *исходном* объекте(тах) и копирует их (только через присваивание `=`) в *целевой* объект. Кроме того, удобно, что он возвращает *целевой* объект, как показано ниже:


```js
var newObj = Object.assign( {}, myObject );
newObj.a;	                    // 2
newObj.b === anotherObject;	    // true
newObj.c === anotherArray;	    // true
newObj.d === anotherFunction;	// true
```

**Примечание:** В следующем разделе мы опишем «дескрипторы свойств» (характеристики свойств) и покажем использование `Object.defineProperty(..)`. Как бы то ни было, дублирование, которое имеет место в `Object.assign(..)` это чистое присваивание в стиле `=`, так что любые особенные характеристики свойств (вроде `writable`) исходного объекта *не сохраняются* в целевом объекте.

### Дескрипторы свойств

Вплоть до ES5 язык JavaScript не давал вашему коду напрямую проверить или описать различия между характеристиками свойств: например, узнать доступно ли свойство только для чтения или нет.

Но в ES5 все свойства описываются с помощью **дескриптора свойств**.

Рассмотрим такой код:

```js
var myObject = {
    a: 2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
```

Как видно, дескриптор свойства (называемый «дескриптором данных», поскольку он хранит только значение данных) для нашего обычного свойства `a` это больше чем просто его `value`, равное `2`.

Поскольку мы знаем значения по умолчанию для характеристик дескриптора свойств при создании обычного свойства, мы можем использовать `Object.defineProperty(..)` для добавления нового или изменения существующего свойства (если оно является `configurable`!) с желаемыми характеристиками.

Например:


```js
var myObject = {};
Object.defineProperty( myObject, "a", {
    value: 2,
    writable: true,
    configurable: true,
    enumerable: true
} );
myObject.a; // 2
```

С помощью `defineProperty(..)` мы вручную добавили простое, обычное свойство `a` к объекту `myObject` в явном виде. Как бы то ни было, в общем случае вам не придется использовать ручной способ, пока вы не захотите изменить обычное поведение характеристик дескриптора.

#### Перезаписываемое

Возможность изменить значение свойства контролируется характеристикой `writable`.

Рассмотрим:

```js
var myObject = {};
Object.defineProperty( myObject, "a", {
    value: 2,
    writable: false, // не перезаписываемо!
    configurable: true,
    enumerable: true
} );
myObject.a = 3;
myObject.a;         // 2
```

Как видите, наша попытка модифицировать `value` не удалась, при этом мы не получили никакого уведомления об этом. В строгом режиме `strict mode` мы получим ошибку:

```js
"use strict";
var myObject = {};
Object.defineProperty( myObject, "a", {
    value: 2,
    writable: false, // не перезаписываемо!
    configurable: true,
    enumerable: true
} );
myObject.a = 3;     // TypeError
```

`TypeError` говорит о том, что мы не можем изменить неперезаписываемое свойство

**Примечание**: Мы скоро обсудим геттеры и сеттеры, но вкратце, вы можете заметить, что `writable:false` означает, что значение нельзя изменить. Это отчасти равносильно указанию NOOP-сеттера. На самом деле, чтобы действительно соответствовать `writable:false` ваш NOOP-сеттер при вызове должен выдавать `TypeError`.

#### Конфигурируемое

Пока свойство является конфигурируемым, мы можем изменять описание дескриптора, используя всё тот же инструмент `defineProperty(..)`.

```js
var myObject = {
    a: 2
};
myObject.a = 3;
myObject.a;	// 3
Object.defineProperty( myObject, "a", {
    value: 4,
    writable: true,
    configurable: false,	// не конфигурируемо!
    enumerable: true
} );
myObject.a;	// 4
myObject.a = 5;
myObject.a;	// 5
Object.defineProperty( myObject, "a", {
    value: 6,
    writable: true,
    configurable: true,
    enumerable: true
} );        // TypeError
```

Последний вызов `defineProperty(..)` приводит к ошибке TypeError, вне зависимости от `strict mode`, если вы пытаетесь изменить значение дескриптора неконфигурируемого свойства. Осторожно: как видите, изменение `configurable` на `false` необратимо и его нельзя отменить.

**Примечание**: существует особенное исключение, о котором стоит помнить: если для свойства уже задано `configurable:false`, то `writable` может быть изменено с `true` на `false` без ошибки, но не обратно в `true` если оно уже `false`.

А еще `configurable:false` препятствует возможности использовать оператор `delete` для удаления существующего свойства.

```js
var myObject = {
    a: 2
};
myObject.a;     // 2
delete myObject.a;
myObject.a;     // undefined
Object.defineProperty( myObject, "a", {
    value: 2,
    writable: true,
    configurable: false,
    enumerable: true
} );
myObject.a;     // 2
delete myObject.a;
myObject.a;     // 2
```

Как видите, последний вызов `delete` не удался (без уведомления), потому что мы сделали свойство `a` неконфигурируемым.

`delete` используется только для удаления свойств объекта (которое может быть удалено) напрямую из указанного объекта. Если свойство объекта -- это последняя оставшаяся *ссылка* на некоторый объект/функцию и вы удаляете его, то ссылка удалится и теперь не имеющий ссылок объект/функция могут быть убраны сборщиком мусора.

#### Перечисляемое

Последнее свойство дескриптора, о котором мы расскажем (есть еще два других, с которыми мы будем иметь дело, когда обсудим геттеры/сеттеры), это `enumerable`.

Возможно, это очевидно из названия, но этот параметр указывает, появится ли свойство в определенных перечислениях свойств объекта, таких как цикл `for..in`. Установите `false`, чтобы свойство не появлялось в подобных перечислениях, даже если оно по-прежнему полностью доступно. Установите `true`, чтобы оно присутствовало.

Все нормальные свойства, заданные пользователем, по умолчанию являются `enumerable`, поскольку обычно это то, что вам нужно. Но если у вас есть особенное свойство, которое вы хотите спрятать от перечислений, установите для него `enumerable:false`.

Мы скоро продемонстрируем перечисляемость более подробно, так что возьмите ее себе на заметку.

### Иммутабельность

Иногда требуется создать свойства или объекты, которые не могут быть изменены (случайно или преднамеренно). ES5 добавляет для работы с этим несколько различных способов с определенными тонкостями.

Важно отметить, что **всё** это -- попытки создать неглубокую иммутабельность. Они влияют только на объект и характеристики его непосредственных свойств. Если объект содержит указатель на другой объект (массив, объект, функцию и т.д.), то *содержимое* другого объекта не будет затронуто и останется изменяемым.

```js
myImmutableObject.foo; // [1,2,3]
myImmutableObject.foo.push( 4 );
myImmutableObject.foo; // [1,2,3,4]
```

В этом фрагменте мы предполагаем, что `myImmutableObject` уже создан и защищен как иммутабельный. Но, чтобы также защитить содержимое `myImmutableObject.foo` (которое само по себе является объектом-массивом), вам также нужно сделать иммутабельным `foo`, используя один или несколько следующих способов.

**Примечание**: Нет ничего страшного в создании глубоко укоренившихся неизменяемых объектов в программах на JS. Особые случаи определённо требуют этого, но в качестве общего шаблона проектирования, если вы обнаружите у себя желание *запечатать* или *заморозить* все объекты, вы можете сделать шаг назад и пересмотреть структуру программы, чтобы сделать её более устойчивой к возможным изменениям в значениях объектов.

#### Константа объекта

Комбинируя `writable:false` и `configurable:false` вы по сути можете создать *константу* (не может быть изменена, переопределенна или удалена) в качестве свойства объекта, вроде:

```js
var myObject = {};
Object.defineProperty( myObject, "FAVORITE_NUMBER", {
    value: 42,
    writable: false,
    configurable: false
} );
```

#### Запрет расширения

Если вы хотите запретить добавление новых свойств объекта, но в то же время оставить существующие свойства нетронутыми, используйте `Object.preventExtensions(..)`


```js
var myObject = {
    a: 2
};
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
```

В `нестрогом режиме`, создание `b` завершится неудачей без ошибок. В `строгом режиме` это приведет к ошибке `TypeError`.

#### Запечатывание

Метод `Object.seal(..)` создает «запечатанный» объект -- то есть принимает существующий объект и, по сути, применяет к нему `Object.preventExtensions(..)`, но также помечает все существующие свойства как `configurable:false`.

Таким образом, вы не можете не только добавлять свойства, но и переконфигурировать или удалить существующие (хотя вы всё еще *можете* изменять их значения).

#### Заморозка

Метод `Object.freeze(..)` создает замороженный объект, что означает, что он принимает существующий объект и по сути применяет к нему `Object.seal(..)`, но также помечает все свойства «доступа к данным» как `writable:false`, так, что их значения не могут быть изменены.

Этот подход дает наивысший уровень иммутабельности, который вы можете получить для самого объекта, поскольку он предотвращает любые изменения в объекте или его непосредственных свойствах (хотя, как сказано выше, содержимое любых других привязанных объектов не затрагивается).

Вы можете «глубоко заморозить» объект, применив `Object.freeze(..)` к объекту и рекурсивно перебрать все объекты, на которые он ссылается (которые еще не были затронуты) применив к ним `Object.freeze(..)`. Однако, будьте осторожны, поскольку это может затронуть другие (общие) объекты, которые вы не планировали менять.

### `[[Get]]`

Есть одна маленькая, но важная деталь, связанная с тем, как происходит доступ к свойствам.

Рассмотрим:

```js
var myObject = {
    a: 2
};
myObject.a; // 2
```

`myObject.a` -- это запрос свойства, но он не *просто* ищет в `myObject` свойство с именем `a`, как может показаться.

Согласно спецификации, код выше выполняет операцию `[[Get]]` (что-то вроде вызова функции `[[Get]]()`) с объектом `myObject`. Стандартная встроенная операция `[[Get]]` проверяет объект на наличие запрашиваемого свойства и, если находит его, то возвращает соответствующее значение.

Однако, в алгоритме `[[Get]]` описано важное поведение для случая, когда она *не* находит запрошенное свойство. В главе 5 мы узнаем что происходит *дальше* (обход по цепочке `[[Prototype]]`, если что).

Но один из важных результатов операции `[[Get]]` заключается в том, что, если она по какой-либо причине не может найти значение запрошенного свойства, то вернёт значение `undefined`.

```js
var myObject = {
    a: 2
};
myObject.b; // undefined
```

Это поведение отличается от случая, когда вы обращаетесь к *переменным* по имени их идентификатора. Если вы запросите переменную, которая не может быть найдена с помощью поиска по лексической области видимости, то результатом будет не `undefined`, как у свойств объекта, а ошибка `ReferenceError`.

```js
var myObject = {
    a: undefined
};
myObject.a; // undefined
myObject.b; // undefined
```

С точки зрения *значения*, нет разницы между этими двумя вызовами -- они оба выдадут `undefined`. Однако внутри операции `[[Get]]`, хоть это и не заметно на первый взгляд, потенциально выполняется немного больше «работы» для вывода `myObject.b`, чем для вывода `myObject.a`.

Проверяя лишь результаты вывода значения, вы не можете отличить когда существует свойство, явно содержащее значение `undefined`, а когда свойство *не* существует и `undefined` -- это значение, по умолчанию возвращаемое, если `[[Get]]` не может вернуть нечто определённое.

### `[[Put]]`

Поскольку существует встроенная операция `[[Get]]` для получения значения свойства, очевидно, должна существовать и стандартная операция `[[Put]]`.

Заманчиво думать, что назначение свойства объекту просто вызовет `[[Put]]`, чтобы задать или создать это свойство для запрашиваемого объекта. Но ситуация сложнее, чем кажется.

Поведение `[[Put]]` при вызове зависит от нескольких факторов, включая (наиболее значимый): существует ли такое свойство у объекта или нет.

Если свойство существует, то алгоритм `[[Put]]` проверит примерно следующее:

1. Является ли свойство дескриптором доступа (смотрите раздел «Геттеры и Сеттеры» ниже)? **Если да, то вызовет сеттер, если он есть.**
2. Является ли свойство дескриптором данных с ключом `writable` равным `false`? **Если да, то тихо завершится в нестрогом режиме [`non-strict mode`], или выдаст ошибку `TypeError` в строгом режиме [`strict mode`].**
3. Иначе, установит значение существующего свойства как обычно.

Если свойство запрашиваемого объекта еще не задано, то операция `[[Put]]` еще более сложная и запутанная. Мы вернемся к этому сценарию в Главе 5, когда обсудим `[[Prototype]]`, чтобы внести больше ясности.

### Геттеры и Сеттеры

Стандартные операции объектов `[[Put]]` и `[[Get]]` полностью контролируют, как значения задаются для существующих или новых свойств и, соответственно, запрашиваются из существующих свойств.

**Примечание**: При использовании будущих/расширенных возможностей языка можно переопределить стандартные операции `[[Get]]` или `[[Put]]` для всего объекта (а не только для свойства). Данная тема выходит за рамки обсуждения этой книги, но будет охвачена позже в серии «Вы не знаете JS».

ES5 представил способ переопределения части этих стандартных операций не на уровне объекта, а на уровне свойств, через использование геттеров и сеттеров. Геттеры -- это свойства, которые, на самом деле, вызывают скрытую функцию для получения значения. Сеттеры -- это свойства, которые, на самом деле, вызывают скрытую функцию для задания значения.

Когда вы задаете свойству геттер или сеттер, оно определяется как «дескриптор доступа» (в противовес «дескриптору данных»). Для дескрипторов доступа, характеристики дескриптора `value` и `writable` игнорируются, а вместо этого JS рассматривает характеристики свойства `set` и `get` (а также `configurable` и `enumerable`).

Рассмотрим:

```js
var myObject = {
    // определяем геттер для `a`
    get a() {
        return 2;
    }
};
Object.defineProperty(
    myObject,	// цель
    "b",	    // имя свойства
    {	// дескриптор
        // определяем геттер для `b`
        get: function(){ return this.a * 2 },
        // убедимся что `b` будет отображаться как свойство объекта
        enumerable: true
    }
);
myObject.a; // 2
myObject.b; // 4
```

Как в объектно-литеральном синтаксисе с использованием `get a() { .. }`, так и с помощью явного определения через `defineProperty(..)` мы создали свойство объекта, которое на самом деле не содержит значение, но доступ к которому приводит к вызову функции-геттера, чьё возвращаемое значение и будет результатом обращения к свойству.

```js
var myObject = {
    // определяем геттер для `a`
    get a() {
        return 2;
    }
};
myObject.a = 3;
myObject.a; // 2
```

Поскольку мы определили геттер для `a`, то если мы попытаемся установить значение `a`, операция не выдаст ошибки, а молча отбросит присваивание. Даже если бы тут был валидный сеттер, в нашем геттере жестко прописано вернуть только `2`, так что операция присваивания будет спорной.

Чтобы сделать этот сценарий более разумным, свойства должны быть заданы с помощью сеттеров, которые переопределяют стандартную операцию `[[Put]]` (известную как присваивание) для каждого свойства, как вы того и ожидали. Скорее всего, вы захотите всегда объявлять и геттер, и сеттер (наличие только одного из них часто приводит к непредсказуемому/удивительному поведению):

```js
var myObject = {
    // определим геттер для `a`
    get a() {
        return this._a_;
    },
    // определим сеттер для `a`
    set a(val) {
        this._a_ = val * 2;
    }
};
myObject.a = 2;
myObject.a; // 4
```

**Примечание**: В этом примере мы на самом деле сохраняем указанное значение присваивания `2` (операция `[[Put]]`) в другой переменной `_a_`. Имя `_a_` здесь чисто для примера и не означает никакого особенного поведения -- это обычное свойство, как и любое другое.

### Существование

Ранее мы показали, что запрос свойства вроде `myObject.a` может вывести значение `undefined`, как в случае, когда там явно задано `undefined`, так и в случае, когда свойство `a` вообще не существует. Если в обоих случаях значение одинаково, как же нам их различить?

Мы можем спросить есть ли у объекта свойство, не запрашивая значение свойства:

```js
var myObject = {
    a: 2
};
("a" in myObject);	            // true
("b" in myObject);	            // false
myObject.hasOwnProperty( "a" );	// true
myObject.hasOwnProperty( "b" );	// false
```

Оператор `in` проверит находится ли свойство `в` объекте или существует ли оно уровнем выше в цепочке `[[Prototype]]` объекта (смотрите Главу 5). `hasOwnProperty(..)` наоборот проверяет есть ли свойство *только* у объекта `myObject` или нет и *не* опрашивает цепочку `[[Prototype]]`. Мы еще вернёмся к важным различиям между этими двумя операциями в Главе 5, когда исследуем `[[Prototype]]` более подробно.

Метод `hasOwnProperty(..)` доступен для всех нормальных объектов через делегирование `Object.prototype` (см. Главу 5). Но можно создать объект, который не привязан к `Object.prototype` (с помощью`Object.create(null)` -- см. Главу 5). В этом случае, вызвать метод `myObject.hasOwnProperty(..)` не получится.

При таком сценарии более надежным способом выполнить подобную проверку будет `Object.prototype.hasOwnProperty.call(myObject,"a")`, который заимствует базовый метод `hasOwnProperty` и использует *явную привязку `this`* (см. Главу 2), чтобы применить его к нашему `myObject`.

**Примечание**: Оператор `in` выглядит так, будто он проверяет существование *значения* внутри контейнера, но, на самом деле, он проверяет существование имени свойства. Это отличие важно учитывать применительно к массивам, поскольку велик соблазн сделать проверку вроде `4 in [2, 4, 6]`, но она не будет вести себя так, как вы ожидали.

#### Перечисление

Ранее мы кратко объяснили идею «перечисляемости», когда рассматривали `enumerable` -- характеристику дескриптора свойства. Давайте вернемся и рассмотрим её более подробно.

```js
var myObject = { };
Object.defineProperty(
    myObject,
    "a",
    // сделаем `a` перечисляемой, как обычно
    { enumerable: true, value: 2 }
);
Object.defineProperty(
myObject,
    "b",
    // сделаем `b` НЕперечисляемой
    { enumerable: false, value: 3 }
);
myObject.b;                     // 3
("b" in myObject);              // true
myObject.hasOwnProperty( "b" ); // true
// .......
for (var k in myObject) {
    console.log( k, myObject[k] );
}
// "a" 2
```

Вы заметите, что `myObject.b` по факту **существует** и имеет доступное значение, но оно не отображается в цикле `for..in` (хотя, внезапно, оно *обнаружилось* проверкой на существование оператором `in`). Всё потому, что по сути «перечислимое» означает «будет учтено, если пройти перебором по свойствам объекта»).

**Примечание**: Использование циклов `for..in` с массивами может выдать неожиданный результат, поскольку перечисление массива будет включать не только все численные индексы, но также перечисляемые свойства. Хорошая идея использовать циклы `for..in` *только* с объектами, а традиционные циклы `for` для перебора по численным индексам значений, хранящихся в массивах.

Еще один способ определить перечисляемые и неперечисляемые свойства:


```js
var myObject = { };
Object.defineProperty(
    myObject,
    "a",
    // сделаем `a` перечисляемым, как обычно
    { enumerable: true, value: 2 }
);
Object.defineProperty(
    myObject,
    "b",
    // сделаем `b` неперечисляемым
    { enumerable: false, value: 3 }
);
myObject.propertyIsEnumerable( "a" );   // true
myObject.propertyIsEnumerable( "b" );   // false
Object.keys( myObject );                // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

`propertyIsEnumerable(..)` проверяет существует ли данное имя свойства *непосредственно* в объекте и установлено ли `enumerable:true`.

`Object.keys(..)` возвращает массив всех перечисляемых свойств, в то время как `Object.getOwnPropertyNames(..)` возвращает массив *всех* свойств -- перечисляемых или нет.

Отличия `in` от `hasOwnProperty(..)` в том, опрашивают ли они цепочку `[[Prototype]]` или нет. В то время как `Object.keys(..)` и `Object.getOwnPropertyNames(..)` проверяют *только* конкретный указанный объект.

Не существует (пока) встроенного способа получить список **всех свойств**, эквивалентного тому, как опрашивает оператор  `in` (перебирая все свойства по всей цепочке `[[Prototype]]`, как описано в Главе 5). Приблизительно, такой инструмент можно сделать, если рекурсивно перебирать цепочку `[[Prototype]]` объекта и на каждом уровне выбирать список из `Object.keys(..)` -- только перечисляемых свойств.

## Итерация

Цикл `for..in` проходит по списку перечисляемых свойств объекта (включая его цепочку `[[Prototype]]`). Но что, если вместо этого вы хотите перебрать именно значения?

В массивах с числовыми индексами перебор значений обычно выполняется стандартным циклом `for`, вроде:

```js
var myArray = [1, 2, 3];
for (var i = 0; i < myArray.length; i++) {
    console.log( myArray[i] );
}
// 1 2 3
```

Это не перебор значений, а перебор индексов, где вы используете индекс для получения значения, наподобие `myArray[i]`.

ES5 добавил несколько вспомогательных итераторов для массивов, включая `forEach(..)`, `every(..)`, и `some(..)`. Каждый из этих помощников принимает функцию обратного вызова для каждого элемента массива. Отличия только в том, как они реагируют на значение, возвращаемое этой функцией.

`forEach(..)` перебирает все значения массива и игнорирует любые значения, возвращаемые функцией обратного вызова. `every(..)` продолжает перебор до конца *или* пока функция не вернёт `false` (или «ложное» значение), в то время как `some(..)` продолжает до конца *или* пока функция не вернёт значение `true` (или «истинное» значение).

Эти специальные возвращаемые значения внутри `every(..)` и `some(..)` действуют наподобие инструкции `break` внутри обычного цикла, поскольку они прекращают перебор задолго до конца.

Если вы перебираете объект циклом `for..in`, вы также лишь косвенно запрашиваете значения, поскольку он, на самом деле, перебирает только перечисляемые свойства объекта, заставляя вас обращаться к свойствам вручную для получения значений.

**Примечание:** В противовес перебору индексов массива в числовой последовательности (циклы `for` или другие итераторы), порядок перебора свойств объекта *не гарантирован* и может различаться в разных движках JS. **Не полагайтесь** на любую наблюдаемую последовательность для всего, что требует постоянства окружения, поскольку любое наблюдаемое ненадежно.

Но что если вместо индексов массива (или свойств объекта) вы хотите перебрать значения напрямую? К счастью, ES6 добавляет синтаксис цикла `for..of` для перебора массивов (и объектов, если объект определяет свой собственный итератор).


```js
var myArray = [ 1, 2, 3 ];
for (var v of myArray) {
    console.log( v );
}
// 1
// 2
// 3
```

Цикл `for..of` запрашивает объект-итератор (из стандартной встроенной функции, на языке спецификации известной как `@@iterator`) у перебираемой сущности, а затем перебирает возвращаемые значения, вызывая метод `next()` объекта-итератора для каждой итерации цикла.

Массивы имеют встроенный `@@iterator`, поэтому `for..of` легко работает с ними, как показано выше. Давайте переберем массив вручную, используя встроенный `@@iterator`, чтобы посмотреть как он работает:

```js
var myArray = [ 1, 2, 3 ];
var it = myArray[Symbol.iterator]();
it.next(); // { value:1, done:false }
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { done:true }
```

**Примечание:** В `@@iterator` мы получаем *внутреннее свойство* объекта, используя `Symbol` из ES6: `Symbol.iterator`. Мы уже упоминали семантику `Symbol` ранее в этой главе (см. «Вычисляемые имена свойств»), здесь применяются те же рассуждения. Как правило, вы захотите обращаться к таким особенным свойствам через имя `Symbol`, а не через специальное значение, которое оно может содержать. Не смотря на подтекст в названии, `@@iterator` является **не объектом-итератором**, а **функцией, возвращающей** объект-итератор -- маленькая, но важная деталь.

Как показывает фрагмент выше, значение, которое возвращает вызов `next()` итератора, -- это объект вида `{ value: .. , done: .. }`, где `value` -- это значение текущей итерации, а `done` -- это `boolean`, показывающее, остались ли элементы для перебора.

Обратите внимание, что значение `3` вернулось вместе с `done:false`, что на первый взгляд может показаться странным. Вам нужно вызвать `next()` четвертый раз (что автоматически делает `for..of` из предыдущего фрагмента) чтобы получить `done:true` и понять, что вы действительно закончили перебор. Причина такого костыля находится за рамками текущего обсуждения, но она исходит из семантики генерирующих функций стандарта ES6.

В то время, как массивы автоматически перебираются циклами `for..of`, обычные объекты **не имеют встроенного `@@iterator`**. Причины такого намеренного упущения намного сложнее чем то, что мы рассмотрим. В общих чертах, правильным было решение не добавлять реализацию, которая будет проблемной для будущих типов объектов.

Для перебора любого объекта *можно* определить свой собственный стандартный `@@iterator`. Например:

```js
var myObject = {
    a: 2,
    b: 3
};
Object.defineProperty( myObject, Symbol.iterator, {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
        var o = this;
        var idx = 0;
        var ks = Object.keys( o );
        return {
            next: function() {
                return {
                    value: o[ks[idx++]],
                    done: (idx > ks.length)
                };
            }
        };
    }
} );
// перебираем `myObject` вручную
var it = myObject[Symbol.iterator]();
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // { value:undefined, done:true }
// перебираем `myObject` с помощью `for..of`
for (var v of myObject) {
    console.log( v );
}
// 2
// 3
```

**Примечание:** Мы использовали `Object.defineProperty(..)` чтобы задать свой `@@iterator` (в основном для того, чтобы сделать его неперечисляемым), но, используя `Symbol` как *рассчитанное имя свойства* (описанное ранее в этой главе), мы могли бы объявить его напрямую, вроде `var myObject = { a:2, b:3, [Symbol.iterator]: function(){ /* .. */ } }`.

Каждый раз, когда цикл `for..of` вызовет `next()` из итератора объекта `myObject`, внутренний указатель переместится и вернёт следующее значение из списка свойств объекта (см. примечание о порядке перебора свойств/значений объекта).

Мы продемонстрировали простой перебор «значение за значением», но вы, конечно, можете задать перебор произвольной сложности для своих структур данных так, как вам будет удобней. Самодельные итераторы вкупе с циклом `for..of` из ES6 -- мощный инструмент для работы с объектами, определяемыми пользователем.

Например, для списка объектов `Pixel` (со значениями координат `x` и `y`) можно упорядочить перебор в зависимости от линейного расстояния до начала координат `(0,0)` или отфильтровать точки, которые расположены «слишком далеко». Пока ваш итератор возвращает предполагаемое `{ value: .. }`, возвращает значения при вызове `next()` и `{ done: true }`, когда перебор завершен, цикл `for..of` стандарта ES6 сможет выполнить перебор.

Фактически, вы можете сгенерировать «бесконечные» итераторы, которые никогда не «завершатся» и всегда будут возвращать новое значение (вроде случайного числа, инкрементированного значения, уникального идентификатора и т.д.), хотя, скорее всего, вы не захотите использовать такие итераторы в неограниченном цикле `for..of`, поскольку он никогда не закончится и повесит вашу программу.

```js
var randoms = {
    [Symbol.iterator]: function() {
        return {
            next: function() {
                return { value: Math.random() };
            }
        };
    }
};
var randoms_pool = [];
for (var n of randoms) {
    randoms_pool.push( n );
    // не продолжаем бесконечно!
    if (randoms_pool.length === 100) break;
}
```

Этот итератор будет генерировать случайные числа «вечно», поэтому мы позаботились о том, чтобы получить только 100 значений, и наша программа не зависла.

## Обзор (TL;DR)

Объекты в JS имеют литеральную форму (вроде `var a = { .. }`) и конструкторную форму (вроде `var a = new Array(..)`). Литеральная форма почти всегда предпочтительнее, но конструкторная форма в некоторых случаях предлагает больше опций при создании.

Многие ошибочно заявляют, что «в JS всё является объектом», но это некорректно. Объекты -- это один из 6 (или 7, в зависимости от ваших взглядов) примитивных типов. Существуют подтипы объектов, в том числе `function`, а также подтипы со специальным поведением, наподобие `[object Array]`, представляющего внутреннее обозначение такого подтипа объекта, как массив.

Объекты -- это коллекции ключ-значение. Значения могут быть получены через свойства, посредством синтаксиса `.propName` или `["propName"]`. Вне зависимости от синтаксиса, движок вызывает встроенную стандартную операцию `[[Get]]` (и `[[Put]]` для установки значений), которая не только ищет свойство непосредственно в объекте, но и перемещается по цепочке `[[Prototype]]` (см. Главу 5), если свойство не найдено.

У свойств есть определенные характеристики, которыми можно управлять через дескрипторы свойств, такие как `writable` и `configurable`. В дополнение, мутабельностью объектов (и их свойств) можно управлять на разных уровнях иммутабельности, используя `Object.preventExtensions(..)`, `Object.seal(..)`, и `Object.freeze(..)`.

Свойства не обязательно содержат значения -- они могут быть также «свойствами доступа» с геттерами/сеттерами. Они могут быть *перечисляемыми* или нет, что влияет на их появление в итерациях цикла, например `for..in`.

Вы также можете перебирать **значения** структур данных (массивов, объектов и т.п.) используя синтаксис ES6 `for..of`, который ищет встроенный или самодельный объект `@@iterator`, содержащий метод `next()` для перебора значений по одному.

# Вы не знаете JS: This и Прототипы Объектов
# Глава 4: Смешивая объекты "классов"

Продолжая исследование объектов, начатое в предыдущей главе, вполне естественно, что теперь мы обратим внимание на «объектно-ориентированное (OO) программирование», с «классами».  Мы рассмотрим «класс-ориентированность» в качестве шаблона проектирования, прежде чем изучать механику «классов»: «создание экземпляров», «наследование» и «(относительный) полиморфизм».

Мы увидим, что эти понятия на самом деле не очень хорошо соотносятся с механизмами работы с объектами в JS (mixins и т. д.), и усилия, которые многие разработчики JavaScript прикладывают, чтобы это преодолеть.

**Примечание:** В этой главе уделяется довольно много внимания (первая половина!) тяжеловесной  теории «объективно-ориентированного программирования». В конце концов, мы свяжем эти идеи с реальным JavaScript кодом во второй половине, где мы поговорим о «миксинах (mixins)». Но рассмотрим много концепций и псевдокода прежде, чем продвинуться вперед, поэтому не теряйтесь - просто потерпите!

## Теория классов

"Классовое наследование" описывает определенный подход к архитектуре и организации кода - способ моделирования реальных проблемных областей в нашем программном обеспечении.

ОО или класс-ориентированное программирование делает акцент на том, что данные в действительности имеют схожее поведение (конечно, разное в зависимости от типа и природы данных!), влияющее на них, поэтому соответствующий дизайн должен упаковать (ака, инкапсулировать) данные и их поведение вместе. В формальной информатике это иногда называют "структурами данных".

Например, некая последовательность символов, представляющая собой слово или фразу, обычно называется "строка". Данными здесь являются символы. Но вам почти никогда не интересны данные, обычно Вы хотите с этими данными *что-то делать*, поэтому все операции, которые могут применяться *к* этим данным (вычисление длины, добавление данных, поиск и т. д.) разработаны как методы класса 'String'.

Любая данная строка просто является экземпляром этого класса, что означает, что это аккуратно собранная упаковка как символьных данных, так и функциональности, которую мы можем к ним применить.

Классы также подразумевают *классификацию* определенной структуры данных. Мы это делаем, воспринимая любую данную структуру как конкретную вариацию более общего базового определения.

Давайте рассмотрим этот процесс "классификации" на часто используемом примере: *автомобиль* можно описать как некую частную реализацию более общего "класса" предметов, называемого *транспортные средства*.

В программном обеспечении мы моделируем данную связь с помощью классов, определяя класс `транспортные средства` и класс `автомобиль`.

Определение `транспортные средства` может включать в себя такие понятия, как силовая установка (ДВС и т. д.), способность перевозить людей, и так далее, все это будет неким поведением класса. Все, что мы определяем в "транспортном средстве", - это принципы, являющиеся общими для всех (или большинства) возможных типов транспортных средств ("самолеты, поезда и автомобили").

Возможно, нет смысла снова и снова переопределять в нашей программе базовую сущность "способности перевозить людей" для каждого типа транспортного средства. Вместо этого мы определим данную возможность один раз в "транспортном средстве", а далее, описывая "автомобиль", мы просто укажем, что он "наследует" (или "расширяет") базовое определение от "транспортного средства". Определение "автомобиля", как говорят, уточняет, общее определение "транспортного средства".

В то время как `транспортное средство` и `автомобиль` определяют поведение посредством методов, данными экземпляра будут такие вещи, как уникальный VIN конкретного автомобиля и т. д.

**Таким образом возникают классы, наследование и создание экземпляров.**

Другим ключевым понятием касательно классов является "полиморфизм", который описывает идею о том, что общее поведение, описанное в родительском классе может быть переопределено в дочернем классе, чтобы придать ему больше конкретики. Фактически, относительный полиморфизм позволяет нам ссылаться на базовое поведение из переопределенного.

Теория классов предполагает, что родительский и дочерний классы разделяют название методов для описания определенного поведения, так что потомок переопределяет родительскую реализацию. Как мы увидим позже, подобные вещи в вашем JavaScript коде могут привести к разочарованию и хрупкости кода.

### Шаблон проектирования "Класс"

Возможно, вы никогда не смотрели на классы как на "шаблон проектирования", так как чаще всего обсуждаются популярные "OO шаблоны проектирования", такие как "итератор", "наблюдатель", "фабрика", "синглтон" и т.д. При этом сразу предполагается, что OO классы являются механизмами более низкого уровня, с помощью которых мы реализуем все шаблоны проектирования (более высокого уровня), как будто OO является единственно-верной основой для *всего* (правильного) кода.

В зависимости от вашего уровня формального образования в области программирования, вы, возможно, слышали о "процедурном программировании" как способе описания кода, который состоит только из процедур (ака, функций), вызывающих другие функции, без каких-либо более высокоуровневых абстракций. Возможно, вас учили, что классы были *правильным* способом преобразования процедурного "спагетти-кода" в хорошо оформленный организованный код.

Конечно, если у вас есть опыт в "функциональном программировании" (монады и др.), вы хорошо знаете, что классы являются лишь одним из нескольких распространенных шаблонов проектирования. Но другие, возможно, впервые спросят себя, а действительно ли классы являются фундаментальной основой для написания кода, или они являются необязательной абстракцией.

Некоторые языки (например, Java) не оставляют вам выбора, поэтому это вовсе не *опционально* - все это класс. Другие языки, такие как C/C++ или PHP, предоставляют вам как процедурные, так и классовые синтаксисы, и больше зависит от выбора разработчика, какой стиль или смесь стилей ему подойдет.

### "Классы" JavaScript

Где JavaScript начинает иметь к этому всему отношение? JS имеет *некоторые* синтаксические элементы, подобные классу (например, `new` и `instanceof`) довольно давно, а в последнее время в ES6 появились некоторые дополнения, такие как ключевое слово `class` (см. приложение A).

Но значит ли это, что в JavaScript действительно *есть* классы? Строго и однозначно: **Нет.**

Поскольку классы являются шаблоном проектирования, вы *можете*, приложив немало усилий (как мы увидим далее в этой главе), реализовать некоторое приближение для большей части классической функциональности класса. JS пытается удовлетворить чрезвычайно распространенное *желание* проектировать с классами, предоставляя, казалось бы, похожий на классы синтаксис.

Хотя у нас и может быть синтаксис, похожий на классы, это больше похоже на то, что механика JavaScript борется против того, чтобы вы использовали шаблон проектирования *class*. Так как под капотом механизмы, которые вы строите, работают совсем по-другому. Синтаксический сахар и (очень широко используемые) JS библиотеки для работы с "классами" проходят долгий путь скрывая эту реальность от вас, но рано или поздно вы столкнетесь с тем, что *классы* которые у вас есть в других языках не похожи на фейковые "классы", которые мы создаем себе в JS.

Все это сводится к тому, что классы не являются обязательным шаблоном при разработке программного обеспечения, и у вас есть выбор, использовать их в JavaScript или нет. Поскольку многие разработчики имеют сильную тягу к класс-ориентированному дизайну программного обеспечения, мы посвятим оставшуюся часть этой главы рассмотрению того, чего стоит поддержание иллюзии классов с использованием тех механизмов, что предоставляет JS, и тех проблем, которые мы при этом испытываем.

## Механика Классов

Во многих классовых языках "стандартная библиотека" предоставляет "стековую" структуру данных (push, pop и др.) как класс `Stack`. Этот класс имеет внутренний набор переменных, которые хранят данные, и набор публичных методов, которые дают вашему коду возможность взаимодействовать со (скрытыми) данными (добавление и удаление данных и т. д.).

Но в подобных языках вы на самом деле не работаете непосредственно со `Stack` (если только речь не идет о **Static** члене класса, но это выходит за рамки нашего обсуждения). Класс `Stack` - это просто абстрактное описание того, что должен делать *любой* "стек", но это не *сам* "стек". Вы должны **создать экземпляр** класса `Stack`, прежде чем у вас будет конкретная структура данных *нечто* для работы с ней.

### Строительство

Традиционная метафора понимания концепции «класс» и «экземпляр» основана на конструировании здания.

Архитектор планирует все характеристики здания: какова его ширина, высота, сколько окон и в каких местах, даже какой материал использовать для стен и крыши. На данном этапе архитектору не важно *где* будет построено здание, равно как и *сколько* копий этого здания будет построено.

Архитектор также не очень заботится о внутренностях здания - мебели, обоях, потолочных вентиляторах и т.д. - только о том, какой тип конструкции будет иметь здание.

Архитектурные проекты являются всего лишь *планами* здания. Они на самом деле не представляют собой здание, в которое мы можем войти и сесть. Нам нужен строитель для этой задачи. Строитель возьмет эти планы и будет следовать им по мере того, как он *строит* здание. Он «копирует» намеченные характеристики из планов в физическое здание.

После завершения строительства это будет физическое воплощение планов, которые, как мы надеемся, по сути, будут идеальной копией. И тогда застройщик может перейти к открытому участку по соседству и сделать это снова, создав еще одну *копию*.

Отношения между строительством и планом косвенные. Вы можете изучить чертеж, чтобы понять, как строилось здание, для любых частей, где прямой осмотр самого здания был недостаточен. Но если вы хотите открыть дверь, вы должны пойти в само здание - на чертеже просто нарисованы линии, которые *представляют*, где должна быть дверь.

Класс - это план. Чтобы на самом деле *получить* объект, с которым мы можем взаимодействовать, мы должны построить (иначе, "создать экземпляр") что-то из класса. Конечным результатом такой «конструкции» является объект, обычно называемый «экземпляром», с помощью которого мы можем напрямую вызывать методы и обращаться к любым общедоступным свойствам данных при необходимости.

**Этот объект является *копией*** всех характеристик, описанных классом.

Вы, вероятно, не ожидаете, что войдете в здание и найдете висящую в рамке на стене копию чертежей, используемых для планирования здания, хотя чертежи, вероятно, хранятся в государственном архиве. Точно так же вы обычно не используете экземпляр объекта для прямого доступа к его классу и манипулирования им, но, обычно, возможно, по крайней мере, определить, *из какого класса* исходит экземпляр объекта.

Более полезно рассмотреть прямую связь класса с экземпляром, а не любые косвенные отношения между экземпляром и классом, из которого он получен. **Класс создается в форме объекта с помощью операции копирования.**

<img src = "fig1.png">

Как видно, стрелки перемещаются слева направо и сверху вниз, что указывает на операции копирования, которые происходят как концептуально, так и физически.

### Конструктор

Экземпляры классов создаются специальным методом класса, обычно с тем же именем, что и класс, называемым *конструктор*. Задача этого метода - инициализировать любую информацию (состояние), которая понадобится экземпляру.

Например, рассмотрим этот свободный псевдокод (изобретенный синтаксис) для классов:

```js
class CoolGuy {
	specialTrick = nothing

	CoolGuy( trick ) {
		specialTrick = trick
	}

	showOff() {
		output( "Зацените мой трюк: ", specialTrick )
	}
}
```

Чтобы *сделать* экземпляр `CoolGuy`, мы бы вызвали конструктор класса:

```js
Joe = new CoolGuy( "Прыжок через скакалку" )

Joe.showOff() // Зацените мой трюк: прыжок через скакалку
```

Обратите внимание, что класс `CoolGuy` имеет конструктор `CoolGuy()`, который фактически является тем, что мы вызываем, когда мы говорим `new CoolGuy (..)`. Обратно из конструктора мы получаем объект (экземпляр нашего класса), и мы можем вызвать метод `showOff()`, который выводит особый трюк `CoolGuy`.

*Очевидно, прыжки со скакалкой делают Джо довольно крутым парнем.*

Конструктор класса *принадлежит* классу, почти всегда с тем же именем, что и класс. Кроме того, конструкторы всегда нужно вызывать с помощью `new`, чтобы языковой движок знал, что вы хотите создать *новый* экземпляр класса.

## Наследование классов

В класс-ориентированных языках вы можете не только определить класс, для которого можно создать сам экземпляр, но вы можете определить другой класс, который **наследуется** от первого класса.

Второй класс часто называют «дочерним классом», тогда как первый - «родительским классом». Эти термины, очевидно, происходят из метафоры "родители и дети", хотя метафоры здесь немного растянуты, как вы скоро увидите.

Когда у родителя есть биологический ребенок, генетические характеристики родителя копируются в ребенка. Очевидно, что в большинстве систем биологического размножения есть два родителя, которые в равной степени передают гены ребёнку. Но в нашей метафоре мы будем предполагать только одного родителя.

Когда ребенок существует, он или она отделяется от родителя. Изначально ребенок находится под сильным влиянием наследования от своего родителя, но со временем начинает отличаться от него всё больше и больше. Если у ребенка появляются рыжие волосы, это не значит, что волосы родителя *были* или автоматически *становятся* рыжими.

Аналогичным образом, после определения дочернего класса он становится отдельным и отличным от родительского класса. Дочерний класс содержит начальную копию поведения от родителя, но затем может переопределить любое унаследованное поведение и даже определить новое поведение.

Важно помнить, что мы говорим о родительских и дочерних **классах**, которые не являются физическими. Вот где метафора «родитель-ребенок» становится немного запутанной, потому что на самом деле мы должны сказать, что родительский класс похож на ДНК родителя, а дочерний класс похож на ДНК ребенка. Мы должны сделать (или «создать экземпляр») человека из каждого набора ДНК, чтобы на самом деле иметь живого собеседника.

Давайте оставим в стороне биологических родителей и детей и рассмотрим наследование через несколько иную линзу: разные типы транспортных средств. Это одна из самых канонических (и часто достойных восклицания) метафор для понимания наследования.

Давайте вернемся к обсуждению `Транспортное средство` и `Автомобиль`, описанному ранее в этой главе. Рассмотрим этот свободный псевдокод (изобретенный синтаксис) для унаследованных классов:

```js
class Vehicle {
	engines = 1

	ignition() {
		output( "Завожу двигатель." )
	}

	drive() {
		ignition()
		output( "Двигаюсь вперёд!" )
	}
}

class Car inherits Vehicle {
	wheels = 4

	drive() {
		inherited:drive()
		output( "Еду на всех ", wheels, " колёсах!" )
	}
}

class SpeedBoat inherits Vehicle {
	engines = 2

	ignition() {
		output( "Завожу мои ", engines, " двигатели." )
	}

	pilot() {
		inherited:drive()
		output( "Скольжу по воде с ветерком!" )
	}
}
```

**Примечание:** Для ясности и краткости конструкторы для этих классов были опущены.

Мы определяем класс «Транспортное средство» - `Vehicle`, который предполагает двигатель, способ включения зажигания и способ передвижения. Но вы бы никогда не произвели просто универсальное «транспортное средство», так что на самом деле это просто абстрактная концепция.

Итак, мы определяем два конкретных типа транспортных средств: «Автомобиль» - `Car` и «Скоростной катер» - `SpeedBoat`. Каждый из них наследует общие характеристики «Транспортного средства» - `Vehicle`, но затем они специализируют характеристики соответствующие для каждого вида. Автомобилю нужно 4 колеса, а скоростному катеру - 2 двигателя, а это значит, что для включения зажигания обоих двигателей требуется дополнительное внимание.

### Полиморфизм

`Car` определяет свой собственный метод `drive()`, который переопределяет метод с тем же именем, унаследованный от `Vehicle`. Но затем метод `drive()` из `Сar` вызывает `inherited:drive()`, что указывает на то, что `Car` может ссылаться на исходный предварительно переопределенный метод `drive()`, который он унаследовал. Метод `pilot()` из `SpeedBoat` также ссылается на его унаследованную копию `drive()`.
Эта техника называется «полиморфизм» или «виртуальный полиморфизм». Приближённо к нашей теме, мы будем называть это «относительным полиморфизмом».

Полиморфизм - гораздо более широкая тема, чем мы здесь рассмотрели, но наша текущая «относительная» семантика относится к одному конкретному аспекту: идее о том, что любой метод может ссылаться на другой метод (с тем же или другим именем) на более высоком уровне иерархии наследования. Мы говорим «относительный», потому что мы не определяем абсолютно к какому уровню наследования (классу) мы хотим получить доступ, а скорее ссылаемся на него, по сути, «на один уровень вверх».

Во многих языках используется ключевое слово «super» вместо «inherited:», это основывается на идее, что «super class» является родителем/предком текущего класса.

Другой аспект полиморфизма заключается в том, что имя метода может иметь несколько определений на разных уровнях цепочки наследования, и эти определения автоматически выбираются соответствующим образом при определении того, какие методы вызываются.

Мы видим два случая такого поведения в нашем примере выше: `drive()` определен как в `Vehicle`, так и в `Car`, а `ignition()` определен как в `Vehicle`, так и в `SpeedBoat`.

**Примечание:** Еще одна вещь, которую дают вам традиционные класс-ориентированные языки через `super`, - это возможность прямо ссылаться на конструктор родительского класса из конструктора дочернего класса. Это в значительной степени верно, потому что с реальными классами конструктор принадлежит классу. Однако в JS все наоборот - на самом деле более уместно думать о «классе», принадлежащем конструктору (ссылки на типы `Foo.prototype ...`). Поскольку в JS отношения между дочерними и родительскими объектами существуют только между двумя объектами `.prototype` соответствующих конструкторов, сами конструкторы не связаны напрямую, и, следовательно, не существует простого способа ссылаться из одного конструктора в другой (см. Приложение A для ES6 `class`, который "решает" это с помощью `super`).

Интересное следствие полиморфизма можно увидеть именно с помощью функции `ignition()`. Внутри `pilot()` делается относительная-полиморфная ссылка на (унаследованную) версию `Vehicle` `drive()`. Но этот `drive()` ссылается на метод `ignition()` только по имени (без относительной ссылки).

Какую версию `ignition()` будет использовать языковой движок: `Vehicle` или `SpeedBoat`? **Он использует версию SpeedBoat `ignition()`.** Если бы вы *должны были* создать экземпляр самого класса `Vehicle`, а затем вызвать его метод `drive()`, языковой движок использовал бы метод `ignition()` от `Vehicle`.

Другими словами, определение для метода `ignition()` - *полиморфно* (изменяется) в зависимости от того, на какой класс (уровень наследования) вы ссылаетесь для экземпляра.

Это может показаться слишком глубокими академическими подробностями. Но понимание этих деталей необходимо для правильного сопоставления аналогичного (но отличного) поведения в механизме JavaScript `[[Prototype]]`.

Когда классы наследуются, существует способ **для самих классов** (а не для созданных из них экземпляров!) *относительно* ссылаться на класс-источник наследования, и эта относительная ссылка обычно называется `super`.

Ранее мы рассматривали схему:

<img src="fig1.png">

Обратите внимание, как для экземпляров (`a1`, `a2`, `b1` и `b2`) *и* наследования (`Bar`) стрелки указывают операцию копирования.

Концептуально может показаться, что дочерний класс `Bar` может обращаться к методам своего родительского `Foo`, используя относительную полиморфную ссылку (известную как `super`). Однако в действительности дочернему классу просто дается копия унаследованного поведения от его родительского класса. Если дочерний элемент «переопределяет» метод, который он наследует, то исходная и переопределенная версии метода фактически поддерживаются, так что обе версии метода доступны.

Не позволяйте полиморфизму сбить вас с толку, думая, что дочерний класс связан с его родительским классом. Дочерний класс вместо этого получает копию того, что ему нужно, от родительского класса. **Дочерний класс подразумевает копии.**

### Множественное наследование

Помните наше предыдущее обсуждение родителей и детей, а также ДНК? Мы сказали, что метафора была немного странной, потому что биологически большинство потомков происходит от двух родителей. Если бы класс мог наследовать от двух других классов, он более точно соответствовал бы метафоре родитель / потомок.

Некоторые ориентированные на классы языки позволяют указывать более одного «родительского» класса для «наследования». Множественное наследование означает, что каждое определение родительского класса копируется в дочерний класс.

На первый взгляд, это кажется мощным дополнением к возможностям классов, что позволяет нам объединить больше функциональных возможностей. Однако, безусловно, возникают некоторые сложные вопросы. Если оба родительских класса предоставляют метод с именем `drive()`, на какую версию ссылается ссылка `drive()` в дочернем элементе? Всегда ли вам нужно вручную указывать, какой родительский тип `drive()` вы имели в виду, теряя при этом некоторую грациозность полиморфного наследования?

Есть еще один вариант, так называемая «проблема алмазов», которая относится к сценарию, где дочерний класс «D» наследует от двух родительских классов («B» и «C»), а каждый из них, в свою очередь, наследуется от общего класса «A». «A» предоставляет метод `drive()`, и оба класса "B" и "C" переопределяют (полиморфируют) этот метод. Когда `D` ссылается на `drive()`, какую версию следует использовать (`B:drive()` или `C:drive()`)?

<img src="fig2.png">

Но на деле всё ещё сложнее, чем кажется на первый взгляд. Мы рассматриваем это только для того, чтобы мы могли противопоставить работу механизмов JavaScript.

JavaScript проще: он не предоставляет нативный механизм «множественного наследования». Многие считают, что это хорошо, потому что экономия на сложности более чем компенсирует «урезанную» функциональность языка. Но это не мешает разработчикам пытаться подделать его(механизм) различными способами, как мы увидим дальше.

## Mixins - Примеси

Механизм объектов JavaScript не *автоматически* выполняет поведение копирования, когда вы «наследуете» или «создаете экземпляр». Проще говоря, в JavaScript нет «классов» для создания экземпляров, только объекты. И объекты не копируются в другие объекты, они *связываются вместе* (подробнее об этом в главе 5).

Поскольку наблюдаемое поведение классов в других языках подразумевает наличие копий, давайте рассмотрим, как разработчики JS **подделывают** поведение копирования *отсутствующего* в JavaScript классах с помощью примесей(Mixins). Мы рассмотрим два типа «примесей»: **явные** и **неявные**.

### Явные примеси

Давайте снова вернемся к нашему примеру «Транспортное средство» - `Vehicle` и «Автомобиль» - `Car`. Поскольку JavaScript не будет автоматически копировать поведение из `Vehicle` в `Car`, мы можем вместо этого создать утилиту, которая будет это делать. Такая утилита часто называется `extend(..)` многими библиотеками / фреймворками, но мы будем называть ее `mixin(..)` здесь для наглядности.

```js
// значительно упрощенный пример `mixin(..)`:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// копируем только если его еще нет
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}

var Vehicle = {
	engines: 1,

	ignition: function() {
		console.log( "Завожу двигатель." );
	},

	drive: function() {
		this.ignition();
		console.log( "Двигаюсь вперёд!" );
	}
};

var Car = mixin( Vehicle, {
	wheels: 4,

	drive: function() {
		Vehicle.drive.call( this );
		console.log( "Еду на всех моих " + this.wheels + " колёсах!" );
	}
} );
```

**Примечание:** Важная деталь - мы больше не имеем дело с классами, потому что в JavaScript нет классов. «Транспортное средство» - `Vehicle` и «Автомобиль» - `Car` — это просто объекты, с которых мы делаем копии, соответственно.

`Car` теперь имеет копию свойств и функций из `Vehicle`. Технически, функции на самом деле не дублируются, а копируются *ссылки* на функции. Таким образом, `Car` теперь имеет свойство под названием `ignition`, которое является скопированной ссылкой на функцию `ignition()`, а также свойство, называемое `engines`, со скопированным значением `1` из `Vehicle`.

`Car` *уже* имеет свойство (функцию) `drive`, поэтому ссылка на свойство не была переопределена (см. Инструкцию `if` в `mixin(..)` выше).

#### "Полиморфизм" вновь

Давайте рассмотрим это утверждение: `Vehicle.drive.call(this)`. Это то, что я называю «явным псевдополиморфизмом». Напомню, что в псевдокоде, который мы рассматривали выше, эта строка была `inherited:drive()`, которую мы назвали «относительным полиморфизмом».

JavaScript не имеет (до ES6; см. Приложение A) средства для относительного полиморфизма. Итак, **потому что `Car` и `Vehicle` имеют функцию с одинаковым именем: `drive()`**, чтобы различать вызов той или иной функции, мы должны сделать абсолютную (не относительную) ссылку. Мы явно указываем объект `Vehicle` по имени и вызываем функцию `drive()` для него.

Но если бы мы сказали `Vehicle.drive()`, привязка `this` для этого вызова функции была бы объектом `Vehicle` вместо объекта `Car` (см. Главу 2), а это не то, что нам нужно. Таким образом, вместо этого мы используем `.call(this)` (Глава 2), чтобы гарантировать, что `drive()` выполняется в контексте объекта `Car`.

**Примечание:** Если идентификатор имени функции для `Car.drive()` не перекрывался ("затенялся"; см. Главу 5) с `Vehicle.drive()`, мы бы не выполняли «метод полиморфизма». Таким образом, ссылка на `Vehicle.drive()` была бы скопирована вызовом `mixin(..)`, и мы могли бы получить прямой доступ с помощью `this.drive()`. Выбранный идентификатор перекрывается **затенением**, поэтому *мы* должны использовать более сложный *явный подход псевдополиморфизма*.

В ориентированных на классы языках, которые имеют относительный полиморфизм, связь между `Car` и `Vehicle` устанавливается один раз, в верхней части определения класса, что дает только одно место для поддержания таких отношений.

Но из-за особенностей JavaScript явный псевдополиморфизм (из-за затенения!) Создает хрупкую ручную/явную связь **в каждой отдельной функции, где вам нужна такая (псевдо-) полиморфная ссылка**. Это может значительно увеличить стоимость обслуживания. Более того, хотя явный псевдополиморфизм может эмулировать поведение «множественного наследования», он только увеличивает сложность и хрупкость.

Результатом таких подходов обычно является более сложный, трудный для чтения и сложный в обслуживании код. **По возможности следует избегать явного псевдополиморфизма**, потому что стоимость в большинстве случаев перевешивает выгоду.

#### Смешивание копий

Вспомните утилиту `mixin(..)` сверху:

```js
// значительно упрощенный пример `mixin(..)`:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// копируем только если его еще нет
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}
```

Теперь давайте посмотрим, как работает `mixin(..)`. Он перебирает свойства `sourceObj` (в нашем примере - `Vehicle`), и если в `targetObj` (в нашем примере, `Car`) нет соответствующего свойства с этим именем, он создает копию. Поскольку мы делаем копию после того, как объект уже был проинициализирован, мы стараемся не копировать целевое свойство.

Если мы сначала сделаем копии, прежде чем указывать содержимое `Car`, мы могли бы опустить эту проверку для `targetObj`, но это немного более неуклюже и менее эффективно, поэтому обычно это менее предпочтительно:

```js
// альтернативный миксин, менее "безопасный" для перезаписи
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		targetObj[key] = sourceObj[key];
	}

	return targetObj;
}

var Vehicle = {
	// ...
};

// сначала создаем пустой объект со
// скопированными свойствами `Vehicle`
var Car = mixin( Vehicle, { } );

// теперь копируем содержимое в Car
mixin( {
	wheels: 4,

	drive: function() {
		// ...
	}
}, Car );
```

При любом подходе мы явно копировали неперекрывающееся содержимое `Vehicle` в `Car`. Название `mixin` происходит от альтернативного способа объяснения задачи: у `Car` **смешанное** с `Vehicle` содержимое, как вы смешиваете шоколадные крошки в своем любимом тесте для печенья чтобы получить печенье с шоколадной крошкой.

В результате операции копирования `Car` будет работать несколько иначе, чем `Vehicle`. Если вы добавите свойство в `Car`, оно не повлияет на `Vehicle`, и наоборот.

**Примечание:** Здесь были рассмотрены несколько мелких деталей. Есть и некоторые другие тонкости, которые позволяют двум объектам «влиять» друг на друга даже после копирования, например, если они оба имеют общую ссылку на общий объект (такой как массив).

Поскольку эти два объекта также имеют общие ссылки на свои общие функции, это означает, что **даже ручное копирование функций (иначе говоря, подмешивание) из одного объекта в другой *фактически не эмулирует* реальное дублирование от класса к экземпляру, которое происходит в класс-ориентированных языках**.

Функции JavaScript на самом деле не могут быть дублированы (стандартным, надежным способом), поэтому вместо этого мы получаем **дублированную ссылку** на один и тот же объект общей функции (функции являются объектами; см. Главу 3). Если вы изменили один из общих **функциональных объектов** (например, `ignition()`), добавив к нему свойства, то и `Vehicle`, и `Car` будут «затронуты» через общую ссылку.

Явные примеси - это прекрасный механизм в JavaScript. Но они кажутся более могущественными, чем они есть на самом деле. На самом деле *небольшая выгода* получается от копирования свойства из одного объекта в другой, **в отличие от простого определения свойств дважды**, один раз для каждого объекта. И это особенно верно, учитывая нюанс ссылки на функцию-объект, который мы только что упомянули.

Если вы явно смешиваете два или более объекта в целевой объект, вы можете **частично эмулировать** поведение «множественного наследования», но нет прямого способа обработки коллизий, если один и тот же метод или свойство копируется из более чем одного источника. Некоторые разработчики/библиотеки придумали методы «позднего связывания» и другие экзотические обходные пути, но по сути эти «уловки» *обычно* требуют больше усилий (и меньшей производительности!), чем дают пользы.

Позаботьтесь только о том, чтобы использовать явные примеси, когда это действительно помогает сделать код более читабельным, и избегайте шаблонов, если вы обнаружите, что он делает код сложным для отслеживания или он создает ненужные или громоздкие зависимости между объектами.

**Если при использовании примесей писать и поддерживать код становится труднее, чем если бы вы их не использовали**, вам, вероятно, следует прекратить использовать примеси. Фактически, если вам нужно использовать сложную библиотеку/утилиту для проработки всех этих деталей, это может быть признаком того, что вы идете по этому пути сложнее, возможно, чем следовало бы. В главе 6 мы попытаемся найти более простой способ достижения желаемых результатов без суеты.

#### Паразитическое наследование

Вариант этого явного паттерна подмешивания, который в некоторых отношениях явный, а в других неявный, называется «паразитическим наследованием», популяризируемый в основном Дугласом Крокфордом.

Вот как это может работать:

```js
// "Традиционный JS класс" `Vehicle`
function Vehicle() {
	this.engines = 1;
}
Vehicle.prototype.ignition = function() {
	console.log( "Завожу двигатель." );
};
Vehicle.prototype.drive = function() {
	this.ignition();
	console.log( "Двигаюсь вперёд!" );
};

// "Паразитический класс" `Car`
function Car() {
	// во-первых, `car` это `Vehicle`
	var car = new Vehicle();

	// теперь, давайте модифицируем `car` чтобы придать ей специфичности
	car.wheels = 4;

	// сохранить привилегированную ссылку в `Vehicle::drive()`
	var vehDrive = car.drive;

	// переопределяем `Vehicle::drive()`
	car.drive = function() {
		vehDrive.call( this );
		console.log( "Еду на всех моих " + this.wheels + " колёсах!" );
	};

	return car;
}

var myCar = new Car();

myCar.drive();
// Завожу двигатель.
// Двигаюсь вперёд!
// Еду на всех моих 4 колёсах!
```

Как вы можете видеть, мы сначала делаем копию определения из «родительского класса» (объекта) `Vehicle`, затем смешиваем наше определение «дочернего класса» (объекта) (сохраняя при необходимости ссылки на привилегированный родительский класс) и передаем от этого составного объекта `car` в качестве нашего дочернего экземпляра.

**Примечание:** когда мы вызываем `new Car()`, создается новый объект и на него ссылается ссылка `this` (см. Главу 2). Но поскольку мы не используем этот объект и вместо этого возвращаем наш собственный объект `car`, первоначально созданный объект просто отбрасывается. Таким образом, `Car()` может быть вызван без ключевого слова `new`, а приведенные выше функциональные возможности будут идентичны, но без ненужного создания объекта/сборки мусора.

### Неявные примеси

Неявные примеси тесно связаны с *явным псевдополиморфизмом*, как объяснено ранее. Как таковые, они приходят с одинаковыми предостережениями и предупреждениями.

Рассмотрим этот код:

```js
var Something = {
	cool: function() {
		this.greeting = "Привет, мир";
		this.count = this.count ? this.count + 1 : 1;
	}
};

Something.cool();
Something.greeting; // "Привет, мир"
Something.count; // 1

var Another = {
	cool: function() {
		// неявное смешивание `Something` с `Another`
		Something.cool.call( this );
	}
};

Another.cool();
Another.greeting; // "Привет, мир"
Another.count; // 1 (нет общего состояния с `Something`)
```

С помощью `Something.cool.call(this)`, которое может происходить либо при вызове «конструктора» (наиболее часто), либо при вызове метода (показано здесь), мы, по сути, «заимствуем» функцию `Something.cool()` и вызываем его в контексте `Another` (через привязку `this`; см. главу 2) вместо `Something`. Конечным результатом является то, что назначения, которые выполняет `Something.cool()`, применяются к объекту `Another`, а не к объекту `Something`.

Итак, сказано, что мы «смешали» поведение Something с (или в) `Another`.

Хотя этот вид техники, кажется, использует полезные преимущества функции связывания this, это хрупкий вызов `Something.cool.call(this)`, который нельзя превратить в относительную (и, следовательно, более гибкую) ссылку, с которой вам **следует соблюдать осторожность**. Как правило, **по возможности избегайте таких конструкций**, чтобы сохранить более чистый и более понятный код.

## Обзор (TL; DR)

Классы - это шаблон кодирования. Многие языки предоставляют синтаксис, который позволяет проектировать класс-ориентированное программное обеспечение. JS также имеет похожий синтаксис, но он ведет себя **совсем иначе**, чем вы ожидаете от классов из этих других языков.

**Классы означают копии.**

При создании объектов традиционных классов, происходит копирование поведения от класса к экземпляру. Когда классы наследуются, также происходит копирование поведения от родителя к потомку.

Может показаться что полиморфизм (имеющий разные функции на нескольких уровнях цепочки наследования с одним и тем же именем) подразумевает относительную ссылку от дочернего элемента к родительскому, но это все еще просто результат поведения копирования.

JavaScript **автоматически не** создает копии (как подразумевают классы) между объектами.

Шаблон примеси (как явный, так и неявный) часто используется для *эмуляции* поведения копирования классов, но это обычно приводит к уродливому и хрупкому синтаксису, например явному псевдополиморфизму (`OtherObj.methodName.call(this, ...)`), что часто приводит к усложнению понимания и поддержки кода.

Явные примеси также не совсем совпадают с *копированием* классов, поскольку объекты (и функции!) дублируются только общими ссылками, а сами объекты/функции не дублируются. Не обратив внимания на такой нюанс вы получите источник множества недочетов.

В целом, фальшивые классы в JS часто устанавливают больше мин для будущего кодирования, чем решают *реальные* проблемы.

# # Вы не знаете JS: _this_ и прототипы объектов

# Глава 5: Прототипы

В главах 3 и 4 мы неоднократно упоминали цепочку `[[Prototype]]`, но не уточняли что это такое. Пришло время разобраться с тем, как работают прототипы.

**Примечание:** Любые попытки эмуляции копирования классов, упомянутые в главе 4 как "примеси", полностью обходят механизм цепочки `[[Prototype]]`, рассматриваемый в этой главе.

## `[[Prototype]]`

Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как `[[Prototype]]`, которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-`null` значение.

**Примечание:** Чуть ниже мы увидим, что объект _может_ иметь пустую ссылку `[[Prototype]]`, хотя такой вариант встречается реже.

Рассмотрим пример:

```js
var myObject = {
  a: 2,
};

myObject.a; // 2
```

Для чего используется ссылка `[[Prototype]]`? В главе 3 мы изучили операцию `[[Get]]`, которая вызывается когда вы ссылаетесь на свойство объекта, например `myObject.a`. Стандартная операция `[[Get]]` сначала проверяет, есть ли у объекта собственное свойство `a`, если да, то оно используется.

**Примечание:** Прокси-объекты ES6 выходят за рамки этой книги (мы увидим их в одной из следующих книг серии!), но имейте в виду, что обсуждаемое нами стандартное поведение `[[Get]]` и `[[Put]]` неприменимо если используются `Proxy`.

Но нас интересует то, что происходит, когда `a` **отсутствует** в `myObject`, т.к. именно здесь вступает в действие ссылка `[[Prototype]]` объекта.

Если стандартная операция `[[Get]]` не может найти запрашиваемое свойство в самом объекте, то она следует по **ссылке** `[[Prototype]]` этого объекта.

```js
var anotherObject = {
  a: 2,
};

// создаем объект, привязанный к `anotherObject`
var myObject = Object.create(anotherObject);

myObject.a; // 2
```

**Примечание:** Чуть позже мы объясним что делает `Object.create(..)` и как он работает. Пока же считайте, что создается объект со ссылкой `[[Prototype]]` на указанный объект.

Итак, у нас есть `myObject`, который теперь связан с `anotherObject` через ссылку `[[Prototype]]`. Очевидно, что `myObject.a` на самом деле не существует, однако обращение к свойству выполнилось успешно (свойство нашлось в `anotherObject`) и действительно вернуло значение `2`.

Если бы `a` не нашлось и в объекте `anotherObject`, то теперь уже его цепочка `[[Prototype]]` использовалась бы для дальнейшего поиска.

Этот процесс продолжается до тех пор, пока либо не будет найдено свойство с совпадающим именем, либо не закончится цепочка `[[Prototype]]`. Если по достижении конца цепочки искомое свойство _так и не будет_ найдено, операция `[[Get]]` вернет `undefined`.

По аналогии с этим процессом поиска по цепочке `[[Prototype]]`, если вы используете цикл `for..in` для итерации по объекту, будут перечислены все свойства, достижимые по его цепочке (при условии, что они перечислимые — см. `enumerable` в главе 3). Если вы используете оператор `in` для проверки существования свойства в объекте, то `in` проверит всю цепочку объекта (независимо от _перечисляемости_).

```js
var anotherObject = {
  a: 2,
};

// создаем объект, привязанный к `anotherObject`
var myObject = Object.create(anotherObject);

for (var k in myObject) {
  console.log("найдено: " + k);
}
// найдено: a

"a" in myObject; // true
```

Итак, ссылки в цепочке `[[Prototype]]` используются одна за другой, когда вы тем или иным способом пытаетесь найти свойство. Поиск заканчивается при нахождении свойства или достижении конца цепочки.

### `Object.prototype`

Но _где_ именно "заканчивается" цепочка `[[Prototype]]`?

В конце каждой _типичной_ цепочки `[[Prototype]]` находится встроенный объект `Object.prototype`. Этот объект содержит различные утилиты, используемые в JS повсеместно, поскольку все обычные (встроенные, не связанные с конкретной средой исполнения) объекты в JavaScript "происходят от" объекта `Object.prototype` (иными словами, имеют его на вершине своей цепочки `[[Prototype]]`).

Некоторые утилиты этого объекта могут быть вам знакомы: `.toString()` и `.valueOf()`. В главе 3 мы видели еще одну: `.hasOwnProperty(..)`. Еще одна функция `Object.prototype`, о которой вы могли не знать, но узнаете далее в этой главе — это `.isPrototypeOf(..)`.

### Установка и затенение свойств

Ранее в главе 3 мы отмечали, что установка свойств объекта происходит чуть сложнее, чем просто добавление к объекту нового свойства или изменение значения существующего свойства.

```js
myObject.foo = "bar";
```

Если непосредственно у `myObject` есть обычное свойство доступа к данным с именем `foo`, то присваивание сводится к изменению значения существующего свойства.

Если непосредственно у `myObject` нет `foo`, то выполняется обход цепочки `[[Prototype]]` по аналогии с операцией `[[Get]]`. Если `foo` не будет найдено в цепочке, то свойство `foo` добавляется непосредственно к `myObject` и получает указанное значение, как мы того и ожидаем.

Однако если `foo` находится где-то выше по цепочке, то присваивание `myObject.foo = "bar"` может повлечь за собой более сложное (и даже неожиданное) поведение. Рассмотрим этот вопрос подробнее.

Если свойство с именем `foo` присутствует как у самого `myObject`, так и где-либо выше в цепочке `[[Prototype]]`, начинающейся с `myObject`, то такая ситуация называется _затенением_. Свойство `foo` самого `myObject` _затеняет_ любые свойства `foo`, расположенные выше по цепочке, потому что поиск `myObject.foo` всегда находит свойство `foo`, ближайшее к началу цепочки.

Как уже отмечалось, затенение `foo` в `myObject` происходит не так просто, как может показаться. Мы рассмотрим три сценария присваивания `myObject.foo = "bar"`, когда `foo` **не** содержится непосредственно в `myObject`, а **находится** выше по цепочке `[[Prototype]]` объекта `myObject`:

1. Если обычное свойство доступа к данным (см. главу 3) с именем `foo` находится выше по цепочке `[[Prototype]]`, **и свойство доступно для записи (`writable:true`)**, то новое свойство `foo` добавляется непосредственно в объект `myObject`, и происходит **затенение свойства**.
2. Если `foo` находится выше по цепочке `[[Prototype]]`, но отмечено как **только для чтения (`writable:false`)**, то установка значения этого существующего свойства, равно как и создание затеняющего свойства у `myObject`, **запрещены**. Если код выполняется в `strict mode`, то будет выброшена ошибка, если нет, то попытка установить значение свойства будет проигнорирована. В любом случае, **затенения не происходит**.
3. Если `foo` находится выше по цепочке `[[Prototype]]` и является сеттером (см. главу 3), то всегда будет вызываться сеттер. Свойство `foo` не будет добавлено в `myObject`, сеттер `foo` не будет переопределен.

Большинство разработчиков предполагает, что присваивание свойства (`[[Put]]`) всегда приводит к затенению, если свойство уже существует выше по цепочке `[[Prototype]]`, но как видите это является правдой лишь в одной (№1) из трех рассмотренных ситуаций.

Если вы хотите затенить `foo` в случаях №2 и №3, то вместо присваивания `=` нужно использовать `Object.defineProperty(..)` (см. главу 3) чтобы добавить `foo` в `myObject`.

**Примечание:** Ситуация №2 может показаться наиболее удивительной из трех. Наличие свойства _только для чтения_ мешает нам неявно создать (затенить) свойство с таким же именем на более низком уровне цепочки `[[Prototype]]`. Причина такого ограничения по большей части кроется в желании поддержать иллюзию наследования свойств класса. Если представить, что `foo` с верхнего уровня цепочки наследуется (копируется) в `myObject`, то имеет смысл запретить изменение этого свойства `foo` в `myObject`. Но если перейти от иллюзий к фактам и согласиться с тем, что никакого наследования с копированием _на самом деле_ не происходит (см. главы 4 и 5), то кажется немного странным, что `myObject` не может иметь свойство `foo` лишь потому, что у какого-то другого объекта есть неизменяемое свойство `foo`. Еще более странно то, что это ограничение действует только на присваивание `=`, но не распространяется на `Object.defineProperty(..)`.

Затенение при использовании **методов** приведет к уродливому _явному псевдополиморфизму_ (см. главу 4) если вам потребуется делегирование между ними. Обычно затенение приносит больше проблем и сложностей, чем пользы, **поэтому старайтесь избегать его если это возможно**. В главе 6 вы увидите альтернативный шаблон проектирования, который наряду с другими вещами предполагает отказ от затенения в пользу более разумных альтернатив.

Затенение может даже произойти неявно, поэтому если вы хотите его избежать, будьте бдительны. Например:

```js
var anotherObject = {
  a: 2,
};

var myObject = Object.create(anotherObject);

anotherObject.a; // 2
myObject.a; // 2

anotherObject.hasOwnProperty("a"); // true
myObject.hasOwnProperty("a"); // false

myObject.a++; // ой, неявное затенение!

anotherObject.a; // 2
myObject.a; // 3

myObject.hasOwnProperty("a"); // true
```

Хотя может показаться, что выражение `myObject.a++` должно (через делегирование) найти и просто инкрементировать свойство `anotherObject.a`, вместо этого операция `++` соответствует выражению `myObject.a = myObject.a + 1`. В результате `[[Get]]` ищет свойство `a` через `[[Prototype]]` и получает текущее значение `2` из `anotherObject.a`, далее это значение увеличивается на 1, после чего `[[Put]]` присваивает значение `3` новому затеняющему свойству `a` в `myObject`. Ой!

Будьте очень осторожны при работе с делегированными свойствами, пытаясь изменить их значение. Если вам нужно инкрементировать `anotherObject.a`, то вот единственно верный способ сделать это: `anotherObject.a++`.

## "Класс"

Вы уже могли задаться вопросом: "_Зачем_ одному объекту нужна ссылка на другой объект?" Какой от этого толк? Это очень хороший вопрос, но сначала нам нужно выяснить, чем `[[Prototype]]` **не является**, прежде чем мы сможем понять и оценить то, чем он _является_, и какая от него польза.

В главе 4 мы выяснили, что в отличие от класс-ориентированных языков в JavaScript нет абстрактных шаблонов/схем объектов, называемых "классами". В JavaScript **просто** есть объекты.

На самом деле, JavaScript — **практически уникальный** язык, ведь пожалуй только он имеет право называться "объектно-ориентированным", т.к. относится к весьма немногочисленной группе языков, где объекты можно создавать напрямую, без классов.

В JavaScript классы не могут описывать поведение объекта (учитывая тот факт, что их вообще не существует!). Объект сам определяет собственное поведение. **Есть _только_ объект.**

### Функции "классов"

В JavaScript есть специфическое поведение, которым долгие годы цинично злоупотребляли для создания _поделок_, внешне _похожих_ на "классы". Рассмотрим этот подход более подробно.

Специфическое поведение "как бы классов" основано на одной странной особенности: у всех функций по умолчанию есть публичное, неперечислимое (см. главу 3) свойство, называемое `prototype`, которое указывает на некий объект.

```js
function Foo() {
  // ...
}

Foo.prototype; // { }
```

Этот объект часто называют "прототипом Foo", поскольку обращение к нему происходит через свойство с неудачно выбранным названием `Foo.prototype`. Как мы вскоре увидим, такая терминология обречена приводить людей в замешательство. Вместо этого, я буду называть его "объектом, ранее известным как прототип Foo". Ладно, шучу. Как насчет этого: "объект, условно называемый 'Foo точка prototype'"?

Как бы мы не называли его, что же это за объект?

Проще всего объяснить так: у каждого объекта, создаваемого с помощью вызова `new Foo()` (см. главу 2), ссылка `[[Prototype]]` будет указывать на этот объект "Foo точка prototype".

Проиллюстрируем на примере:

```js
function Foo() {
  // ...
}

var a = new Foo();

Object.getPrototypeOf(a) === Foo.prototype; // true
```

Когда `a` создается путем вызова `new Foo()`, одним из результатов (все _четыре_ шага см. в главе 2) будет создание в `a` внутренней ссылки `[[Prototype]]` на объект, на который указывает `Foo.prototype`.

Остановитесь на секунду и задумайтесь о смысле этого утверждения.

В класс-ориентированных языках множественные **копии** (или "экземпляры") создаются как детали, штампуемые на пресс-форме. Как мы видели в главе 4, так происходит потому что процесс создания экземпляра (или наследования от) класса означает "скопировать поведение из этого класса в физический объект", и это выполняется для каждого нового экземпляра.

Но в JavaScript такого копирования не происходит. Вы не создаете множественные экземпляры класса. Вы можете создать множество объектов, \*связанных** ссылкой `[[Prototype]]` с общим объектом. Но по умолчанию никакого копирования не происходит, поэтому эти объекты не становятся полностью автономными и не соединенными друг с другом, напротив, они весьма \***связаны\*\*\*.

Вызов `new Foo()` создает новый объект (мы назвали его `a`), и **этот** новый объект `a` связан внутренней ссылкой `[[Prototype]]` с объектом `Foo.prototype`.

**В результате получилось два объекта, связанных друг с другом.** Вот и _все_. Мы не создали экземпляр класса. И мы уж точно не копировали никакого поведения из "класса" в реальный объект. Мы просто связали два объекта друг с другом.

На самом деле секрет, о котором не догадывается большинство JS разработчиков, состоит в том, что вызов функции `new Foo()` практически никак _напрямую_ не связан с процессом создания ссылки. **Это всегда было неким побочным эффектом.** `new Foo()` — это косвенный, окольный путь к желаемому результату: **новому объекту, связанному с другим объектом**.

Можем ли мы добиться желаемого более _прямым_ путем? **Да!** Герой дня — `Object.create(..)`. Но мы вернемся к нему чуть позже.

#### Что значит имя?

В JavaScript мы не делаем _копии_ из одного объекта ("класса") в другой ("экземпляр"). Мы создаем _ссылки_ между объектами. В механизме `[[Prototype]]` визуально стрелки идут справа налево и снизу вверх.

<img src="fig3.png">

Этот механизм часто называют "прототипным наследованием" (мы подробнее рассмотрим код чуть ниже), которое обычно считается вариантом "классического наследования" для динамических языков. Это попытка воспользоваться общепринятым пониманием термина "наследование" в класс-ориентированных языках и \*подогнать\*\* знакомую семантику под динамический язык.

Термин "наследование" имеет очень четкий смысл (см. главу 4). Добавление перед ним слова "прототипное" чтобы обозначить _на самом деле почти противоположное_ поведение привело к неразберихе в течение двух десятков лет.

Я люблю говорить, что использовать слово "прототипное" перед "наследованием" для придания существенно иного смысла — это как держать в одной руке апельсин, а в другой яблоко и настаивать на том, что яблоко — это "красный апельсин". Не важно, какое прилагательное я добавлю перед ним, это не изменит тот _факт_, что один фрукт — яблоко, а другой — апельсин.

Лучше называть яблоко яблоком, применяя аккуратную и точную терминологию. Это позволяет нам легко понимать их **многочисленные сходства и отличия**, потому что мы все имеем ясное представление что такое "яблоко".

Из-за всей этой неразберихи с терминами я считаю, что само название "прототипное наследование" (а также некорректное использование связанных с ним терминов, таких как "класс", "конструктор", "экземпляр", "полиморфизм" и т.д.) принесло **больше вреда чем пользы** в понимании того, как _на самом деле_ работает JavaScript.

"Наследование" подразумевает операцию _копирования_, а JavaScript не копирует свойства объекта (по умолчанию). Вместо этого JS создает ссылку между двумя объектами, в результате один объект по сути _делегирует_ доступ к свойствам/функциям другому объекту. "Делегирование" (см. главу 6) — более точный термин для описания механизма связывания объектов в JavaScript.

Другой термин, который иногда встречается в JavaScript - это "дифференциальное наследование". Суть в том, что мы описываем поведение объекта с точки зрения того, что _отличается_ в нем от более общего описания. Например, вы можете сказать, что автомобиль является видом транспортного средства, у которого ровно 4 колеса, вместо того чтобы заново описывать все свойства транспортного средства (двигатель, и т.д.).

Если представить, что любой объект в JS является суммой всего поведения, которое _доступно_ через делегирование, и **мысленно объединить** все это поведение в одну реальную \*сущность\*\*, то можно предположить, что "дифференциальное наследование" (вроде как) подходящий термин.

Но как и "прототипное наследование", "дифференциальное наследование" претендует на то, что мысленная модель важнее того, что физически происходит в языке. Здесь упускается из виду факт, что объект `B` на самом деле не создается дифференциально, а создается с конкретно заданными характеристиками, а также с "дырами", где ничего не задано. Эти дыры (пробелы или отсутствующие определения) _могут_ заменяться механизмом делегирования, который на лету "заполняет их" делегированным поведением.

Объект по умолчанию не сворачивается в единый дифференциальный объект **посредством копирования**, как это подразумевается в мысленной модели "дифференциального наследования". Таким образом, "дифференциальное наследование" не слишком подходит для описания реального механизма работы `[[Prototype]]` в JavaScript.

Вы *можете\*\* придерживаться терминологии и мысленной модели "дифференциального наследования", но нельзя отрицать тот факт, что это *лишь\* упражнение ума в вашей голове, а не реальное поведение движка.

### "Конструкторы"

Вернемся к рассмотренному ранее коду:

```js
function Foo() {
  // ...
}

var a = new Foo();
```

Что именно заставляет нас подумать, что `Foo` является "классом"?

С одной стороны, мы видим использование ключевого слова `new`, совсем как в класс-ориентированных языках, когда создаются экземпляры классов. С другой стороны, кажется, что мы на самом деле выполняем метод _конструктора_ класса, потому что метод `Foo()` на самом деле вызывается, так же как конструктор реального класса вызывается при создании экземпляра.

У объекта `Foo.prototype` есть еще один фокус, который усиливает недоразумение, связанное с семантикой "конструкторов". Посмотрите на этот код:

```js
function Foo() {
  // ...
}

Foo.prototype.constructor === Foo; // true

var a = new Foo();
a.constructor === Foo; // true
```

По умолчанию объект `Foo.prototype` (во время объявления в первой строке примера!) получает публичное неперечислимое (см. главу 3) свойство `.constructor`, и это свойство является обратной ссылкой на функцию (в данном случае `Foo`), с которой связан этот объект. Более того, мы видим, что объект `a`, созданный путем вызова "конструктора" `new Foo()`, похоже тоже имеет свойство с именем `.constructor`, также указывающее на "функцию, создавшую его".

**Примечание:** На самом деле это неправда. У `a` нет свойства `.constructor`, и хотя `a.constructor` действительно разрешается в функцию `Foo`, "конструктор" **на самом деле не значит** "был сконструирован этой функцией". Мы разберемся с этим курьезом чуть позже.

Ах, да, к тому же... в мире JavaScript принято соглашение об именовании "классов" с заглавной буквы, поэтому тот факт что это `Foo`, а не `foo` является четким указанием, что мы хотим определить "класс". Это ведь абсолютно очевидно, не так ли!?

**Примечание:** Это соглашение имеет такое влияние, что многие JS линтеры _возмущаются_ когда вы вызываете `new` с методом, имя которого состоит из строчных букв, или не вызываете `new` с функцией, начинающейся с заглавной буквы. Удивительно, что мы с таким трудом пытаемся добиться (фальшивой) "класс-ориентированности" в JavaScript, что даже создаем правила для линтеров, чтобы гарантировать использование заглавных букв, хотя заглавные буквы _вообще_ **ничего** не значат для движка JS.

#### Конструктор или вызов?

В примере выше есть соблазн предположить, что `Foo` — это "конструктор", потому что мы вызываем её с `new` и видим, что она "конструирует" объект.

В действительности, `Foo` такой же "конструктор", как и любая другая функция в вашей программе. Функции сами по себе **не** являются конструкторами. Однако когда вы добавляете ключевое слово `new` перед обычным вызовом функции, это превращает вызов функции в "вызов конструктора". На самом деле `new` как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, **а также выполняется код самой функции**.

Например:

```js
function NothingSpecial() {
  console.log("Don't mind me!");
}

var a = new NothingSpecial();
// "Don't mind me!"

a; // {}
```

`NothingSpecial` — обычная функция, но когда она вызывается с `new`, то практически в качестве побочного эффекта _создает_ объект, который мы присваиваем `a`. Этот **вызов** был _вызовом конструктора_, но сама по себе функция `NothingSpecial` не является _конструктором_.

Иначе говоря, в JavaScript "конструктор" — это **любая функция, вызванная с ключевым словом `new`** перед ней.

Функции не являются конструкторами, но вызовы функций являются "вызовами конструктора" тогда и только тогда, когда используется `new`.

### Механика

Являются ли эти особенности единственными причинами многострадальных дискуссий о "классах" в JavaScript?

**Не совсем.** JS разработчики постарались симулировать поведение классов настолько, насколько это возможно:

```js
function Foo(name) {
  this.name = name;
}

Foo.prototype.myName = function () {
  return this.name;
};

var a = new Foo("a");
var b = new Foo("b");

a.myName(); // "a"
b.myName(); // "b"
```

Этот пример показывает два дополнительных трюка для "класс-ориентированности":

1. `this.name = name`: свойство `.name` добавляется в каждый объект (`a` и `b`, соответственно; см. главу 2 о привязке `this`), аналогично тому как экземпляры классов инкапсулируют значения данных.

2. `Foo.prototype.myName = ...`: возможно более интересный прием, добавляет свойство (функцию) в объект `Foo.prototype`. Теперь работает `a.myName()`, но каким образом?

В примере выше велик соблазн думать, что при создании `a` и `b` свойства/функции объекта `Foo.prototype` _копируются_ в каждый из объектов `a` и `b`. **Однако этого не происходит**.

В начале этой главы мы изучали ссылку `[[Prototype]]` — часть стандартного алгоритма `[[Get]]`, которая предоставляет запасной вариант поиска, если ссылка на свойство отсутствует в самом объекте.

В силу того, как создаются `a` и `b`, оба объекта получают внутреннюю ссылку `[[Prototype]]` на `Foo.prototype`. Когда `myName` не находится в `a` или `b` соответственно, она обнаруживается (через делегирование, см. главу 6) в `Foo.prototype`.

#### И снова о "конструкторе"

Вспомните наше обсуждение свойства `.constructor`. _Кажется_, что `a.constructor === Foo` означает, что в `a` есть реальное свойство `.constructor`, указывающее на `Foo`, верно? **Не верно.**

Это всего лишь путаница. На самом деле ссылка `.constructor` также _делегируется_ вверх по цепочке в `Foo.prototype`, у которого, **так уж случилось**, по умолчанию есть свойство `.constructor`, указывающее на `Foo`.

_Кажется_ ужасно удобным, что у объекта `a`, "созданного" `Foo`, будет доступ к свойству `.constructor`, которое указывает на `Foo`. Но это ложное чувство безопасности. Лишь по счастливой _случайности_ `a.constructor` указывает на `Foo` через делегирование `[[Prototype]]` по умолчанию. На самом деле есть несколько способов наломать дров, предполагая что `.constructor` означает "использовался для создания".

Начнем с того, что свойство `.constructor` в `Foo.prototype` по умолчанию есть лишь у объекта, создаваемого в момент объявления функции `Foo`. Если создать новый объект и заменить у функции ссылку на стандартный объект `.prototype`, то новый объект по умолчанию не получит свойства `.constructor`.

Рассмотрим:

```js
function Foo() {
  /* .. */
}

Foo.prototype = {
  /* .. */
}; // создаем новый объект-прототип

var a1 = new Foo();
a1.constructor === Foo; // false!
a1.constructor === Object; // true!
```

`Object(..)` не был "конструктором" `a1`, не так ли? Выглядит так, будто "конструктором" объекта должна быть `Foo()`. Многие разработчики думают, что `Foo()` создает объект, но эта идея трещит по швам, когда вы думаете что "constructor" значит "был создан при помощи". Ведь в таком случае `a1.constructor` должен указывать на `Foo`, но это не так!

Что же происходит? У `a1` нет свойства `.constructor`, поэтому он делегирует вверх по цепочке `[[Prototype]]` к `Foo.prototype`. Но и у этого объекта нет `.constructor` (в отличие от стандартного объекта `Foo.prototype`!), поэтому делегирование идет дальше, на этот раз до `Object.prototype` — вершины цепочки делегирования. У _этого_ объекта действительно есть `.constructor`, который указывает на встроенную функцию `Object(..)`.

**Разрушаем заблуждение.**

Конечно, можно вернуть объекту `Foo.prototype` свойство `.constructor`, но это придется сделать вручную, особенно если вы хотите, чтобы свойство соответствовало стандартному поведению и было не перечислимым (см. главу 3).

Например:

```js
function Foo() {
  /* .. */
}

Foo.prototype = {
  /* .. */
}; // создаем новый объект-прототип

// Необходимо правильно "пофиксить" отсутствующее свойство `.constructor`
// у нового объекта, выступающего в роли `Foo.prototype`.
// См. главу 3 про `defineProperty(..)`.
Object.defineProperty(Foo.prototype, "constructor", {
  enumerable: false,
  writable: true,
  configurable: true,
  value: Foo, // `.constructor` теперь указывает на `Foo`
});
```

Как видите, для исправления `.constructor` необходимо много ручной работы. Больше того, все это мы делаем ради поддержания ошибочного представления о том, что "constructor" означает "используется для создания". _Дорого_ же нам обходится эта иллюзия.

Факт в том, что `.constructor` объекта по умолчанию указывает на функцию, которая, в свою очередь, имеет обратную ссылку на объект — ссылку `.prototype`. Слова "конструктор" и "прототип" лишь наделяются по умолчанию ненадежным смыслом, который позднее может оказаться неверным. Лучше всего постоянно напоминать себе, что "конструктор не значит используется для создания".

`.constructor` — это не магическое неизменяемое свойство. Оно _является_, неперечисляемым (см. пример выше), но его значение доступно для записи (может быть изменено), и более того, вы можете добавить или перезаписать (намеренно или случайно) свойство с именем `constructor` в любом объекте любой цепочки `[[Prototype]]`, задав ему любое подходящее вам значение.

В силу того как алгоритм `[[Get]]` обходит цепочку `[[Prototype]]`, ссылка на свойство `.constructor`, найденная в любом узле цепочки, может получать значение, весьма отличающееся от ожидаемого.

Видите, насколько произвольным является его значение?

Что в итоге? Некая произвольная ссылка на свойство объекта, например `a1.constructor`, не может считаться _надежной_ ссылкой на функцию по умолчанию. Более того, как мы вскоре увидим, в результате небольшого упущения `a1.constructor` может вообще указывать на весьма странное и бессмысленное значение.

`a1.constructor` — слишком ненадежная и небезопасная ссылка, чтобы полагаться на нее в коде. **В общем случае таких ссылок по возможности следует избегать.**

## "(Прототипное) наследование"

Мы увидели некоторые типичные хаки для добавления механики "классов" в программы на JavaScript. Но "классы" JavaScript были бы неполными без попыток смоделировать "наследование".

На самом деле мы уже видели механизм под названием "прототипное наследование", когда объект `a` "унаследовал от" `Foo.prototype` функцию `myName()`. Но обычно под "наследованием" подразумевается отношение между двумя "классами", а не между "классом" и "экземпляром".

<img src="fig3.png">

Мы уже видели эту схему, на которой показано не только делегирование от объекта (или "экземпляра") `a1` к объекту `Foo.prototype`, но и от `Bar.prototype` к `Foo.prototype`, что отчасти напоминает концепцию наследования классов родитель-потомок. Вот только направление стрелок здесь другое, поскольку изображены делегирующие ссылки, а не операции копирования.

Вот типичный пример кода в "прототипном стиле", где создаются такие ссылки:

```js
function Foo(name) {
  this.name = name;
}

Foo.prototype.myName = function () {
  return this.name;
};

function Bar(name, label) {
  Foo.call(this, name);
  this.label = label;
}

// здесь мы создаем `Bar.prototype`
// связанный с `Foo.prototype`
Bar.prototype = Object.create(Foo.prototype);

// Осторожно! Теперь `Bar.prototype.constructor` отсутствует,
// и это придется "пофиксить" вручную,
// если вы привыкли полагаться на подобные свойства!

Bar.prototype.myLabel = function () {
  return this.label;
};

var a = new Bar("a", "obj a");

a.myName(); // "a"
a.myLabel(); // "obj a"
```

**Примечание:** Чтобы понять, почему `this` указывает на `a`, см. главу 2.

Самая важная строка здесь `Bar.prototype = Object.create( Foo.prototype )`. `Object.create(..)` _создает_ "новый" объект из ничего, и связывает внутреннюю ссылку `[[Prototype]]` этого объекта с указанным объектом (в данном случае `Foo.prototype`).

Другими словами, эта строка означает: "создать _новый_ объект 'Bar точка prototype', связанный с 'Foo точка prototype'".

При объявлении `function Bar() { .. }` функция `Bar`, как и любая другая, получает ссылку `.prototype` на объект по умолчанию. Но _этот_ объект не ссылается на `Foo.prototype`, как мы того хотим. Поэтому мы создаем *новый\*\* объект, который *имеет\* нужную ссылку, и отбрасываем исходный, неправильно связанный объект.

**Примечание:** Типичная ошибка — пытаться использовать следующие варианты, думая, что они _тоже_ сработают, но это приводит к неожиданным результатам:

```js
// работает не так, как вы ожидаете!
Bar.prototype = Foo.prototype;

// работает почти так, как нужно,
// но с побочными эффектами, которые возможно нежелательны :(
Bar.prototype = new Foo();
```

`Bar.prototype = Foo.prototype` не создает новый объект, на который ссылалось бы `Bar.prototype`. Вместо этого `Bar.prototype` становится еще одной ссылкой на `Foo.prototype`, и в результате `Bar` напрямую связывается с **тем же самым объектом**, что и `Foo`: `Foo.prototype`. Это значит, что когда вы начнете присваивать значения, например `Bar.prototype.myLabel = ...`, вы будете изменять **не отдельный объект**, а общий объект `Foo.prototype`, что повлияет на любые объекты, привязанные к `Foo.prototype`. Это наверняка не то, чего вы хотите. В противном случае вам вообще не нужен `Bar`, и стоит использовать только `Foo`, сделав код проще.

`Bar.prototype = new Foo()` **действительно** создает новый объект, корректно привязанный к `Foo.prototype`. Но для этого используется "вызов конструктора" `Foo(..)`. Если эта функция имеет какие-либо побочные эффекты (логирование, изменение состояния, регистрация в других объектах, **добавление свойств в `this`**, и т.д.), то эти побочные эффекты сработают во время привязывания (и возможно в отношении неправильного объекта!), а не только при создании конечных "потомков" `Bar`, как можно было бы ожидать.

Поэтому, для правильного привязывания нового объекта без побочных эффектов от вызова `Foo(..)` у нас остается лишь `Object.create(..)`. Небольшой недостаток состоит в том, что нам приходится создавать новый объект и выбрасывать старый, вместо того чтобы модифицировать существующий стандартный объект.

Было бы _здорово_ если бы существовал стандартный и надежный способ поменять привязку существующего объекта. До ES6 был нестандартный и не полностью кроссбраузерный способ через свойство `.__proto__`, которое можно изменять. В ES6 добавлена вспомогательная утилита `Object.setPrototypeOf(..)`, которая проделывает нужный трюк стандартным и предсказуемым способом.

Сравните пред-ES6 и стандартизованный в ES6 способ привязки `Bar.prototype` к `Foo.prototype`:

```js
// пред-ES6
// выбрасывает стандартный существующий `Bar.prototype`
Bar.prototype = Object.create(Foo.prototype);

// ES6+
// изменяет существующий `Bar.prototype`
Object.setPrototypeOf(Bar.prototype, Foo.prototype);
```

Если отбросить небольшой проигрыш в производительности (выбрасывание объекта, который позже удаляется сборщиком мусора), то способ с `Object.create(..)` немного короче и может даже читабельнее, чем подход ES6+. Хотя это всего лишь пустые разговоры о синтаксисе.

### Инспектируем связи между "классами"

Что если у вас есть объект `a` и вы хотите выяснить, какому объекту он делегирует? Инспектирование экземпляра (объект в JS) с целью найти его предка (делегирующая связь в JS) в традиционных класс-ориентированных языках часто называют _интроспекцией_ (или _рефлексией_).

Рассмотрим:

```js
function Foo() {
	// ...
}

Foo.prototype.blah = ...;

var a = new Foo();
```

Как выполнить интроспекцию `a`, чтобы найти его "предка" (делегирующую связь)? Первый подход использует путаницу с "классами":

```js
a instanceof Foo; // true
```

Оператор `instanceof` принимает в качестве операнда слева обычный объект, а в качества операнда справа — **функцию**. `instanceof` отвечает на следующий вопрос: **присутствует ли где-либо в цепочке `[[Prototype]]` объекта `a` объект, на который указывает `Foo.prototype`?**

К сожалению, это значит, что вы можете получить сведения о "происхождении" некоторого объекта (`a`) только имея некоторую **функцию** (`Foo` c её ссылкой `.prototype`). Если у вас есть два произвольных объекта, например `a` и `b`, и вы хотите узнать, связаны ли сами эти _объекты_ друг с другом через цепочку `[[Prototype]]`, одного `instanceof` будет недостаточно.

**Примечание:** Если вы используете встроенную утилиту `.bind(..)` для создания жестко привязанной функции (см. главу 2), то у созданной функции не будет свойства `.prototype`. При использовании `instanceof` с такой функцией прозрачно подставляется `.prototype` _целевой функции_, из которой была создана жестко привязанная функция.

Использование функции с жесткой привязкой для "вызова конструктора" крайне маловероятно, но если вы сделаете это, то она будет вести себя так, как если бы вы вызвали _целевую функцию_. Это значит, что вызов `instanceof` с жестко привязанной функцией также ведет себя в соответствии с оригинальной функцией.

Этот фрагмент кода показывает нелепость попыток рассуждать об отношениях между **двумя объектами** используя семантику "классов" и `instanceof`:

```js
// вспомогательная утилита для проверки
// связан ли `o1` (через делегирование) с `o2`
function isRelatedTo(o1, o2) {
  function F() {}
  F.prototype = o2;
  return o1 instanceof F;
}

var a = {};
var b = Object.create(a);

isRelatedTo(b, a); // true
```

Внутри `isRelatedTo(..)` мы временно используем функцию `F`, меняя значение её свойства `.prototype` на объект `o2`, а затем спрашиваем, является ли `o1` "экземпляром" `F`. Ясно, что `o1` _на самом деле_ не унаследован от и даже не создан с помощью `F`, поэтому должно быть понятно, что подобные приемы бессмысленны и сбивают с толку. **Проблема сводится к несуразности семантики классов, навязываемой JavaScript**, что наглядно показано на примере косвенной семантики `instanceof`.

Второй подход к рефлексии `[[Prototype]]` более наглядный:

```js
Foo.prototype.isPrototypeOf(a); // true
```

Заметьте, что в этом случае нам неинтересна (и даже _не нужна_) `Foo`. Нам просто нужен **объект** (в данном случае произвольный объект с именем `Foo.prototype`) для сопоставления его с другим **объектом**. `isPrototypeOf(..)` отвечает на вопрос: **присутствует ли где-либо в цепочке `[[Prototype]]` объекта `a` объект `Foo.prototype`?**

Тот же вопрос, и в точности такой же ответ. Но во втором подходе нам не нужна **функция** (`Foo`) для косвенного обращения к её свойству `.prototype`.

Нам _просто нужны_ два **объекта** для выявления связи между ними. Например:

```js
// Просто: присутствует ли `b` где-либо
// в цепочке [[Prototype]] объекта `c`
b.isPrototypeOf(c);
```

Заметьте, что в этом подходе вообще не требуется функция ("класс"). Используются прямые ссылки на объекты `b` и `c`, чтобы выяснить нет ли между ними связи. Другими словами, наша утилита `isRelatedTo(..)` уже встроена в язык и называется `isPrototypeOf(..)`.

Мы можем напрямую получить `[[Prototype]]` объекта. В ES5 появился стандартный способ сделать это:

```js
Object.getPrototypeOf(a);
```

Здесь видно, что ссылка на объект является тем, что мы и ожидаем:

```js
Object.getPrototypeOf(a) === Foo.prototype; // true
```

В большинстве браузеров (но не во всех!) давно добавлена поддержка нестандартного альтернативного способа доступа к `[[Prototype]]`:

```js
a.__proto__ === Foo.prototype; // true
```

Загадочное свойство `.__proto__` (стандартизовано лишь в ES6!) "магически" возвращает ссылку на внутреннее свойство `[[Prototype]]` объекта, что весьма полезно, если вы хотите напрямую проинспектировать (или даже обойти: `.__proto__.__proto__...`) цепочку.

Аналогично рассмотренному ранее `.constructor`, свойство `.__proto__` отсутствует у инспектируемого объекта (`a` в нашем примере). На самом деле оно есть (и является неперечисляемым, см. главу 2) у встроенного `Object.prototype`, наряду с другими известными утилитами (`.toString()`, `.isPrototypeOf(..)`, и т.д.).

Более того, `.__proto__` выглядит как свойство, но правильнее думать о нем как о геттере/сеттере (см. главу 3).

Грубо говоря, можно представить, что `.__proto__` реализовано так (см. главу 3 об определениях свойств объекта):

```js
Object.defineProperty(Object.prototype, "__proto__", {
  get: function () {
    return Object.getPrototypeOf(this);
  },
  set: function (o) {
    // setPrototypeOf(..) доступно начиная с ES6
    Object.setPrototypeOf(this, o);
    return o;
  },
});
```

Таким образом, когда мы обращаемся (получаем значение) к `a.__proto__`, это похоже на вызов `a.__proto__()` (вызов функции геттера). В \*этом\*\* вызове функции `this` указывает на `a`, несмотря на то что функция геттера находится в объекте `Object.prototype` (см. главу 2 о правилах привязки `this`), так что это равносильно `Object.getPrototypeOf( a )`.

Значение `.__proto__` можно также изменять, например с помощью функции `Object.setPrototypeOf(..)` в ES6, как показано выше. Однако обычно **не следует изменять `[[Prototype]]` существующего объекта**.

Глубоко внутри некоторых фреймворков можно встретить сложные, продвинутые механизмы, позволяющие выполнять трюки наподобие "создания производного класса" от `Array`, но обычно подобные вещи не поощряются в повседневной практике, поскольку такой код _гораздо_ труднее понимать и сопровождать.

**Примечание:** В ES6 добавлено ключевое слово `class`, с помощью которого можно делать вещи, напоминающие "создание производных классов" от встроенных объектов, таких как `Array`. Обсуждение синтаксиса `class` из ES6 см. в Приложении А.

В остальном же единственным исключением будет установка свойства `[[Prototype]]` стандартного объекта `.prototype` функции, чтобы оно ссылалось на какой-то другой объект (помимо `Object.prototype`). Это позволит избежать замены этого стандартного объекта новым объектом. В любой другой ситуации **лучше всего считать ссылку `[[Prototype]]` доступной только для чтения**, чтобы облегчить чтение вашего кода в будущем.

**Примечание:** В сообществе JavaScript неофициально закрепилось название двойного подчеркивания, особенно перед именами свойств (как `__proto__`): "dunder". Поэтому в мире JavaScript "крутые ребята" обычно произносят `__proto__` как "dunder proto".

## Объектные ссылки

Как мы уже видели, механизм `[[Prototype]]` является внутренней ссылкой, существующей у объекта, который ссылается на другой объект.

Переход по этой ссылке выполняется (в основном) когда происходит обращение к свойству/методу первого объекта, и это свойство/метод отсутствует. В таком случае ссылка `[[Prototype]]` указывает движку, что свойство/метод нужно искать в связанном объекте. Если и в этом объекте ничего не находится, то происходит переход по его ссылке `[[Prototype]]`, и так далее. Эта последовательность ссылок между объектами образует то, что называется "цепочкой прототипов".

### Создание ссылок

Мы подробно объяснили, почему механизм `[[Prototype]]` в JavaScript **не** похож на "классы", и увидели, что вместо этого создаются **ссылки** между подходящими объектами.

В чем смысл механизма `[[Prototype]]`? Почему многие JS разработчики прикладывают так много усилий (эммулируя классы), чтобы настроить эти ссылки?

Помните, как в начале этой главы мы сказали, что `Object.create(..)` станет нашим героем? Теперь вы готовы это увидеть.

```js
var foo = {
  something: function () {
    console.log("Скажи что-нибудь хорошее...");
  },
};

var bar = Object.create(foo);

bar.something(); // Скажи что-нибудь хорошее...
```

`Object.create(..)` создает новый объект (`bar`), связанный с объектом, который мы указали (`foo`), и это дает нам всю мощь (делегирование) механизма `[[Prototype]]`, но без ненужных сложностей вроде функции `new`, выступающей в роли классов и вызовов конструктора, сбивающих с толку ссылок `.prototype` и `.constructor`, и прочих лишних вещей.

**Примечание:** `Object.create(null)` создает объект с пустой (или `null`) ссылкой `[[Prototype]]`, поэтому этот объект не сможет ничего делегировать. Поскольку у такого объекта нет цепочки прототипов, оператору `instanceof` (рассмотренному ранее) нечего проверять, и он всегда вернет `false`. Эти специальные объекты с пустым `[[Prototype]]` часто называют "словарями", поскольку они обычно используются исключительно для хранения данных в свойствах, потому что у них не может быть никаких побочных эффектов от делегируемых свойств/функций цепочки `[[Prototype]]`, и они являются абсолютно плоскими хранилищами данных.

Для создания продуманных связей между двумя объектами нам не _нужны_ классы. Нам нужно **только лишь** связать объекты друг с другом для делегирования, и `Object.create(..)` дает нам эту связь без лишней возни с классами.

#### Полифилл для `Object.create()`

`Object.create(..)` была добавлена в ES5. Вам может понадобиться поддержка пред-ES5 окружения (например, старые версии IE), поэтому давайте рассмотрим простенький **частичный** полифилл для `Object.create(..)`:

```js
if (!Object.create) {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

В этом полифилле используется временно создаваемая функция `F`, и её свойство `.prototype` переопределяется так, чтобы указывать на объект, с которым нужно создать связь. Затем мы используем `new F()`, чтобы создать новый объект, который будет привязан нужным нам образом.

Такой вариант использования `Object.create(..)` встречается в подавляющем большинстве случаев, поскольку эту часть _можно_ заменить полифиллом. В ES5 стандартная функция `Object.create(..)` предоставляет дополнительную функциональность, которую нельзя **заменить полифиллом** в пред-ES5. Для полноты картины рассмотрим, в чем она заключается:

```js
var anotherObject = {
  a: 2,
};

var myObject = Object.create(anotherObject, {
  b: {
    enumerable: false,
    writable: true,
    configurable: false,
    value: 3,
  },
  c: {
    enumerable: true,
    writable: false,
    configurable: false,
    value: 4,
  },
});

myObject.hasOwnProperty("a"); // false
myObject.hasOwnProperty("b"); // true
myObject.hasOwnProperty("c"); // true

myObject.a; // 2
myObject.b; // 3
myObject.c; // 4
```

Второй аргумент `Object.create(..)` указывает свойства, которые будут добавлены в создаваемый объект, объявляя _дескриптор_ каждого нового свойства (см. главу 3). Поскольку полифиллинг дескрипторов свойств в пред-ES5 невозможен, эту дополнительную функциональность `Object.create(..)` также невозможно реализовать в виде полифилла.

В большинстве случаев используется лишь та часть функциональности `Object.create(..)`, которую можно заменить полифиллом, поэтому большинство разработчиков устраивает использование **частичного полифилла** в пред-ES5 окружениях.

Некоторые разработчики придерживаются более строгого подхода, считая, что можно использовать только _полные_ полифиллы. Поскольку `Object.create(..)` — одна из тех утилит, что нельзя полностью заменить полифиллом, такой строгий подход предписывает, что если вы хотите использовать `Object.create(..)` в пред-ES5 окружении, то вместо полифилла следует применить собственную утилиту, и вообще воздержаться от использования имени `Object.create`. Вместо этого можно определить свою собственную утилиту:

```js
function createAndLinkObject(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var anotherObject = {
  a: 2,
};

var myObject = createAndLinkObject(anotherObject);

myObject.a; // 2
```

Я не разделяю такой подход. Меня полностью устраивает показанный выше частичный полифилл `Object.create(..)` и его использование в коде даже в пред-ES5. Решайте сами, какой подход вам ближе.

### Ссылки в роли запасных свойств?

Существует соблазн думать, что эти ссылки между объектами _в основном_ предоставляют что-то вроде запасного варианта на случай "отсутствующих" свойств или методов. И хотя такой вывод допустим, я не считаю что это верный способ размышления о `[[Prototype]]`.

Рассмотрим:

```js
var anotherObject = {
  cool: function () {
    console.log("круто!");
  },
};

var myObject = Object.create(anotherObject);

myObject.cool(); // "круто!"
```

Этот код работает благодаря `[[Prototype]]`, но если вы написали его так, что `anotherObject` играет роль запасного варианта **на случай если** `myObject` не сможет обработать обращение к некоторому свойству/методу, то вероятно ваше ПО будет содержать больше "магии" и будет сложнее для понимания и сопровождения.

Я не хочу сказать, что такой подход является в корне неверным шаблоном проектирования, но он нехарактерен для JS. Если вы используете его, возможно вам стоит сделать шаг назад и подумать, является ли такое решение уместным и разумным.

**Примечание:** В ES6 добавлена продвинутая функциональность, называемая `Proxy`, с помощью которой можно реализовать что-то наподобие поведения "отсутствующих методов". `Proxy` выходит за рамки этой книги, но будет подробно рассмотрена в одной из следующих книг серии _"Вы не знаете JS"_.

**Не упустите одну важную, но едва уловимую мысль.**

Явно проектируя ПО таким образом, что разработчик может вызвать, к примеру, `myObject.cool()`, и это будет работать даже при отсутствии метода `cool()` у `myObject`, вы добавляете немного "магии" в дизайн вашего API, что может в будущем преподнести сюрприз другим разработчикам, которые будут поддерживать ваш код.

Но вы можете спроектировать API и без подобной "магии", не отказываясь при этом от преимуществ ссылки `[[Prototype]]`.

```js
var anotherObject = {
  cool: function () {
    console.log("круто!");
  },
};

var myObject = Object.create(anotherObject);

myObject.doCool = function () {
  this.cool(); // внутреннее делегирование!
};

myObject.doCool(); // "круто!"
```

Здесь мы вызываем `myObject.doCool()` — метод, который _действительно есть_ у объекта `myObject`, делая наш API более явным (менее "магическим"). _Внутри_ наша реализация следует **шаблону делегирования** (см. главу 6), используя делегирование `[[Prototype]]` к `anotherObject.cool()`.

Другими словами, делегирование как правило преподносит меньше сюрпризов, если оно является частью внутренней реализации, а не выставлено наружу в дизайне API. Мы изучим **делегирование** в мельчайших подробностях в следующей главе.

## Обзор

При попытке обратиться к несуществующему свойству объекта внутренняя ссылка `[[Prototype]]` этого объекта задает дальнейшее направление поиска для операции `[[Get]]` (см. главу 3). Этот каскад ссылок от объекта к объекту образует "цепочку прототипов" (чем то похожую на цепочку вложенных областей видимости) для обхода при разрешении свойства.

У обычных объектов есть встроенный объект `Object.prototype` на конце цепочки прототипов (похоже на глобальную область видимости при поиске по цепочке областей видимости), где процесс разрешения свойства остановится, если свойство не будет найдено в предыдущих звеньях цепочки. У этого объекта есть утилиты `toString()`, `valueOf()` и несколько других, благодаря чему все объекты в языке имеют доступ к ним.

Наиболее популярный способ связать два объекта друг с другом — использовать ключевое слово `new` с вызовом функции, что помимо четырех шагов (см. главу 2) создаст новый объект, привязанный к другому объекту.

Этим "другим объектом" является объект, на который указывает свойство `.prototype` функции, вызванной с `new`. Функции, вызываемые с `new`, часто называют "конструкторами", несмотря на то что они не создают экземпляры классов, как это делают _конструкторы_ в традиционных класс-ориентированных языках.

Хотя эти механизмы JavaScript могут напоминать "создание экземпляров классов" и "наследование классов" из традиционных класс-ориентированных языков, ключевое отличие в том, что в JavaScript не создаются копии. Вместо этого объекты связываются друг с другом через внутреннюю цепочку `[[Prototype]]`.

По множеству причин, среди которых не последнюю роль играет терминологический прецедент, "наследование" (и "прототипное наследование") и все остальные ОО-термины не имеют смысла, учитывая то как _на самом деле_ работает JavaScript.

Более подходящим термином является "делегирование", поскольку эти связи являются не _копиями_, а делегирующими **ссылками**.

# 
# Вы не знаете JS: *this* и прототипы объектов
# Глава 6: Делегирование поведения

В главе 5 мы подробно изучили механизм `[[Prototype]]` и показали, *почему* его нельзя корректно описать в терминах "класс" или "наследование" (несмотря на бесчисленные попытки на протяжении почти двух десятилетий). Нам пришлось продираться не только через многословный синтаксис (`.prototype`, захламляющий код), но и через всевозможные ловушки (такие как непредвиденное разрешение `.constructor` или уродливый псевдополиморфный синтаксис). Мы также рассмотрели различные варианты использования "примесей", которые часто используются, чтобы сгладить эти острые углы.

Возникает закономерный вопрос: почему так сложно делать такие простые вещи? Теперь, когда мы приоткрыли завесу и увидели, насколько грязно все устроено внутри, неудивительно, что большинство JS разработчиков никогда не погружаются так глубоко, поручая эту работу библиотеке "классов".

Я надеюсь, что вы не собираетесь просто обойти все эти детали, поручив их "черному ящику". Так что давайте разберемся, как мы *могли и должны были бы* думать о механизме `[[Prototype]]` в JS, используя **гораздо более простой и прямой путь**, чем вся эта путаница с классами.

Как вы уже знаете из Главы 5, механизм `[[Prototype]]` — это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект.

Эта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка `[[Prototype]]` говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке `[[Prototype]]` и так далее. Эта последовательность ссылок между объектами образует так называемую "цепочку прототипов".

Другими словами, реальный механизм, важнейшая часть функциональности, доступной нам в JavaScript — это по сути **объекты, связанные с другими объектами**.

Данное наблюдение является фундаментальным и критически важным для понимания мотивов и подходов, описанных далее в этой главе!

## Towards Delegation-Oriented Design

Чтобы использовать `[[Prototype]]` наиболее правильным способом, необходимо осознавать, что этот шаблон проектирования фундаментально отличается от классов (см. главу 4).

**Примечание:** *Некоторые* принципы класс-ориентированного проектирования остаются крайне актуальными, так что не отбрасывайте все, что вы знаете (а всего лишь большую часть!). Например, *инкапсулирование* — весьма мощный инструмент, совместимый с делегированием (хотя такое сочетание встречается редко).

Нам нужно изменить наш способ мышления с шаблона проектирования "класс/наследование" на шаблон проектирования "делегирование поведения". Если большую часть вашего обучения или карьеры в программировании вы имели дело с классами, это может показаться некомфортным или неестественным. Попробуйте проделать это умственное упражнение несколько раз, чтобы привыкнуть к такому совершенно иному способу мышления.

Сначала я покажу вам некоторые теоретические упражнения, а затем мы посмотрим на более конкретный пример, который вы сможете использовать на практике в вашем коде.

### Теория классов

Предположим, что у нас есть несколько похожих задач ("XYZ", "ABC", etc), которые мы хотим смоделировать в нашем ПО.

При использовании классов проектирование происходит так: определяем общий родительский (базовый) класс `Task`, в котором задается поведение всех "похожих" задач. Затем определяем дочерние классы `XYZ` и `ABC`, которые  наследуют от `Task` и добавляют уточненное поведение для выполнения собственных задач.

**Важно отметить,** что шаблон проектирования классов диктует нам для получения максимальной выгоды от наследования использовать переопределение методов (и полиморфизм). В этом случае мы переопределяем определение некоторого общего метода `Task` в `XYZ`, возможно даже используя `super` для вызова базовой версии метода, добавляя к нему новое поведение. **Вероятно вы найдете довольно много мест**, где можно "абстрагировать" общее поведение в родительский класс, и уточнить (переопределить) его в дочерних классах.

Вот примерный псевдокод для такого сценария:

```js
class Task {
	id;

	// конструктор `Task()`
	Task(ID) { id = ID; }
	outputTask() { output( id ); }
}

class XYZ inherits Task {
	label;

	// конструктор `XYZ()`
	XYZ(ID,Label) { super( ID ); label = Label; }
	outputTask() { super(); output( label ); }
}

class ABC inherits Task {
	// ...
}
```

Теперь вы можете создать одну или более **копий** дочернего класса `XYZ`, и использовать эти экземпляры для выполнения задачи "XYZ". Эти экземпляры **копируют** как общее поведение из `Task`, так и уточненное поведение из `XYZ`. Аналогично и экземпляры класса `ABC` будут иметь копии поведения `Task` и уточненного поведения `ABC`. Обычно после создания вы взаимодействуете только с этими экземплярами (но не с классами), поскольку у каждого экземпляра есть копия всего поведения, которое необходимо для выполнения задачи.

### Теория делегирования

А теперь давайте поразмышляем о той же предметной области, но с использованием *делегирования поведения* вместо *классов*.

Сначала определяется **объект** (не класс и не `function`, что бы ни говорили вам большинство JS разработчиков) по имени `Task` с конкретным поведением, включающим в себя вспомогательные методы, которыми могут пользоваться различные задачи (читай *делегировать*!). Затем для каждой задачи ("XYZ", "ABC") вы определяете **объект** с данными/поведением, специфичными для данной задачи. Вы **связываете** специфические объекты задач со вспомогательным объектом `Task`, позволяя им делегировать ему в случае необходимости.

В сущности, для выполнения задачи "XYZ" нам необходимо поведение двух объектов одного уровня (`XYZ` и `Task`). Но вместо композиции через копирование классов мы можем оставить их в виде отдельных объектов, и разрешить объекту `XYZ` **делегировать** объекту `Task`, когда это необходимо.

Вот простой пример кода, показывающий как этого добиться:

```js
var Task = {
	setID: function(ID) { this.id = ID; },
	outputID: function() { console.log( this.id ); }
};

// `XYZ` делегирует `Task`
var XYZ = Object.create( Task );

XYZ.prepareTask = function(ID,Label) {
	this.setID( ID );
	this.label = Label;
};

XYZ.outputTaskDetails = function() {
	this.outputID();
	console.log( this.label );
};

// ABC = Object.create( Task );
// ABC ... = ...
```

В этом примере `Task` и `XYZ` не являются классами (или функциями), это **просто объекты**. С помощью `Object.create(..)` объект `XYZ` делегирует объекту `Task` через ссылку `[[Prototype]]` (см. главу 5).

По аналогии с класс-ориентированностью (или, OO — объектно-ориентированный), я назвал этот стиль кода **"OLOO"** (objects-linked-to-other-objects — "объекты, связанные с другими объектами"). Все, что нас *действительно* интересует — это тот факт, что объект `XYZ` делегирует объекту `Task` (как и объект `ABC`).

В JavaScript механизм `[[Prototype]]` связывает **объекты** с другими **объектами**. Нет никаких абстрактных механизмов наподобие "классов", как бы вы ни пытались убедить себя в обратном. Это как грести на каноэ вверх по реке: вы *можете* это сделать, но *выбираете* путь против естественного течения, так что вам очевидно **будет труднее добраться в нужное место**.

Вот некоторые другие отличия **стиля OLOO**:

1. Оба члена данных `id` и `label` из предыдущего примера с классами являются здесь свойствами данных непосредственно `XYZ` (ни одного из них нет в `Task`). Как правило в случае делегирования через `[[Prototype]]`, **вы хотите, чтобы состояние хранилось в делегирующих объектах** (`XYZ`, `ABC`), а не в делегате (`Task`).
2. При использовании шаблона проектирования классов мы специально назвали `outputTask` одинаково как в родителе (`Task`), так и в потомке (`XYZ`), чтобы воспользоваться переопределением (полиморфизм). В случае делегирования поведения мы делаем ровно наоборот: **при любой возможности избегаем одинаковых имен** на разных уровнях цепочки `[[Prototype]]` (это называется затенением — см. главу 5), поскольку коллизии имен вынуждают использовать ужасный/хрупкий код для устранения неоднозначности ссылок (см. главу 4), а мы хотим избежать этого.

   Этот шаблон проектирования предписывает отказ от общих, расплывчатых имен методов (предрасположенных к переопределению) в пользу более описательных имен, *характерных* для поведения каждого конкретного объекта. **Это может сделать код проще для понимания/сопровождения**, потому что имена методов (не только в месте их определения, но и по всему коду) становятся более очевидными (самодокументируемыми).
3. `this.setID(ID);` внутри метода объекта `XYZ` сначала ищет `setID(..)` в `XYZ`, но поскольку метода с таким именем нет в `XYZ`, *делегирование* `[[Prototype]]` означает, что можно пройти по ссылке на `Task`, чтобы найти там `setID(..)`, что и происходит. Более того, благодаря неявным правилам привязки `this` (см. главу 2), при выполнении `setID(..)`, хотя этот метод и был найден в `Task`, `this` для данного вызова функции — это `XYZ`, как мы того и желали. То же самое происходит и с `this.outputID()` чуть дальше в листинге кода.

   Другими словами, методы общего назначения, существующие в `Task`, доступны нам при взаимодействии с `XYZ`, потому что `XYZ` может делегировать `Task`.

**Делегирование поведения** означает: пусть у одного объекта (`XYZ`) будет делегирование (к `Task`) для обращения к свойству или методу, отсутствующему в объекте (`XYZ`).

Это *чрезвычайно мощный* шаблон проектирования, сильно отличающийся от идеи родительских и дочерних классов, наследования, полиморфизма, и т.п. Вместо того чтобы мысленно выстраивать вертикальную иерархию объектов от Родителей к Потомкам, представьте себе равноправные объекты одного уровня, между которыми в любом направлении могут идти делегирующие ссылки.

**Примечание:** Правильнее использовать делегирование как внутреннюю деталь реализации, а не выставлять его наружу в дизайне API. В нашем дизайне API в примере выше мы не подталкиваем разработчиков использовать `XYZ.setID()` (хотя могли бы это сделать!). Мы как бы *прячем* делегирование как внутреннюю деталь нашего API, где `XYZ.prepareTask(..)` делегирует к `Task.setID(..)`. Подробнее см. главу 5, раздел "Ссылки в роли запасных свойств?".

#### Взаимное делегирование (запрещено)

Нельзя создавать *цикл*, где между двумя или более объектами есть взаимное (двунаправленное) делегирование. Если вы создадите `B`, связанный с `A`, а затем попытаетесь связать `A` с `B`, то получите ошибку.

Жаль, что это запрещено (не то чтобы ужасно, но слегка раздражает). Если бы вы обратились к свойству/методу, которого нет ни у одного из объектов, это привело бы к бесконечной рекурсии в цикле `[[Prototype]]`. Но если бы все ссылки были на месте, тогда `B` мог делегировать `A` и наоборот, и это *могло* бы сработать. Это позволило бы использовать любой из объектов для делегирования другому. Есть несколько частных случаев, где это было бы полезным.

Но это запрещено, потому что разработчики конкретных реализаций движка обнаружили, что с точки зрения производительности выгоднее проверить (и отклонить!) наличие бесконечных циклических ссылок один раз во время установки, чем выполнять эту проверку каждый раз при обращении к свойству объекта.

#### Отладка

Рассмотрим вкратце один тонкий момент, который иногда сбивает с толку разработчиков. В целом спецификация JS не контролирует то, в каком виде конкретные значения и структуры отображаются в консоли разработчика в браузере. Поэтому каждый браузер/движок интерпретирует подобные вещи по-своему, и эта интерпретация *может различаться*. В частности поведение, которое мы сейчас рассмотрим, встречается только в Chrome Developer Tools.

Посмотрите на этот "традиционный" стиль "конструктора классов" в JS коде, и то, что отображается в *консоли* Chrome Developer Tools:

```js
function Foo() {}

var a1 = new Foo();

a1; // Foo {}
```

Обратите внимание на последнюю строку кода: в результате вычисления выражения `a1` выводится `Foo {}`. Если запустить этот код в Firefox, то скорее всего мы увидим `Object {}`. Почему такая разница, и что означают эти значения в консоли?

Chrome по сути говорит нам, что "{} — это пустой объект, который был создан функцией с именем 'Foo'". Firefox же говорит, что "{} — это пустой объект, созданный на основе Object". Маленькое отличие состоит в том, что Chrome отслеживает в виде *внутреннего свойства* имя реальной функции, создавшей объект, а другие браузеры такую информацию не отслеживают.

Есть соблазн попытаться объяснить это с помощью механизмов JavaScript:

```js
function Foo() {}

var a1 = new Foo();

a1.constructor; // Foo(){}
a1.constructor.name; // "Foo"
```

Получается, что Chrome выводит "Foo", всего-навсего проверяя свойство `.constructor.name` объекта? И "да", и "нет".

Рассмотрим код:

```js
function Foo() {}

var a1 = new Foo();

Foo.prototype.constructor = function Gotcha(){};

a1.constructor; // Gotcha(){}
a1.constructor.name; // "Gotcha"

a1; // Foo {}
```

Несмотря на то, что мы изменили `a1.constructor.name` на другое значение ("Gotcha"), консоль Chrome по-прежнему использует имя "Foo".

Итак, получается, что ответ на предыдущий вопрос (используется ли `.constructor.name`?) — **нет**, информация отслеживается где-то в другом месте, внутри движка.

Но не торопитесь! Давайте посмотрим, как это работает при использовании стиля OLOO:

```js
var Foo = {};

var a1 = Object.create( Foo );

a1; // Object {}

Object.defineProperty( Foo, "constructor", {
	enumerable: false,
	value: function Gotcha(){}
});

a1; // Gotcha {}
```

Ага! **Попались!** Здесь консоль Chrome **нашла** и использует `.constructor.name`. На самом деле, на момент написания этой книги данное поведение было идентифицировано как баг в Chrome, и сейчас, когда вы её читаете, баг скорее всего исправлен. Поэтому в вашем браузере может выдаваться корректный результат `a1; // Object {}`.

Если не обращать внимания на этот баг, то внутреннее отслеживание "имени конструктора" (по-видимому, только в целях отладки в консоли) в Chrome является собственным поведением Chrome, выходящим за рамки спецификации.

Если вы не используете "конструктор" для создания объектов, как того и требует OLOO стиль кодирования в этой главе, тогда Chrome *не* будет отслеживать внутреннее "имя конструктора" для этих объектов, и они будут отображаться в консоли как "Object {}", то есть, "объекты, созданные из Object()".

**Не думайте**, что это является недостатком OLOO стиля. Когда вы используете шаблон проектирования на основе OLOO и делегирования поведения, совершенно неважно, *кто* "создал" объект (то есть, *какая функция* была вызвана с `new`?). Отслеживание "имени конструктора" внутри Chrome полезно только если вы полностью пишете код "в стиле классов", но совершенно неактуально при использовании OLOO делегирования.

### Сравнение мысленных моделей

Теперь, когда вы видите как минимум теоретическую разницу между шаблонами проектирования "класс" и "делегирование", давайте посмотрим на то, как эти шаблоны влияют на мысленные модели, которые мы используем, рассуждая о коде.

Мы рассмотрим абстрактный код ("Foo", "Bar"), и сравним два способа его реализации (OO против OLOO). Первый фрагмент кода использует классический ("прототипный") OO стиль:

```js
function Foo(who) {
	this.me = who;
}
Foo.prototype.identify = function() {
	return "I am " + this.me;
};

function Bar(who) {
	Foo.call( this, who );
}
Bar.prototype = Object.create( Foo.prototype );

Bar.prototype.speak = function() {
	alert( "Hello, " + this.identify() + "." );
};

var b1 = new Bar( "b1" );
var b2 = new Bar( "b2" );

b1.speak();
b2.speak();
```

Родительский класс `Foo` наследуется дочерним классом `Bar`, после чего создаются два экземпляра этого класса `b1` и `b2`. В результате `b1` делегирует `Bar.prototype`, который делегирует `Foo.prototype`. Все выглядит довольно знакомо, ничего особенного.

Теперь давайте реализуем **ту же самую** функциональность, используя код в стиле *OLOO*:

```js
var Foo = {
	init: function(who) {
		this.me = who;
	},
	identify: function() {
		return "I am " + this.me;
	}
};

var Bar = Object.create( Foo );

Bar.speak = function() {
	alert( "Hello, " + this.identify() + "." );
};

var b1 = Object.create( Bar );
b1.init( "b1" );
var b2 = Object.create( Bar );
b2.init( "b2" );

b1.speak();
b2.speak();
```

Мы используем преимущество делегирования `[[Prototype]]` от `b1` к `Bar`, и от `Bar` к `Foo`, аналогично тому, как сделали это в предыдущем примере с `b1`, `Bar.prototype`, и `Foo.prototype`. **У нас по-прежнему есть те же самые 3 объекта, связанные вместе**.

Но важно то, что мы значительно упростили *все остальное*, потому что теперь у нас просто есть **объекты**, связанные друг с другом, без всех этих ненужных вещей, которые выглядят (но не ведут себя) как классы, с конструкторами, прототипами и вызовами `new`.

Спросите себя: если я могу получить с OLOO точно такую же функциональность, что и с "классами", но OLOO проще и понятнее, **может быть OLOO лучше**?

Давайте рассмотрим мысленные модели, связанные с двумя этими примерами.

Пример с классами предполагает следующую мысленную модель сущностей и взаимосвязей между ними:

<img src="fig4.png">

На самом деле, это немного нечестно, потому что здесь показано множество дополнительных нюансов, которые вы *строго говоря* не должны постоянно держать в голове (хотя вам *надо* понимать их!). С одной стороны, это довольно сложная последовательность взаимосвязей. Но с другой стороны, если вы внимательно изучите эти стрелки со связями, то поймете, что механизмы JS обладают **потрясающей внутренней целостностью и непротиворечивостью**.

Например, функции в JS могут обращаться к `call(..)`, `apply(..)` и `bind(..)` (см. главу 2), поскольку сами по себе являются объектами, и у них есть ссылка `[[Prototype]]` на объект `Function.prototype`. В этом объекте определены стандартные методы, которым может делегировать любая функция-объект. JS может делать такие вещи, *и вы тоже можете!*.

Хорошо, давайте теперь посмотрим на *слегка* упрощенную версию этой диаграммы, чтобы сделать наше сравнение чуть более "честным". Здесь показаны лишь *ключевые* сущности и взаимосвязи.

<img src="fig5.png">

По-прежнему довольно сложно, не так ли? Пунктирными линиями обозначены неявные взаимосвязи, когда вы установили "наследование" между `Foo.prototype` и `Bar.prototype`, но пока еще не *исправили* ссылку на **отсутствующее** свойство `.constructor` (см. раздел "И снова о конструкторе" в главе 5). Даже без этих пунктирных линий вам придется мысленно проделывать очень много работы каждый раз, когда вы имеете дело с объектными.

А теперь давайте посмотрим на мысленную модель для кода в OLOO-стиле:

<img src="fig6.png">

Из этого сравнения очевидно, что в OLOO-стиле вам нужно учитывать *гораздо меньшее количество нюансов*, поскольку в OLOO принимается за аксиому тот **факт**, что нас интересуют только **объекты, связанные с другими объектами**.

Весь остальной "классовый" хлам — запутанный и сложный способ для получения такого же конечного результата. Уберите его, и вещи станут гораздо проще (без потери какой-либо функциональности).

## Классы против объектов

Мы только что провели теоретические рассуждения и сравнили мысленные модели "классов" и "делегирования поведения". А теперь давайте посмотрим более реальные примеры кода, чтобы увидеть как на деле применять эти идеи.

Сначала мы рассмотрим типичный сценарий фронтенд-разработки: создание UI-виджетов (кнопки, раскрывающиеся списки, и т.п.).

### "Классы" виджетов

Если вы привыкли использовать шаблон проектирования OO, то скорее всего сразу же представите себе предметную область в виде родительского класса (например, `Widget`) с базовым поведением виджета и дочерних производных классов для виджетов конкретного типа (например, `Button`).

**Примечание:** Для работы с DOM и CSS мы используем jQuery, поскольку в данном обсуждении нас не интересуют подобные детали. В приведенном ниже коде выбор конкретного JS фреймворка (jQuery, Dojo, YUI, и т.п.) для решения рутинных задач не имеет никакого значения.

Давайте посмотрим, как бы мы могли реализовать архитектуру "классов" на чистом JS, без каких-либо вспомогательных библиотек "классов" или синтаксиса:

```js
// Родительский класс
function Widget(width,height) {
	this.width = width || 50;
	this.height = height || 50;
	this.$elem = null;
}

Widget.prototype.render = function($where){
	if (this.$elem) {
		this.$elem.css( {
			width: this.width + "px",
			height: this.height + "px"
		} ).appendTo( $where );
	}
};

// Дочерний класс
function Button(width,height,label) {
	// вызов конструктора "super"
	Widget.call( this, width, height );
	this.label = label || "Default";

	this.$elem = $( "<button>" ).text( this.label );
}

// `Button` "наследует" от `Widget`
Button.prototype = Object.create( Widget.prototype );

// переопределяем базовый "унаследованный" `render(..)`
Button.prototype.render = function($where) {
	// вызов "super"
	Widget.prototype.render.call( this, $where );
	this.$elem.click( this.onClick.bind( this ) );
};

Button.prototype.onClick = function(evt) {
	console.log( "Button '" + this.label + "' clicked!" );
};

$( document ).ready( function(){
	var $body = $( document.body );
	var btn1 = new Button( 125, 30, "Hello" );
	var btn2 = new Button( 150, 40, "World" );

	btn1.render( $body );
	btn2.render( $body );
} );
```

Шаблон проектирования OO предписывает нам объявить базовый метод `render(..)` в родительском классе, и переопределить его в дочернем классе, но не заменять его полностью, а дополнить базовую функциональность поведением, характерным для кнопки.

Обратите внимание на уродливый *явный псевдополиморфизм* ссылок `Widget.call` и `Widget.prototype.render.call` для имитации вызова "super" из методов дочернего "класса". Фу, гадость!

#### Синтаксический сахар ES6: `class`

Мы подробно рассмотрим синтаксический сахар `class` в ES6 в Приложении А. Ну а пока давайте узнаем, как мы могли бы реализовать тот же самый код с помощью `class`:

```js
class Widget {
	constructor(width,height) {
		this.width = width || 50;
		this.height = height || 50;
		this.$elem = null;
	}
	render($where){
		if (this.$elem) {
			this.$elem.css( {
				width: this.width + "px",
				height: this.height + "px"
			} ).appendTo( $where );
		}
	}
}

class Button extends Widget {
	constructor(width,height,label) {
		super( width, height );
		this.label = label || "Default";
		this.$elem = $( "<button>" ).text( this.label );
	}
	render($where) {
		super.render( $where );
		this.$elem.click( this.onClick.bind( this ) );
	}
	onClick(evt) {
		console.log( "Button '" + this.label + "' clicked!" );
	}
}

$( document ).ready( function(){
	var $body = $( document.body );
	var btn1 = new Button( 125, 30, "Hello" );
	var btn2 = new Button( 150, 40, "World" );

	btn1.render( $body );
	btn2.render( $body );
} );
```

Несомненно, `class` в ES6 делает предыдущий классический код менее ужасным. В частности, довольно приятно наличие `super(..)` (хотя если копнуть поглубже, все не так красиво!).

Несмотря на улучшение синтаксиса, **это не настоящие классы**, поскольку они по-прежнему работают поверх механизма `[[Prototype]]`. Им присущи те же самые концептуальные несостыковки, рассмотренные нами в 4 и 5 главах, и в начале этой главы. В Приложении А мы подробно изучим синтаксис `class` в ES6 и последствия его применения. Мы увидим, почему устранение проблем с синтаксисом не избавляет нас от путаницы с классами в JS, хотя и преподносится как решение.

Неважно, используете ли вы классический прототипный синтаксис или новый синтаксический сахар ES6, вы по-прежнему моделируете предметную область с помощью "классов". И как показано в нескольких предыдущих главах, такой *выбор* в JavaScript сулит вам дополнительные проблемы и концептуальные трудности.

### Делегирование объектов виджетов

Вот более простая реализация нашего примера с `Widget` / `Button`,  использующая **делегирование в стиле OLOO**:

```js
var Widget = {
	init: function(width,height){
		this.width = width || 50;
		this.height = height || 50;
		this.$elem = null;
	},
	insert: function($where){
		if (this.$elem) {
			this.$elem.css( {
				width: this.width + "px",
				height: this.height + "px"
			} ).appendTo( $where );
		}
	}
};

var Button = Object.create( Widget );

Button.setup = function(width,height,label){
	// делегированный вызов
	this.init( width, height );
	this.label = label || "Default";

	this.$elem = $( "<button>" ).text( this.label );
};
Button.build = function($where) {
	// делегированный вызов
	this.insert( $where );
	this.$elem.click( this.onClick.bind( this ) );
};
Button.onClick = function(evt) {
	console.log( "Button '" + this.label + "' clicked!" );
};

$( document ).ready( function(){
	var $body = $( document.body );

	var btn1 = Object.create( Button );
	btn1.setup( 125, 30, "Hello" );

	var btn2 = Object.create( Button );
	btn2.setup( 150, 40, "World" );

	btn1.build( $body );
	btn2.build( $body );
} );
```

Применяя OLOO-стиль, мы не думаем о `Widget` и `Button` как о родительском и дочернем классах. Вместо этого, `Widget` — **это просто объект**, некий набор утилит, которым может делегировать любой конкретный тип виджета, а `Button` — **это тоже самостоятельный объект** (с делегирующей ссылкой на `Widget`, разумеется!).

Мы **не** используем в обоих объектах одно и то же имя метода `render(..)`, как то предписывается шаблоном проектирования классов. Вместо этого мы выбрали разные имена (`insert(..)` и `build(..)`), которые более точно описывают решаемую каждым классом задачу. *Инициализирующие* методы названы `init(..)` и `setup(..)`, соответственно, по тем же причинам.

Этот шаблон проектирования с использованием делегирования не только предлагает различающиеся и более содержательные имена (вместо одинаковых и более общих), но и избавляет нас от некрасивых явных псевдополиморфных вызовов (`Widget.call` и `Widget.prototype.render.call`), заменяя их на простые, относительные делегирующие вызовы `this.init(..)` и `this.insert(..)`.

Из синтаксиса исчезли конструкторы, `.prototype` и `new`, поскольку на самом деле для нас они бесполезны.

Если вы были внимательны, то могли заметить, что вместо одного вызова (`var btn1 = new Button(..)`) у нас теперь два (`var btn1 = Object.create(Button)` и `btn1.setup(..)`). Поначалу это может показаться недостатком (больше кода).

Однако даже это является **преимуществом кодирования в OLOO-стиле** по сравнению с классическим прототипным кодом. Почему?

Конструкторы классов "вынуждают" вас выполнять создание и инициализацию за один шаг (по крайней мере, это настоятельно рекомендуется). Однако во многих случаях нужна большая гибкость и возможность выполнения этих этапов отдельно друг от друга (что и происходит в OLOO!).

Допустим, в начале программы вы создаете все сущности и помещаете их в пул, но прежде чем извлечь их из этого пула и использовать, нужно дождаться, пока они не будут инициализированы. В примере выше оба вызова находятся рядом друг c другом, но разумеется их можно выполнять в совершенно разное время и в разных местах кода, если это необходимо.

**OLOO** обеспечивает *лучшую* поддержку принципа разделения ответственности, поскольку создание и инициализацию необязательно объединять в одну операцию.

## Более простой дизайн

Помимо того, что OLOO обеспечивает нарочито более простой (и гибкий!) код, делегирование поведения может упростить архитектуру кода. Давайте рассмотрим последний пример, показывающий, как OLOO в целом упрощает дизайн.

В нашем примере будут два объекта-контроллера, один из которых обрабатывает форму входа на веб-странице, а другой отвечает за аутентификацию на сервере.

Нам понадобится вспомогательная утилита для Ajax-взаимодействия с сервером. Мы используем jQuery (хотя подойдет любой фреймворк), поскольку она не только выполняет за нас Ajax-запрос, но и возвращает в ответ promise (обещание), так что мы можем прослушивать ответ в вызывающем коде с помощью `.then(..)`.

**Примечание:** Мы рассмотрим обещания (promises) в одной из будущих книг серии "Вы не знаете JS".

Придерживаясь типичного шаблона проектирования классов, мы разобьем задачу и вынесем базовую функциональность в класс `Controller`, а затем создадим два дочерних класса, `LoginController` и `AuthController`, унаследованных от `Controller` и уточняющих базовое поведение.

```js
// Родительский класс
function Controller() {
	this.errors = [];
}
Controller.prototype.showDialog = function(title,msg) {
	// показывает пользователю заголовок и сообщение в диалоговом окне
};
Controller.prototype.success = function(msg) {
	this.showDialog( "Success", msg );
};
Controller.prototype.failure = function(err) {
	this.errors.push( err );
	this.showDialog( "Error", err );
};
```

```js
// Дочерний класс
function LoginController() {
	Controller.call( this );
}
// Привязываем дочерний класс к родительскому
LoginController.prototype = Object.create( Controller.prototype );
LoginController.prototype.getUser = function() {
	return document.getElementById( "login_username" ).value;
};
LoginController.prototype.getPassword = function() {
	return document.getElementById( "login_password" ).value;
};
LoginController.prototype.validateEntry = function(user,pw) {
	user = user || this.getUser();
	pw = pw || this.getPassword();

	if (!(user && pw)) {
		return this.failure( "Please enter a username & password!" );
	}
	else if (pw.length < 5) {
		return this.failure( "Password must be 5+ characters!" );
	}

	// добрались сюда? валидация прошла успешно!
	return true;
};
// Переопределяем для расширения базового `failure()`
LoginController.prototype.failure = function(err) {
	// вызов "super"
	Controller.prototype.failure.call( this, "Login invalid: " + err );
};
```

```js
// Дочерний класс
function AuthController(login) {
	Controller.call( this );
	// помимо наследования, нам необходима композиция
	this.login = login;
}
// Привязываем дочерний класс к родительскому
AuthController.prototype = Object.create( Controller.prototype );
AuthController.prototype.server = function(url,data) {
	return $.ajax( {
		url: url,
		data: data
	} );
};
AuthController.prototype.checkAuth = function() {
	var user = this.login.getUser();
	var pw = this.login.getPassword();

	if (this.login.validateEntry( user, pw )) {
		this.server( "/check-auth",{
			user: user,
			pw: pw
		} )
		.then( this.success.bind( this ) )
		.fail( this.failure.bind( this ) );
	}
};
//  Переопределяем для расширения базового `success()`
AuthController.prototype.success = function() {
	// вызов "super"
	Controller.prototype.success.call( this, "Authenticated!" );
};
// Переопределяем для расширения базового `failure()`
AuthController.prototype.failure = function(err) {
	// вызов "super"
	Controller.prototype.failure.call( this, "Auth Failed: " + err );
};
```

```js
var auth = new AuthController(
	// помимо наследования, нам необходима композиция
	new LoginController()
);
auth.checkAuth();
```

У всех контроллеров есть общее базовое поведение: `success(..)`, `failure(..)` и `showDialog(..)`. Дочерние классы `LoginController` и `AuthController` переопределяют `failure(..)` и `success(..)`, дополняя стандартное поведение базового класса. Обратите внимание, что `AuthController` необходим экземпляр `LoginController` для взаимодействия с формой входа, поэтому он становится свойством данных.

Мы также добавили к наследованию немного *композиции*. `AuthController` должен знать о `LoginController`, поэтому мы создаем экземпляр (`new LoginController()`) и сохраняем ссылку на него в члене данных класса `this.login`, так что `AuthController` может вызывать поведение `LoginController`.

**Примечание:** Мы могли бы поддаться легкому искушению и унаследовать `AuthController` от `LoginController`, или наоборот, получив *виртуальную композицию* в цепочке наследования. Но это яркий пример того, какие проблемы порождает наследование классов в качестве *модели* предметной области. Ведь ни `AuthController`, ни `LoginController` не уточняют поведение друг друга, поэтому наследование между ними не имеет смысла, если только классы не являются вашим единственным шаблоном проектирования. Вместо этого мы добавили простую *композицию*, и теперь оба класса могут взаимодействовать, сохранив при этом преимущества наследования от базового класса `Controller`.

Если вы разбираетесь в класс-ориентированном (ОО) проектировании, то все это должно выглядеть знакомым и естественным.

### Де-класс-ификация

Но **действительно ли нам нужно моделировать эту проблему** с помощью родительского класса `Controller`, двух дочерних классов и **композиции**? Можно ли воспользоваться преимуществами делегирования поведения в стиле OLOO и получить *гораздо* более простой дизайн? **Да!**

```js
var LoginController = {
	errors: [],
	getUser: function() {
		return document.getElementById( "login_username" ).value;
	},
	getPassword: function() {
		return document.getElementById( "login_password" ).value;
	},
	validateEntry: function(user,pw) {
		user = user || this.getUser();
		pw = pw || this.getPassword();

		if (!(user && pw)) {
			return this.failure( "Please enter a username & password!" );
		}
		else if (pw.length < 5) {
			return this.failure( "Password must be 5+ characters!" );
		}

		// добрались сюда? валидация прошла успешно!
		return true;
	},
	showDialog: function(title,msg) {
		// показывает пользователю сообщение об успехе в диалоговом окне
	},
	failure: function(err) {
		this.errors.push( err );
		this.showDialog( "Error", "Login invalid: " + err );
	}
};
```

```js
// Связываем `AuthController` для делегирования к `LoginController`
var AuthController = Object.create( LoginController );

AuthController.errors = [];
AuthController.checkAuth = function() {
	var user = this.getUser();
	var pw = this.getPassword();

	if (this.validateEntry( user, pw )) {
		this.server( "/check-auth",{
			user: user,
			pw: pw
		} )
		.then( this.accepted.bind( this ) )
		.fail( this.rejected.bind( this ) );
	}
};
AuthController.server = function(url,data) {
	return $.ajax( {
		url: url,
		data: data
	} );
};
AuthController.accepted = function() {
	this.showDialog( "Success", "Authenticated!" )
};
AuthController.rejected = function(err) {
	this.failure( "Auth Failed: " + err );
};
```

Поскольку `AuthController` теперь просто объект (как и `LoginController`), нам не нужно создавать экземпляр (`new AuthController()`) для решения нашей задачи. Все, что надо сделать:

```js
AuthController.checkAuth();
```

При работе с OLOO вы легко можете добавить один или несколько объектов в цепочку делегирования, и вам не придется создавать экземпляры классов:

```js
var controller1 = Object.create( AuthController );
var controller2 = Object.create( AuthController );
```

При делегировании поведения `AuthController` и `LoginController` являются **просто объектами**, которые находятся на одном уровне и не выстроены в иерархию, как родительские и дочерние классы в класс-ориентированом подходе. Мы выбрали направление делегирования от `AuthController` к `LoginController` произвольно — оно вполне могло быть и противоположным.

Основной результат в том, что во втором листинге кода у нас осталось только две сущности (`LoginController` и `AuthController`), **а не три** как раньше.

Нам не нужен базовый класс `Controller` с "общим" поведением для двух других, поскольку делегирование поведения — достаточно мощный механизм, предоставляющий нам все требуемую функциональность. Нам также не нужно создавать экземпляры классов, поскольку классов нет, а есть **лишь сами объекты**. Более того, нет нужды в *композиции*, потому что делегирование позволяет обоим объектам взаимодействовать как угодно.

Наконец, мы избежали ловушек с полиморфизмом в класс-ориентированном дизайне, отказавшись от одинаковых имен `success(..)` и `failure(..)` в обоих классах, ведь иначе нам потребовался бы уродливый явный псевдополиморфизм. Вместо этого, мы назвали их `accepted()` и `rejected(..)` в `AuthController`, и эти имена немного лучше описывают выполняемые задачи.

**Подведем итог**: мы получили ту же функциональность, но (гораздо) более простой дизайн. В этом и состоит мощь OLOO-стиля и шаблона проектирования *делегирования поведения*.

## Более элегантный синтаксис

Одно из приятных новшеств, которое делает `class` в ES6 обманчиво притягательным (о том, почему стоит его избегать, см. в Приложении А!), —  сокращенный синтаксис для объявления методов класса:

```js
class Foo {
	methodName() { /* .. */ }
}
```

Мы избавились от ключевого слова `function` в объявлении, что обрадовало JS-разработчиков по всему миру!

Вы наверное заметили, что в OLOO синтаксисе `function` встречается на каждом шагу, что немного расходится с нашей целью упростить код. **Но мы можем это исправить!**

В ES6 мы можем использовать *сокращенные объявления методов* в любом объектном литерале, поэтому объект в OLOO-стиле можно объявить так (такой же сокращенный синтаксис, что и в теле `class`):

```js
var LoginController = {
	errors: [],
	getUser() { // Смотри-ка, нет `function`!
		// ...
	},
	getPassword() {
		// ...
	}
	// ...
};
```

Единственная разница в том, что в объектных литералах по-прежнему надо использовать разделители `,` между элементами, тогда как синтаксис `class` этого не требует. Но на фоне общей картины это сущий пустяк.

Более того, в ES6 мы можем заменить неуклюжий синтаксис с отдельным присваиванием каждого свойства (как в определении `AuthController`) на объектный литерал (с помощью сокращенной формы записи методов), и изменить `[[Prototype]]` этого объекта на `Object.setPrototypeOf(..)`:

```js
// используем более красивый синтаксис объектного литерала
// с краткими методами!
var AuthController = {
	errors: [],
	checkAuth() {
		// ...
	},
	server(url,data) {
		// ...
	}
	// ...
};

// ТЕПЕРЬ, свяжем `AuthController` через делегирование с `LoginController`
Object.setPrototypeOf( AuthController, LoginController );
```

С краткими методами ES6 наш OLOO-стиль **стал еще более удобным** чем раньше (но даже без этого он и так был гораздо проще и симпатичнее чем классический прототипный код). Чтобы получить красивый и чистый объектный синтаксис, **вам не нужны классы**!

### Лексический недостаток

У кратких методов *есть* небольшой недостаток, о котором нужно знать. Рассмотрим код:

```js
var Foo = {
	bar() { /*..*/ },
	baz: function baz() { /*..*/ }
};
```

Если убрать синтаксический сахар, то этот код будет работать так:

```js
var Foo = {
	bar: function() { /*..*/ },
	baz: function baz() { /*..*/ }
};
```

Видите разницу? Сокращенный вариант `bar()` превратился в *анонимное функциональное выражение* (`function()..`), привязанное к свойству `bar`, поскольку у объекта функции нет имени. Сравните это с указанным вручную *именованным функциональным выражением* (`function baz()..`), которое не только привязано к свойству `.baz`, но и имеет лексический идентификатор `baz`.

И что из этого? В книге *"Область видимости и замыкания"* нашей серии *"Вы не знаете JS"*, мы подробно рассмотрели три основных недостатка *анонимных функциональных выражений*. Перечислим их еще раз и посмотрим, что из этого затрагивает краткие методы.

Отсутствие идентификатора `name` у анонимной функции:

1. усложняет отладку стектрейсов (stack traces)
2. усложняет работу с функциями, ссылающимися на самих себя (рекурсия, подписка/отписка обработчика события, и т.п.)
3. немного затрудняет понимание кода

Пункты 1 и 3 не относятся к кратким методам.

Несмотря на то, что код без синтаксического сахара превращается в *анонимное функциональное выражение*, у которого обычно нет `name` в стектрейсах, краткие методы имеют внутреннее свойство `name` для объекта функции, поэтому стектрейсы могут его использовать (хотя это зависит от реализации и не гарантируется).

Пункт 2, к сожалению, **является недостатком кратких методов**. У них нет лексического идентификатора, на который они могли бы ссылаться. Рассмотрим:

```js
var Foo = {
	bar: function(x) {
		if (x < 10) {
			return Foo.bar( x * 2 );
		}
		return x;
	},
	baz: function baz(x) {
		if (x < 10) {
			return baz( x * 2 );
		}
		return x;
	}
};
```

Явная ссылка `Foo.bar(x*2)` в этом примере вроде бы решает проблему, но во многих случаях у функции нет такой возможности, например когда функция совместно используется различными объектами через делегирование, когда используется привязка `this`, и т.п. Вам придется использовать реальную ссылку функции на саму себя, и лучший способ сделать это — идентификатор `name` объекта функции.

Просто помните об этой особенности кратких методов, и если возникнет проблема со ссылкой функции на саму себя, откажитесь от краткого синтаксиса **в данном конкретном объявлении** метода в пользу *именованного функционального выражения*: `baz: function baz(){..}`.

## Интроспекция

Если вы долгое время писали программы в класс-ориентированном стиле (в JS или других языках), то наверняка знаете, что такое *интроспекция типа*: проверка экземпляра с целью выяснить, какого *вида* объект перед вами. Основная цель *интроспекции типа* экземпляра класса — узнать о структуре и функциональных возможностях объекта исходя из того *как он был создан*.

Рассмотрим пример кода, в котором для интроспекции объекта `a1` используется `instanceof` (см. главу 5):

```js
function Foo() {
	// ...
}
Foo.prototype.something = function(){
	// ...
}

var a1 = new Foo();

// позднее

if (a1 instanceof Foo) {
	a1.something();
}
```

Благодаря `Foo.prototype` (не `Foo`!) в цепочке `[[Prototype]]` (см. главу 5) объекта `a1`, оператор `instanceof` сообщает нам, что `a1` будто бы является экземпляром "класса" `Foo`. Исходя из этого мы предполагаем, что у `a1` есть функциональные возможности, описанные в "классе" `Foo`.

Разумеется, никакого класса `Foo` не существует, есть всего-навсего обычная функция `Foo`, у которой есть ссылка на некоторый объект (`Foo.prototype`), с которым `a1` связывается ссылкой делегирования. По идее, оператор `instanceof` исходя из его названия должен проверять взаимосвязь между `a1` и `Foo`, но на самом деле он лишь сообщает нам, связаны ли `a1` и некий объект, на который ссылается `Foo.prototype`.

Семантическая путаница (и косвенность) синтаксиса `instanceof` приводит к тому, что для интроспекции объекта `a1` с целью выяснить, обладает ли он функциональными возможностями искомого объекта, вам *необходима* функция, содержащая ссылку на этот объект. То есть, вы не можете напрямую узнать, связаны ли два объекта.

Вспомните абстрактный пример `Foo` / `Bar` / `b1`, который мы рассматривали ранее в этой главе:

```js
function Foo() { /* .. */ }
Foo.prototype...

function Bar() { /* .. */ }
Bar.prototype = Object.create( Foo.prototype );

var b1 = new Bar( "b1" );
```

Вот список проверок, которые вам придется выполнить для *интроспекции типов* этих сущностей с помощью семантики `instanceof` и `.prototype`:

```js
// устанавливаем связь между `Foo` и `Bar`
Bar.prototype instanceof Foo; // true
Object.getPrototypeOf( Bar.prototype ) === Foo.prototype; // true
Foo.prototype.isPrototypeOf( Bar.prototype ); // true

// устанавливаем связь между `b1` и `Foo` и `Bar`
b1 instanceof Foo; // true
b1 instanceof Bar; // true
Object.getPrototypeOf( b1 ) === Bar.prototype; // true
Foo.prototype.isPrototypeOf( b1 ); // true
Bar.prototype.isPrototypeOf( b1 ); // true
```

Согласитесь, что это немного отстойно. Например, интуитивно хочется, чтобы была возможность написать что-то вроде `Bar instanceof Foo` (потому что "instance" — довольно широкое понятие, и можно подумать, что оно включает в себя и "наследование"). Но такое сравнение в JS бессмысленно. Вместо этого приходится использовать `Bar.prototype instanceof Foo`.

Еще один распространенный, но возможно менее надежный метод *интроспекции типов*, который многие разработчики предпочитают оператору `instanceof`, называется "утиная типизация". Этот термин берет свое начало из афоризма "если нечто выглядит как утка и крякает как утка, то возможно это и есть утка".

Пример:

```js
if (a1.something) {
	a1.something();
}
```

Вместо того, чтобы проверять связь между `a1` и объектом, содержащим делегируемую функцию  `something()`, мы предполагаем, что успешная проверка `a1.something` означает, что `a1` позволяет вызывать `.something()` (неважно, найден ли метод непосредственно в `a1` или делегирован какому-то другому объекту). Само по себе это предположение не такое уж и рискованное.

Однако зачастую понятие "утиной типизации" расширяется, и делаются **дополнительные предположения о возможностях объекта**, выходящие за рамки проверки. Разумеется, это увеличивает риски и делает дизайн более хрупким.

Ярким примером "утиной типизации" являются обещания (Promises) в ES6 (как мы уже говорили, их рассмотрение выходит за рамки этой книги).

В ряде случаев возникает необходимость проверить, является ли ссылка на некий объект *обещанием*, причем это делается путем проверки наличия у объекта функции `then()`. Другими словами, **если у какого угодно объекта** найдется метод `then()`, то механизм обещаний ES6 будет считать что это **"thenable"** объект, и будет ожидать от него стандартного поведения Promises.

Если у вас какой-либо не-Promise объект, у которого по какой-то причине есть метод `then()`, то настоятельно рекомендуется держать его подальше от механизма ES6 Promise, чтобы избежать некорректных предположений.

Этот пример наглядно иллюстрирует риски "утиной типизации". Подобные вещи следует использовать лишь в разумных пределах и в контролируемом окружении.

Возвращаясь к коду в стиле OLOO отметим, что *интроспекция типов* в данном случае может быть гораздо элегантнее. Давайте вспомним фрагмент OLOO кода `Foo` / `Bar` / `b1`, рассмотренный ранее в этой главе:

```js
var Foo = { /* .. */ };

var Bar = Object.create( Foo );
Bar...

var b1 = Object.create( Bar );
```

Поскольку в OLOO у нас есть лишь обычные объекты, связанные делегированием `[[Prototype]]`, мы можем использовать гораздо более простую форму *интроспекции типов*:

```js
// устанавливаем связь между `Foo` и `Bar`
Foo.isPrototypeOf( Bar ); // true
Object.getPrototypeOf( Bar ) === Foo; // true

// устанавливаем связь между `b1` и `Foo` и `Bar`
Foo.isPrototypeOf( b1 ); // true
Bar.isPrototypeOf( b1 ); // true
Object.getPrototypeOf( b1 ) === Bar; // true
```

Мы больше не используем `instanceof`, потому что он претендует на то, что каким-то образом связан с классами. Теперь мы просто задаем (неформальный) вопрос "являешься ли ты моим прототипом?" Больше не нужны косвенные обращения, такие как `Foo.prototype` или ужасно многословное `Foo.prototype.isPrototypeOf(..)`.

Я считаю, что эти проверки гораздо более простые и не такие запутанные, как предыдущий набор интроспектирующих проверок. **И снова мы видим, что в JavaScript подход OLOO проще, чем кодирование в стиле классов (и при этом обладает теми же возможностями).**

## Обзор (TL;DR)

Классы и наследование — это один из возможных шаблонов проектирования, который вы можете *использовать* или *не использовать* в архитектуре вашего ПО. Большинство разработчиков считают само собой разумеющимся тот факт, что классы являются единственным (правильным) способом организации кода. Но в этой главе мы увидели другой, менее популярный, но весьма мощный шаблон проектирования: **делегирование поведения**.

Делегирование поведения предполагает, что все объекты находятся на одном уровне и связаны друг с другом делегированием, а не отношениями родитель-потомок. Механизм `[[Prototype]]` в JavaScript по своему замыслу является механизмом делегирования поведения. Это значит, что мы можем либо всячески пытаться реализовать механику классов поверх JS (см. главы 4 и 5), либо принять истинную сущность `[[Prototype]]` как механизма делегирования.

Если вы проектируете код, используя только объекты, это не только упрощает синтаксис, но и позволяет добиться более простой архитектуры кода.

**OLOO** (объекты, связанные с другими объектами) — это стиль кодирования, в котором объекты создаются и связываются друг с другом без абстракции классов. OLOO вполне естественным образом реализует делегирование поведения при помощи `[[Prototype]]`.