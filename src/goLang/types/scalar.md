## Скалярные типы данных

### Целочисленные типы

- **int8**, **int16**, **int32**, **int64**, **int**
- **uint8**, **uint16**, **uint32**, **uint64**, **uint**
- **byte**: синоним типа **`uint8`**
- **rune**: синоним типа **`int32`**

Стоит отметить типы **int** и **uint**. Они имеют наиболее эффективный размер для определенной платформы (**32** или **64** бита). Это наиболее используемый тип для представления целых чисел в программе. Причем различные компиляторы могут предоставлять различный размер для этих типов даже для одной и той же платформы. 


### Числа с плавающей точкой(дробные)

- **float32**: представляет число с плавающей точкой от 1.4*10-45 до 3.4*1038(для положительных). Занимает в памяти **4 байта (32 бита)**
- **float64**: представляет число с плавающей точкой от 4.9*10-324 до 1.8*10308 (для положительных) и занимает **8 байт**.

Тип **float32** обеспечивает шесть десятичных цифр точности, в то время как точность, обеспечиваемая типом **float64**, составляет около 15 цифр. В качестве разделителя между целой и дробной частью применяется точка.

### Комплексные числа

- **complex64**: комплексное число, где вещественная и мнимая части представляют числа float32
- **complex128**: комплексное число, где вещественная и мнимая части представляют числа float64

### Bool

Логический тип или тип **bool** может иметь одно из двух значений: **true** (истина) или **false** (ложь).

### Строки

Строки же представляют собой **неизменяемый** последовательный набор байт **фиксированного размера**. Это означает, что нельзя изменять строки — только создавать новые. Это важно понимать в контексте производительности программы. В программах, где нужна очень высокая производительность, постоянное создание большого количества строк создаст ощутимую нагрузку на сборщик мусора.


Строка в Go — это внутренняя структура данных, состоящая из двух слов:

Первое слово представляет указатель на базовый массив байт.
Второе слово представляет длину или количество байт в базовом массиве.
Если строка установлена в значение по умолчанию `""`, то первое слово равно `nil`, а второе слово равно `0`.

С юникод строками удобнее работать как со слайсами из **rune**

```go
func main() {
   message := "Строка"

    // тут перебираем строку как массив байт
   for i := 0; i < len(message); i++ {
      fmt.Printf("Type: %T, Val: %s\n", message[i], string(message[i])) // Type: uint8, Val: Ð
   }

   // тут как массив рун
   for _, val := range message {
      fmt.Printf("Type: %T, Val: %s\n", val, string(val)) // Type: int32, Val: С
   }
}
```



### Константы

Константы вычисляются на тапе компиляции и не меняются в рантайме. Имеют интересную систему типов(чуть отличающуюся от фундаментальных), имеют повышенную точность. Есть генератор констант **iota**.

### Значение по умолчанию

Если переменной не присвоено значение, то она имеет значение по умолчанию, которое определено для ее типа. Для числовых типов это число **0**, для логического типа - **false**, для строк - **пустая строка("")**.